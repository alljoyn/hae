From 050f7140c7072a5a41b051e8f0b4bd7310b95040 Mon Sep 17 00:00:00 2001
From: Nikolai Kovalev <nikolai.kovalev@electrolux.com>
Date: Fri, 26 Feb 2016 00:39:58 -0800
Subject: [PATCH] Update Interfaces related to Electrolux

-Fixed returned status in SetCurrentLevel and SetMaxLevel function of WaterLevel interface if validation not passed

Change-Id: Id957fb92583482445bb8c4753d2a6955a17ae3ef
Signed-off-by: Nikolai Kovalev <nikolai.kovalev@electrolux.com>
---
 .../interfaces/environment/WaterLevelInterface.h   |  80 +++++
 .../environment/WaterLevelIntfControllee.h         |  85 +++++
 .../environment/WaterLevelIntfControlleeListener.h |  68 ++++
 .../environment/WaterLevelIntfController.h         |  67 ++++
 .../environment/WaterLevelIntfControllerListener.h |  83 +++++
 .../interfaces/operation/CycleControlInterface.h   |  99 ++++++
 .../operation/CycleControlIntfControllee.h         |  92 +++++
 .../operation/CycleControlIntfControlleeListener.h |  60 ++++
 .../operation/CycleControlIntfController.h         |  76 ++++
 .../operation/CycleControlIntfControllerListener.h | 104 ++++++
 .../operation/DishWashingCyclePhaseInterface.h     |  95 +++++
 .../DishWashingCyclePhaseIntfControllee.h          |  80 +++++
 .../DishWashingCyclePhaseIntfControlleeListener.h  |  71 ++++
 .../DishWashingCyclePhaseIntfController.h          |  68 ++++
 .../DishWashingCyclePhaseIntfControllerListener.h  |  83 +++++
 .../interfaces/operation/HeatingZoneInterface.h    |  75 ++++
 .../operation/HeatingZoneIntfControllee.h          |  86 +++++
 .../operation/HeatingZoneIntfControlleeListener.h  |  65 ++++
 .../operation/HeatingZoneIntfController.h          |  52 +++
 .../operation/HeatingZoneIntfControllerListener.h  |  87 +++++
 .../operation/LaundryCyclePhaseInterface.h         | 100 ++++++
 .../operation/LaundryCyclePhaseIntfControllee.h    |  80 +++++
 .../LaundryCyclePhaseIntfControlleeListener.h      |  70 ++++
 .../operation/LaundryCyclePhaseIntfController.h    |  68 ++++
 .../LaundryCyclePhaseIntfControllerListener.h      |  83 +++++
 .../interfaces/operation/OvenCyclePhaseInterface.h |  96 ++++++
 .../operation/OvenCyclePhaseIntfControllee.h       |  79 +++++
 .../OvenCyclePhaseIntfControlleeListener.h         |  70 ++++
 .../operation/OvenCyclePhaseIntfController.h       |  68 ++++
 .../OvenCyclePhaseIntfControllerListener.h         |  83 +++++
 .../hae/interfaces/operation/RapidModeInterface.h  |  76 ++++
 .../interfaces/operation/RapidModeIntfControllee.h |  60 ++++
 .../operation/RapidModeIntfControlleeListener.h    |  50 +++
 .../interfaces/operation/RapidModeIntfController.h |  50 +++
 .../operation/RapidModeIntfControllerListener.h    |  44 +++
 .../operation/RemoteControllabilityInterface.h     |  72 ++++
 .../RemoteControllabilityIntfControllee.h          |  60 ++++
 .../RemoteControllabilityIntfControlleeListener.h  |  50 +++
 .../RemoteControllabilityIntfController.h          |  54 +++
 .../RemoteControllabilityIntfControllerListener.h  |  55 +++
 .../hae/interfaces/operation/SoilLevelInterface.h  |  78 +++++
 .../interfaces/operation/SoilLevelIntfControllee.h |  86 +++++
 .../operation/SoilLevelIntfControlleeListener.h    |  88 +++++
 .../interfaces/operation/SoilLevelIntfController.h |  75 ++++
 .../operation/SoilLevelIntfControllerListener.h    |  96 ++++++
 .../interfaces/operation/SpinSpeedLevelInterface.h |  75 ++++
 .../operation/SpinSpeedLevelIntfControllee.h       |  86 +++++
 .../SpinSpeedLevelIntfControlleeListener.h         |  88 +++++
 .../operation/SpinSpeedLevelIntfController.h       |  75 ++++
 .../SpinSpeedLevelIntfControllerListener.h         |  96 ++++++
 .../hae/interfaces/operation/TimerInterface.h      |  81 +++++
 .../hae/interfaces/operation/TimerIntfControllee.h | 110 ++++++
 .../operation/TimerIntfControlleeListener.h        | 105 ++++++
 .../hae/interfaces/operation/TimerIntfController.h | 105 ++++++
 .../operation/TimerIntfControllerListener.h        | 144 ++++++++
 .../BaseSample/Controllee/CycleControlListener.cc  |  35 ++
 .../BaseSample/Controllee/CycleControlListener.h   |  35 ++
 .../Controllee/DishWashingCyclePhaseListener.cc    |  64 ++++
 .../Controllee/DishWashingCyclePhaseListener.h     |  38 ++
 .../BaseSample/Controllee/HeatingZoneListener.cc   |  37 ++
 .../BaseSample/Controllee/HeatingZoneListener.h    |  53 +++
 .../Controllee/LaundryCyclePhaseListener.cc        |  64 ++++
 .../Controllee/LaundryCyclePhaseListener.h         |  38 ++
 .../Controllee/OvenCyclePhaseListener.cc           |  64 ++++
 .../BaseSample/Controllee/OvenCyclePhaseListener.h |  38 ++
 .../BaseSample/Controllee/RapidModeListener.cc     |  33 ++
 .../BaseSample/Controllee/RapidModeListener.h      |  34 ++
 .../Controllee/RemoteControllabilityListener.cc    |  27 ++
 .../Controllee/RemoteControllabilityListener.h     |  31 ++
 .../BaseSample/Controllee/SoilLevelListener.cc     |  58 ++++
 .../BaseSample/Controllee/SoilLevelListener.h      |  41 +++
 .../Controllee/SpinSpeedLevelListener.cc           |  58 ++++
 .../BaseSample/Controllee/SpinSpeedLevelListener.h |  41 +++
 cpp/samples/BaseSample/Controllee/TimerListener.cc |  70 ++++
 cpp/samples/BaseSample/Controllee/TimerListener.h  |  46 +++
 .../BaseSample/Controllee/WaterLevelListener.cc    |  46 +++
 .../BaseSample/Controllee/WaterLevelListener.h     |  35 ++
 .../BaseSample/Controller/ClosedStatusCommands.cc  |   2 +-
 .../BaseSample/Controller/CycleControlCommands.cc  | 193 +++++++++++
 .../BaseSample/Controller/CycleControlCommands.h   |  72 ++++
 .../BaseSample/Controller/DeviceCommands.cc        |  34 ++
 .../Controller/DishWashingCyclePhaseCommands.cc    | 142 ++++++++
 .../Controller/DishWashingCyclePhaseCommands.h     |  64 ++++
 .../BaseSample/Controller/HeatingZoneCommands.cc   | 149 ++++++++
 .../BaseSample/Controller/HeatingZoneCommands.h    |  62 ++++
 .../Controller/LaundryCyclePhaseCommands.cc        | 141 ++++++++
 .../Controller/LaundryCyclePhaseCommands.h         |  64 ++++
 .../Controller/OvenCyclePhaseCommands.cc           | 141 ++++++++
 .../BaseSample/Controller/OvenCyclePhaseCommands.h |  64 ++++
 .../BaseSample/Controller/RapidModeCommands.cc     | 107 ++++++
 .../BaseSample/Controller/RapidModeCommands.h      |  57 +++
 .../Controller/RemoteControllabilityCommands.cc    |  85 +++++
 .../Controller/RemoteControllabilityCommands.h     |  55 +++
 .../BaseSample/Controller/SoilLevelCommands.cc     | 169 +++++++++
 .../BaseSample/Controller/SoilLevelCommands.h      |  69 ++++
 .../Controller/SpinSpeedLevelCommands.cc           | 169 +++++++++
 .../BaseSample/Controller/SpinSpeedLevelCommands.h |  69 ++++
 cpp/samples/BaseSample/Controller/TimerCommands.cc | 242 +++++++++++++
 cpp/samples/BaseSample/Controller/TimerCommands.h  |  77 +++++
 .../BaseSample/Controller/WaterLevelCommands.cc    | 131 +++++++
 .../BaseSample/Controller/WaterLevelCommands.h     |  61 ++++
 cpp/samples/CookTopControllee/CookTopControllee.cc | 243 +++++++++++++
 cpp/samples/CookTopControllee/SConscript           |  28 ++
 cpp/samples/LaundryControllee/LaundryControllee.cc | 373 ++++++++++++++++++++
 cpp/samples/LaundryControllee/SConscript           |  28 ++
 cpp/samples/SConscript                             |   4 +-
 cpp/samples/TvControllee/TvControllee.cc           |   2 +-
 cpp/src/InterfaceFactory.cc                        |  44 +++
 .../interfaces/environment/WaterLevelInterface.cc  |  57 +++
 .../environment/WaterLevelIntfControlleeImpl.cc    | 214 ++++++++++++
 .../environment/WaterLevelIntfControlleeImpl.h     | 147 ++++++++
 .../environment/WaterLevelIntfControllerImpl.cc    | 157 +++++++++
 .../environment/WaterLevelIntfControllerImpl.h     |  86 +++++
 .../interfaces/operation/CycleControlInterface.cc  |  83 +++++
 .../operation/CycleControlIntfControlleeImpl.cc    | 332 ++++++++++++++++++
 .../operation/CycleControlIntfControlleeImpl.h     | 159 +++++++++
 .../operation/CycleControlIntfControllerImpl.cc    | 235 +++++++++++++
 .../operation/CycleControlIntfControllerImpl.h     | 114 ++++++
 .../operation/DishWashingCyclePhaseInterface.cc    |  67 ++++
 .../DishWashingCyclePhaseIntfControlleeImpl.cc     | 347 +++++++++++++++++++
 .../DishWashingCyclePhaseIntfControlleeImpl.h      | 119 +++++++
 .../DishWashingCyclePhaseIntfControllerImpl.cc     | 197 +++++++++++
 .../DishWashingCyclePhaseIntfControllerImpl.h      |  85 +++++
 .../interfaces/operation/HeatingZoneInterface.cc   |  57 +++
 .../operation/HeatingZoneIntfControlleeImpl.cc     | 302 ++++++++++++++++
 .../operation/HeatingZoneIntfControlleeImpl.h      | 147 ++++++++
 .../operation/HeatingZoneIntfControllerImpl.cc     | 183 ++++++++++
 .../operation/HeatingZoneIntfControllerImpl.h      |  87 +++++
 .../operation/LaundryCyclePhaseInterface.cc        |  63 ++++
 .../LaundryCyclePhaseIntfControlleeImpl.cc         | 345 +++++++++++++++++++
 .../LaundryCyclePhaseIntfControlleeImpl.h          | 121 +++++++
 .../LaundryCyclePhaseIntfControllerImpl.cc         | 206 +++++++++++
 .../LaundryCyclePhaseIntfControllerImpl.h          |  85 +++++
 .../operation/OvenCyclePhaseInterface.cc           |  63 ++++
 .../operation/OvenCyclePhaseIntfControlleeImpl.cc  | 345 +++++++++++++++++++
 .../operation/OvenCyclePhaseIntfControlleeImpl.h   | 120 +++++++
 .../operation/OvenCyclePhaseIntfControllerImpl.cc  | 197 +++++++++++
 .../operation/OvenCyclePhaseIntfControllerImpl.h   |  85 +++++
 cpp/src/interfaces/operation/RapidModeInterface.cc |  50 +++
 .../operation/RapidModeIntfControlleeImpl.cc       | 165 +++++++++
 .../operation/RapidModeIntfControlleeImpl.h        | 118 +++++++
 .../operation/RapidModeIntfControllerImpl.cc       | 135 ++++++++
 .../operation/RapidModeIntfControllerImpl.h        |  93 +++++
 .../operation/RemoteControllabilityInterface.cc    |  47 +++
 .../RemoteControllabilityIntfControlleeImpl.cc     | 153 +++++++++
 .../RemoteControllabilityIntfControlleeImpl.h      | 118 +++++++
 .../RemoteControllabilityIntfControllerImpl.cc     | 106 ++++++
 .../RemoteControllabilityIntfControllerImpl.h      |  83 +++++
 cpp/src/interfaces/operation/SoilLevelInterface.cc |  60 ++++
 .../operation/SoilLevelIntfControlleeImpl.cc       | 246 +++++++++++++
 .../operation/SoilLevelIntfControlleeImpl.h        | 146 ++++++++
 .../operation/SoilLevelIntfControllerImpl.cc       | 208 +++++++++++
 .../operation/SoilLevelIntfControllerImpl.h        | 118 +++++++
 .../operation/SpinSpeedLevelInterface.cc           |  56 +++
 .../operation/SpinSpeedLevelIntfControlleeImpl.cc  | 250 ++++++++++++++
 .../operation/SpinSpeedLevelIntfControlleeImpl.h   | 147 ++++++++
 .../operation/SpinSpeedLevelIntfControllerImpl.cc  | 188 ++++++++++
 .../operation/SpinSpeedLevelIntfControllerImpl.h   | 109 ++++++
 cpp/src/interfaces/operation/TimerInterface.cc     |  82 +++++
 .../operation/TimerIntfControlleeImpl.cc           | 381 +++++++++++++++++++++
 .../interfaces/operation/TimerIntfControlleeImpl.h | 129 +++++++
 .../operation/TimerIntfControllerImpl.cc           | 292 ++++++++++++++++
 .../interfaces/operation/TimerIntfControllerImpl.h | 102 ++++++
 163 files changed, 16843 insertions(+), 3 deletions(-)
 create mode 100644 cpp/inc/alljoyn/hae/interfaces/environment/WaterLevelInterface.h
 create mode 100644 cpp/inc/alljoyn/hae/interfaces/environment/WaterLevelIntfControllee.h
 create mode 100644 cpp/inc/alljoyn/hae/interfaces/environment/WaterLevelIntfControlleeListener.h
 create mode 100644 cpp/inc/alljoyn/hae/interfaces/environment/WaterLevelIntfController.h
 create mode 100644 cpp/inc/alljoyn/hae/interfaces/environment/WaterLevelIntfControllerListener.h
 create mode 100644 cpp/inc/alljoyn/hae/interfaces/operation/CycleControlInterface.h
 create mode 100644 cpp/inc/alljoyn/hae/interfaces/operation/CycleControlIntfControllee.h
 create mode 100644 cpp/inc/alljoyn/hae/interfaces/operation/CycleControlIntfControlleeListener.h
 create mode 100644 cpp/inc/alljoyn/hae/interfaces/operation/CycleControlIntfController.h
 create mode 100644 cpp/inc/alljoyn/hae/interfaces/operation/CycleControlIntfControllerListener.h
 create mode 100644 cpp/inc/alljoyn/hae/interfaces/operation/DishWashingCyclePhaseInterface.h
 create mode 100644 cpp/inc/alljoyn/hae/interfaces/operation/DishWashingCyclePhaseIntfControllee.h
 create mode 100644 cpp/inc/alljoyn/hae/interfaces/operation/DishWashingCyclePhaseIntfControlleeListener.h
 create mode 100644 cpp/inc/alljoyn/hae/interfaces/operation/DishWashingCyclePhaseIntfController.h
 create mode 100644 cpp/inc/alljoyn/hae/interfaces/operation/DishWashingCyclePhaseIntfControllerListener.h
 create mode 100644 cpp/inc/alljoyn/hae/interfaces/operation/HeatingZoneInterface.h
 create mode 100644 cpp/inc/alljoyn/hae/interfaces/operation/HeatingZoneIntfControllee.h
 create mode 100644 cpp/inc/alljoyn/hae/interfaces/operation/HeatingZoneIntfControlleeListener.h
 create mode 100644 cpp/inc/alljoyn/hae/interfaces/operation/HeatingZoneIntfController.h
 create mode 100644 cpp/inc/alljoyn/hae/interfaces/operation/HeatingZoneIntfControllerListener.h
 create mode 100644 cpp/inc/alljoyn/hae/interfaces/operation/LaundryCyclePhaseInterface.h
 create mode 100644 cpp/inc/alljoyn/hae/interfaces/operation/LaundryCyclePhaseIntfControllee.h
 create mode 100644 cpp/inc/alljoyn/hae/interfaces/operation/LaundryCyclePhaseIntfControlleeListener.h
 create mode 100644 cpp/inc/alljoyn/hae/interfaces/operation/LaundryCyclePhaseIntfController.h
 create mode 100644 cpp/inc/alljoyn/hae/interfaces/operation/LaundryCyclePhaseIntfControllerListener.h
 create mode 100644 cpp/inc/alljoyn/hae/interfaces/operation/OvenCyclePhaseInterface.h
 create mode 100644 cpp/inc/alljoyn/hae/interfaces/operation/OvenCyclePhaseIntfControllee.h
 create mode 100644 cpp/inc/alljoyn/hae/interfaces/operation/OvenCyclePhaseIntfControlleeListener.h
 create mode 100644 cpp/inc/alljoyn/hae/interfaces/operation/OvenCyclePhaseIntfController.h
 create mode 100644 cpp/inc/alljoyn/hae/interfaces/operation/OvenCyclePhaseIntfControllerListener.h
 create mode 100644 cpp/inc/alljoyn/hae/interfaces/operation/RapidModeInterface.h
 create mode 100644 cpp/inc/alljoyn/hae/interfaces/operation/RapidModeIntfControllee.h
 create mode 100644 cpp/inc/alljoyn/hae/interfaces/operation/RapidModeIntfControlleeListener.h
 create mode 100644 cpp/inc/alljoyn/hae/interfaces/operation/RapidModeIntfController.h
 create mode 100644 cpp/inc/alljoyn/hae/interfaces/operation/RapidModeIntfControllerListener.h
 create mode 100644 cpp/inc/alljoyn/hae/interfaces/operation/RemoteControllabilityInterface.h
 create mode 100644 cpp/inc/alljoyn/hae/interfaces/operation/RemoteControllabilityIntfControllee.h
 create mode 100644 cpp/inc/alljoyn/hae/interfaces/operation/RemoteControllabilityIntfControlleeListener.h
 create mode 100644 cpp/inc/alljoyn/hae/interfaces/operation/RemoteControllabilityIntfController.h
 create mode 100644 cpp/inc/alljoyn/hae/interfaces/operation/RemoteControllabilityIntfControllerListener.h
 create mode 100644 cpp/inc/alljoyn/hae/interfaces/operation/SoilLevelInterface.h
 create mode 100644 cpp/inc/alljoyn/hae/interfaces/operation/SoilLevelIntfControllee.h
 create mode 100644 cpp/inc/alljoyn/hae/interfaces/operation/SoilLevelIntfControlleeListener.h
 create mode 100644 cpp/inc/alljoyn/hae/interfaces/operation/SoilLevelIntfController.h
 create mode 100644 cpp/inc/alljoyn/hae/interfaces/operation/SoilLevelIntfControllerListener.h
 create mode 100644 cpp/inc/alljoyn/hae/interfaces/operation/SpinSpeedLevelInterface.h
 create mode 100644 cpp/inc/alljoyn/hae/interfaces/operation/SpinSpeedLevelIntfControllee.h
 create mode 100644 cpp/inc/alljoyn/hae/interfaces/operation/SpinSpeedLevelIntfControlleeListener.h
 create mode 100644 cpp/inc/alljoyn/hae/interfaces/operation/SpinSpeedLevelIntfController.h
 create mode 100644 cpp/inc/alljoyn/hae/interfaces/operation/SpinSpeedLevelIntfControllerListener.h
 create mode 100644 cpp/inc/alljoyn/hae/interfaces/operation/TimerInterface.h
 create mode 100644 cpp/inc/alljoyn/hae/interfaces/operation/TimerIntfControllee.h
 create mode 100644 cpp/inc/alljoyn/hae/interfaces/operation/TimerIntfControlleeListener.h
 create mode 100644 cpp/inc/alljoyn/hae/interfaces/operation/TimerIntfController.h
 create mode 100644 cpp/inc/alljoyn/hae/interfaces/operation/TimerIntfControllerListener.h
 create mode 100644 cpp/samples/BaseSample/Controllee/CycleControlListener.cc
 create mode 100644 cpp/samples/BaseSample/Controllee/CycleControlListener.h
 create mode 100644 cpp/samples/BaseSample/Controllee/DishWashingCyclePhaseListener.cc
 create mode 100644 cpp/samples/BaseSample/Controllee/DishWashingCyclePhaseListener.h
 create mode 100644 cpp/samples/BaseSample/Controllee/HeatingZoneListener.cc
 create mode 100644 cpp/samples/BaseSample/Controllee/HeatingZoneListener.h
 create mode 100644 cpp/samples/BaseSample/Controllee/LaundryCyclePhaseListener.cc
 create mode 100644 cpp/samples/BaseSample/Controllee/LaundryCyclePhaseListener.h
 create mode 100644 cpp/samples/BaseSample/Controllee/OvenCyclePhaseListener.cc
 create mode 100644 cpp/samples/BaseSample/Controllee/OvenCyclePhaseListener.h
 create mode 100644 cpp/samples/BaseSample/Controllee/RapidModeListener.cc
 create mode 100644 cpp/samples/BaseSample/Controllee/RapidModeListener.h
 create mode 100644 cpp/samples/BaseSample/Controllee/RemoteControllabilityListener.cc
 create mode 100644 cpp/samples/BaseSample/Controllee/RemoteControllabilityListener.h
 create mode 100644 cpp/samples/BaseSample/Controllee/SoilLevelListener.cc
 create mode 100644 cpp/samples/BaseSample/Controllee/SoilLevelListener.h
 create mode 100644 cpp/samples/BaseSample/Controllee/SpinSpeedLevelListener.cc
 create mode 100644 cpp/samples/BaseSample/Controllee/SpinSpeedLevelListener.h
 create mode 100644 cpp/samples/BaseSample/Controllee/TimerListener.cc
 create mode 100644 cpp/samples/BaseSample/Controllee/TimerListener.h
 create mode 100644 cpp/samples/BaseSample/Controllee/WaterLevelListener.cc
 create mode 100644 cpp/samples/BaseSample/Controllee/WaterLevelListener.h
 create mode 100644 cpp/samples/BaseSample/Controller/CycleControlCommands.cc
 create mode 100644 cpp/samples/BaseSample/Controller/CycleControlCommands.h
 create mode 100644 cpp/samples/BaseSample/Controller/DishWashingCyclePhaseCommands.cc
 create mode 100644 cpp/samples/BaseSample/Controller/DishWashingCyclePhaseCommands.h
 create mode 100644 cpp/samples/BaseSample/Controller/HeatingZoneCommands.cc
 create mode 100644 cpp/samples/BaseSample/Controller/HeatingZoneCommands.h
 create mode 100644 cpp/samples/BaseSample/Controller/LaundryCyclePhaseCommands.cc
 create mode 100644 cpp/samples/BaseSample/Controller/LaundryCyclePhaseCommands.h
 create mode 100644 cpp/samples/BaseSample/Controller/OvenCyclePhaseCommands.cc
 create mode 100644 cpp/samples/BaseSample/Controller/OvenCyclePhaseCommands.h
 create mode 100644 cpp/samples/BaseSample/Controller/RapidModeCommands.cc
 create mode 100644 cpp/samples/BaseSample/Controller/RapidModeCommands.h
 create mode 100644 cpp/samples/BaseSample/Controller/RemoteControllabilityCommands.cc
 create mode 100644 cpp/samples/BaseSample/Controller/RemoteControllabilityCommands.h
 create mode 100644 cpp/samples/BaseSample/Controller/SoilLevelCommands.cc
 create mode 100644 cpp/samples/BaseSample/Controller/SoilLevelCommands.h
 create mode 100644 cpp/samples/BaseSample/Controller/SpinSpeedLevelCommands.cc
 create mode 100644 cpp/samples/BaseSample/Controller/SpinSpeedLevelCommands.h
 create mode 100644 cpp/samples/BaseSample/Controller/TimerCommands.cc
 create mode 100644 cpp/samples/BaseSample/Controller/TimerCommands.h
 create mode 100644 cpp/samples/BaseSample/Controller/WaterLevelCommands.cc
 create mode 100644 cpp/samples/BaseSample/Controller/WaterLevelCommands.h
 create mode 100644 cpp/samples/CookTopControllee/CookTopControllee.cc
 create mode 100644 cpp/samples/CookTopControllee/SConscript
 create mode 100644 cpp/samples/LaundryControllee/LaundryControllee.cc
 create mode 100644 cpp/samples/LaundryControllee/SConscript
 create mode 100644 cpp/src/interfaces/environment/WaterLevelInterface.cc
 create mode 100644 cpp/src/interfaces/environment/WaterLevelIntfControlleeImpl.cc
 create mode 100644 cpp/src/interfaces/environment/WaterLevelIntfControlleeImpl.h
 create mode 100644 cpp/src/interfaces/environment/WaterLevelIntfControllerImpl.cc
 create mode 100644 cpp/src/interfaces/environment/WaterLevelIntfControllerImpl.h
 create mode 100644 cpp/src/interfaces/operation/CycleControlInterface.cc
 create mode 100644 cpp/src/interfaces/operation/CycleControlIntfControlleeImpl.cc
 create mode 100644 cpp/src/interfaces/operation/CycleControlIntfControlleeImpl.h
 create mode 100644 cpp/src/interfaces/operation/CycleControlIntfControllerImpl.cc
 create mode 100644 cpp/src/interfaces/operation/CycleControlIntfControllerImpl.h
 create mode 100644 cpp/src/interfaces/operation/DishWashingCyclePhaseInterface.cc
 create mode 100644 cpp/src/interfaces/operation/DishWashingCyclePhaseIntfControlleeImpl.cc
 create mode 100644 cpp/src/interfaces/operation/DishWashingCyclePhaseIntfControlleeImpl.h
 create mode 100644 cpp/src/interfaces/operation/DishWashingCyclePhaseIntfControllerImpl.cc
 create mode 100644 cpp/src/interfaces/operation/DishWashingCyclePhaseIntfControllerImpl.h
 create mode 100644 cpp/src/interfaces/operation/HeatingZoneInterface.cc
 create mode 100644 cpp/src/interfaces/operation/HeatingZoneIntfControlleeImpl.cc
 create mode 100644 cpp/src/interfaces/operation/HeatingZoneIntfControlleeImpl.h
 create mode 100644 cpp/src/interfaces/operation/HeatingZoneIntfControllerImpl.cc
 create mode 100644 cpp/src/interfaces/operation/HeatingZoneIntfControllerImpl.h
 create mode 100644 cpp/src/interfaces/operation/LaundryCyclePhaseInterface.cc
 create mode 100644 cpp/src/interfaces/operation/LaundryCyclePhaseIntfControlleeImpl.cc
 create mode 100644 cpp/src/interfaces/operation/LaundryCyclePhaseIntfControlleeImpl.h
 create mode 100644 cpp/src/interfaces/operation/LaundryCyclePhaseIntfControllerImpl.cc
 create mode 100644 cpp/src/interfaces/operation/LaundryCyclePhaseIntfControllerImpl.h
 create mode 100644 cpp/src/interfaces/operation/OvenCyclePhaseInterface.cc
 create mode 100644 cpp/src/interfaces/operation/OvenCyclePhaseIntfControlleeImpl.cc
 create mode 100644 cpp/src/interfaces/operation/OvenCyclePhaseIntfControlleeImpl.h
 create mode 100644 cpp/src/interfaces/operation/OvenCyclePhaseIntfControllerImpl.cc
 create mode 100644 cpp/src/interfaces/operation/OvenCyclePhaseIntfControllerImpl.h
 create mode 100644 cpp/src/interfaces/operation/RapidModeInterface.cc
 create mode 100644 cpp/src/interfaces/operation/RapidModeIntfControlleeImpl.cc
 create mode 100644 cpp/src/interfaces/operation/RapidModeIntfControlleeImpl.h
 create mode 100644 cpp/src/interfaces/operation/RapidModeIntfControllerImpl.cc
 create mode 100644 cpp/src/interfaces/operation/RapidModeIntfControllerImpl.h
 create mode 100644 cpp/src/interfaces/operation/RemoteControllabilityInterface.cc
 create mode 100644 cpp/src/interfaces/operation/RemoteControllabilityIntfControlleeImpl.cc
 create mode 100644 cpp/src/interfaces/operation/RemoteControllabilityIntfControlleeImpl.h
 create mode 100644 cpp/src/interfaces/operation/RemoteControllabilityIntfControllerImpl.cc
 create mode 100644 cpp/src/interfaces/operation/RemoteControllabilityIntfControllerImpl.h
 create mode 100644 cpp/src/interfaces/operation/SoilLevelInterface.cc
 create mode 100644 cpp/src/interfaces/operation/SoilLevelIntfControlleeImpl.cc
 create mode 100644 cpp/src/interfaces/operation/SoilLevelIntfControlleeImpl.h
 create mode 100644 cpp/src/interfaces/operation/SoilLevelIntfControllerImpl.cc
 create mode 100644 cpp/src/interfaces/operation/SoilLevelIntfControllerImpl.h
 create mode 100644 cpp/src/interfaces/operation/SpinSpeedLevelInterface.cc
 create mode 100644 cpp/src/interfaces/operation/SpinSpeedLevelIntfControlleeImpl.cc
 create mode 100644 cpp/src/interfaces/operation/SpinSpeedLevelIntfControlleeImpl.h
 create mode 100644 cpp/src/interfaces/operation/SpinSpeedLevelIntfControllerImpl.cc
 create mode 100644 cpp/src/interfaces/operation/SpinSpeedLevelIntfControllerImpl.h
 create mode 100644 cpp/src/interfaces/operation/TimerInterface.cc
 create mode 100644 cpp/src/interfaces/operation/TimerIntfControlleeImpl.cc
 create mode 100644 cpp/src/interfaces/operation/TimerIntfControlleeImpl.h
 create mode 100644 cpp/src/interfaces/operation/TimerIntfControllerImpl.cc
 create mode 100644 cpp/src/interfaces/operation/TimerIntfControllerImpl.h

diff --git a/cpp/inc/alljoyn/hae/interfaces/environment/WaterLevelInterface.h b/cpp/inc/alljoyn/hae/interfaces/environment/WaterLevelInterface.h
new file mode 100644
index 0000000..450673c
--- /dev/null
+++ b/cpp/inc/alljoyn/hae/interfaces/environment/WaterLevelInterface.h
@@ -0,0 +1,80 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#ifndef WATERLEVELINTERFACE_H_
+#define WATERLEVELINTERFACE_H_
+
+#include <qcc/String.h>
+#include <alljoyn/Status.h>
+#include <alljoyn/hae/interfaces/HaeInterface.h>
+
+namespace ajn {
+namespace services {
+
+/**
+ * WaterLevel Interface class
+ */
+class WaterLevelInterface : public HaeInterface {
+  public:
+    typedef enum
+    {
+        SUPPLY_SOURCE_TANK,
+        SUPPLY_SOURCE_PIPE,
+        SUPPLY_SOURCE_NOT_SUPPORTED = 0xFF
+    }WaterLevelSupplySource;
+    /**
+     * Constructor of WaterLevel
+     */
+    WaterLevelInterface() {}
+
+    /**
+     * Destructor of WaterLevel
+     */
+    virtual ~WaterLevelInterface() {}
+
+    /**
+     * Get Interface Type
+     * @return interface type
+     */
+    const HaeInterfaceType GetInterfaceType() const { return WATER_LEVEL_INTERFACE; }
+
+    /**
+     * Get Introspection Xml
+     * @return xml
+     */
+    virtual const qcc::String& GetIntrospectionXml() { return s_xml; }
+
+    /**
+     * Get Interface version
+     * @return interface version
+     */
+    virtual const uint16_t GetInterfaceVersion() const { return s_interfaceVersion; }
+
+  protected:
+    static const qcc::String s_prop_Version;
+    static const qcc::String s_prop_SupplySource;
+    static const qcc::String s_prop_CurrentLevel;
+    static const qcc::String s_prop_MaxLevel;
+
+  private:
+    static const qcc::String s_xml;
+    static const uint16_t s_interfaceVersion;
+};
+
+} //namespace services
+} //namespace ajn
+
+#endif /* WATERLEVELINTERFACE_H_ */
diff --git a/cpp/inc/alljoyn/hae/interfaces/environment/WaterLevelIntfControllee.h b/cpp/inc/alljoyn/hae/interfaces/environment/WaterLevelIntfControllee.h
new file mode 100644
index 0000000..a43d384
--- /dev/null
+++ b/cpp/inc/alljoyn/hae/interfaces/environment/WaterLevelIntfControllee.h
@@ -0,0 +1,85 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#ifndef WATERLEVELINTFCONTROLLEE_H_
+#define WATERLEVELINTFCONTROLLEE_H_
+
+#include <qcc/String.h>
+#include <alljoyn/Status.h>
+#include <alljoyn/hae/interfaces/environment/WaterLevelInterface.h>
+
+namespace ajn {
+namespace services {
+
+/**
+ * WaterLevel Interface Controllee class
+ */
+class WaterLevelIntfControllee : public WaterLevelInterface {
+  public:
+    /**
+     * Constructor of WaterLevelIntfControllee
+     */
+    WaterLevelIntfControllee() {}
+
+    /**
+     * Destructor of WaterLevelIntfControllee
+     */
+    virtual ~WaterLevelIntfControllee() {}
+
+    /**
+     * Get Current water Level
+     * @return Current water Level
+     */
+    virtual const uint8_t GetCurrentLevel() const = 0;
+
+    /**
+     * Set CurrentLevel
+     * @param[in] currentLevel current level
+     * @return ER_OK on success
+     */
+    virtual QStatus SetCurrentLevel (const uint8_t currentLevel) = 0;
+
+    /**
+     * Get max water level
+     * @return max water level
+     */
+    virtual const uint8_t GetMaxLevel() const = 0;
+
+    /**
+     * Set MaxLevel
+     * @param[in] maxLevel max level
+     * @return ER_OK on success
+     */
+    virtual QStatus SetMaxLevel(const uint8_t maxLevel) = 0;
+
+    /**
+     * Get supply source
+     * @return supply source
+     */
+    virtual const WaterLevelSupplySource GetSupplySource() const = 0;
+
+    /**
+     * Set SupplySource
+     * @param[in] supplySource supplySource
+     * @return ER_OK on success
+     */
+    virtual QStatus SetSupplySource(const WaterLevelSupplySource supplySource) = 0;
+};
+
+} //namespace services
+} //namespace ajn
+
+#endif /* WATERLEVELINTFCONTROLLEE_H_ */
diff --git a/cpp/inc/alljoyn/hae/interfaces/environment/WaterLevelIntfControlleeListener.h b/cpp/inc/alljoyn/hae/interfaces/environment/WaterLevelIntfControlleeListener.h
new file mode 100644
index 0000000..d75f7e7
--- /dev/null
+++ b/cpp/inc/alljoyn/hae/interfaces/environment/WaterLevelIntfControlleeListener.h
@@ -0,0 +1,68 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#ifndef WATERLEVELINTFCONTROLLEELISTENER_H_
+#define WATERLEVELINTFCONTROLLEELISTENER_H_
+
+#include <qcc/String.h>
+#include <alljoyn/Status.h>
+#include <alljoyn/hae/interfaces/HaeInterfaceErrors.h>
+#include <alljoyn/hae/interfaces/InterfaceControlleeListener.h>
+#include <alljoyn/hae/interfaces/environment/WaterLevelInterface.h>
+
+
+namespace ajn {
+namespace services {
+
+/**
+ * WaterLevel Interface Controllee Listener class
+ */
+class WaterLevelIntfControlleeListener : public InterfaceControlleeListener {
+  public:
+    /**
+     * Destructor of WaterLevelIntfControlleeListener
+     */
+    virtual ~WaterLevelIntfControlleeListener() {}
+
+    /**
+     * Handler for getting currentLevel
+     * This function is only called, when InterfaceControllee::s_retrievingActualPropertyValue is true.
+     * @param[out] currentLevel currentLevel
+     * @return ER_OK on success
+     */
+    virtual QStatus OnGetCurrentLevel(uint8_t& currentLevel) = 0;
+
+    /**
+     * Handler for getting maxLevel
+     * This function is only called, when InterfaceControllee::s_retrievingActualPropertyValue is true.
+     * @param[out] maxLevel maxLevel
+     * @return ER_OK on success
+     */
+    virtual QStatus OnGetMaxLevel(uint8_t& maxLevel)  = 0;
+
+    /**
+     * Handler for getting supplySource
+     * This function is only called, when InterfaceControllee::s_retrievingActualPropertyValue is true.
+     * @param[out] supplySource supplySource
+     * @return ER_OK on success
+     */
+    virtual QStatus OnGetSupplySource(WaterLevelInterface::WaterLevelSupplySource& supplySource)  = 0;
+};
+
+} //namespace services
+} //namespace ajn
+
+#endif /* WATERLEVELINTFCONTROLLEELISTENER_H_ */
diff --git a/cpp/inc/alljoyn/hae/interfaces/environment/WaterLevelIntfController.h b/cpp/inc/alljoyn/hae/interfaces/environment/WaterLevelIntfController.h
new file mode 100644
index 0000000..5277731
--- /dev/null
+++ b/cpp/inc/alljoyn/hae/interfaces/environment/WaterLevelIntfController.h
@@ -0,0 +1,67 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#ifndef WATERLEVELINTFCONTROLLER_H_
+#define WATERLEVELINTFCONTROLLER_H_
+
+#include <qcc/String.h>
+#include <alljoyn/Status.h>
+#include <alljoyn/hae/interfaces/environment/WaterLevelInterface.h>
+
+namespace ajn {
+namespace services {
+
+/**
+ * WaterLevel Interface Controller class
+ */
+class WaterLevelIntfController : public WaterLevelInterface {
+  public:
+    /**
+     * Constructor of WaterLevelIntfController
+     */
+    WaterLevelIntfController() {}
+
+    /**
+     * Destructor of WaterLevelIntfController
+     */
+    virtual ~WaterLevelIntfController() {}
+
+    /**
+     * Get currentLevel
+     * @param[in] context the context that is passed to the callback handler
+     * @return ER_OK on success
+     */
+    virtual QStatus GetCurrentLevel(void* context = NULL) = 0;
+
+    /**
+     * Get supplySource
+     * @param[in] context the context that is passed to the callback handler
+     * @return ER_OK on success
+     */
+    virtual QStatus GetSupplySource(void* context = NULL) = 0;
+
+    /**
+     * Get maxLevel
+     * @param[in] context the context that is passed to the callback handler
+     * @return ER_OK on success
+     */
+    virtual QStatus GetMaxLevel(void* context = NULL) = 0;
+};
+
+} //namespace services
+} //namespace ajn
+
+#endif /* WATERLEVELINTFCONTROLLER_H_ */
diff --git a/cpp/inc/alljoyn/hae/interfaces/environment/WaterLevelIntfControllerListener.h b/cpp/inc/alljoyn/hae/interfaces/environment/WaterLevelIntfControllerListener.h
new file mode 100644
index 0000000..c66a500
--- /dev/null
+++ b/cpp/inc/alljoyn/hae/interfaces/environment/WaterLevelIntfControllerListener.h
@@ -0,0 +1,83 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#ifndef WATERLEVELINTFCONTROLLERLISTENER_H_
+#define WATERLEVELINTFCONTROLLERLISTENER_H_
+
+#include <qcc/String.h>
+#include <alljoyn/Status.h>
+#include <alljoyn/hae/interfaces/InterfaceControllerListener.h>
+#include <alljoyn/hae/interfaces/environment/WaterLevelInterface.h>
+
+namespace ajn {
+namespace services {
+
+/**
+ * WaterLevel Interface Controller Listener class
+ */
+class WaterLevelIntfControllerListener : public InterfaceControllerListener {
+  public:
+    virtual ~WaterLevelIntfControllerListener() {}
+
+    /**
+     * Callback handler for getting MaxLevel property
+     * @param[in] status ER_OK on success
+     * @param[in] objectPath the object path
+     * @param[in] maxLevel maxLevel
+     * @param[in] context the context that is passed from application
+     */
+    virtual void OnGetMaxLevelPropertyCallback(QStatus status, const qcc::String& objectPath, const uint8_t value, void* context) {}
+    /**
+     * Callback handler for getting SupplySource property
+     * @param[in] status ER_OK on success
+     * @param[in] objectPath the object path
+     * @param[in] supplySource supplySource
+     * @param[in] context the context that is passed from application
+     */
+    virtual void OnGetSupplySourcePropertyCallback (QStatus status, const qcc::String& objectPath, const WaterLevelInterface::WaterLevelSupplySource value, void* context) {}
+    /**
+     * Callback handler for getting CurrentLevel property
+     * @param[in] status ER_OK on success
+     * @param[in] objectPath the object path
+     * @param[in] currentLevel currentLevel
+     * @param[in] context the context that is passed from application
+     */
+    virtual void OnGetCurrentLevelPropertyCallback (QStatus status, const qcc::String& objectPath, const uint8_t value, void* context) {}
+
+    /**
+     * Handler for MaxLevel property changed
+     * @param[in] objectPath the object path
+     * @param[in] value MaxLevel
+     */
+    virtual void MaxLevelProprtyChanged(const qcc::String& objectPath, const uint8_t value){}
+    /**
+     * Handler for CurrentLevel property changed
+     * @param[in] objectPath the object path
+     * @param[in] value CurrentLevel
+     */
+    virtual void CurrentLevelProprtyChanged(const qcc::String& objectPath, const uint8_t value){}
+    /**
+     * Handler for SupplySource property changed
+     * @param[in] objectPath the object path
+     * @param[in] value SupplySource
+     */
+    virtual void SupplySourceProprtyChanged(const qcc::String& objectPath, const WaterLevelInterface::WaterLevelSupplySource value){}
+};
+
+} //namespace services
+} //namespace ajn
+
+#endif /* WATERLEVELINTFCONTROLLERLISTENER_H_ */
diff --git a/cpp/inc/alljoyn/hae/interfaces/operation/CycleControlInterface.h b/cpp/inc/alljoyn/hae/interfaces/operation/CycleControlInterface.h
new file mode 100644
index 0000000..1d27d49
--- /dev/null
+++ b/cpp/inc/alljoyn/hae/interfaces/operation/CycleControlInterface.h
@@ -0,0 +1,99 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#ifndef CYCLECONTROLINTERFACE_H_
+#define CYCLECONTROLINTERFACE_H_
+
+#include <qcc/String.h>
+#include <alljoyn/Status.h>
+#include <vector>
+#include <alljoyn/hae/interfaces/HaeInterface.h>
+
+namespace ajn {
+namespace services {
+/**
+ * CycleControl Interface class
+ */
+class CycleControlInterface : public HaeInterface {
+  public:
+    typedef enum
+    {
+        OPERATIONAL_STATE_IDLE,
+        OPERATIONAL_STATE_WORKING,
+        OPERATIONAL_STATE_READY_TO_START,
+        OPERATIONAL_STATE_DELAYED_START,
+        OPERATIONAL_STATE_PAUSED,
+        OPERATIONAL_STATE_END_OF_CYCLE
+    } CycleControlOperationalState;
+
+    typedef enum
+    {
+        OPERATIONAL_COMMAND_START,
+        OPERATIONAL_COMMAND_STOP,
+        OPERATIONAL_COMMAND_PAUSE,
+        OPERATIONAL_COMMAND_RESUME
+    }CycleControlOperationalCommand;
+
+    static const qcc::String OPERATIONAL_STATE_STRINGS[6];
+    static const qcc::String OPERATIONAL_COMMAND_STRINGS[4];
+
+    typedef std::vector<CycleControlOperationalCommand> SupportedOperationalCommands;
+    typedef std::vector<CycleControlOperationalState> SupportedOperationalStates;
+
+    /**
+     * Constructor of CycleControl
+     */
+    CycleControlInterface() {}
+
+    /**
+     * Destructor of CycleControl
+     */
+    virtual ~CycleControlInterface() {}
+
+    /**
+     * Get Interface Type
+     * @return interface type
+     */
+    const HaeInterfaceType GetInterfaceType() const { return CYCLE_CONTROL_INTERFACE; }
+
+    /**
+     * Get Introspection Xml
+     * @return xml
+     */
+    virtual const qcc::String& GetIntrospectionXml() { return s_xml; }
+
+    /**
+     * Get Interface version
+     * @return interface version
+     */
+    virtual const uint16_t GetInterfaceVersion() const { return s_interfaceVersion; }
+
+  protected:
+    static const qcc::String s_prop_Version;
+    static const qcc::String s_prop_OperationalState;
+    static const qcc::String s_prop_SupportedOperationalCommands;
+    static const qcc::String s_prop_SupportedOperationalStates;
+    static const qcc::String s_method_ExecuteCommand;
+    static const qcc::String s_signal_EndOfCycle;
+  private:
+    static const qcc::String s_xml;
+    static const uint16_t s_interfaceVersion;
+};
+
+} //namespace services
+} //namespace ajn
+
+#endif /* CYCLECONTROLINTERFACE_H_ */
diff --git a/cpp/inc/alljoyn/hae/interfaces/operation/CycleControlIntfControllee.h b/cpp/inc/alljoyn/hae/interfaces/operation/CycleControlIntfControllee.h
new file mode 100644
index 0000000..034c1f1
--- /dev/null
+++ b/cpp/inc/alljoyn/hae/interfaces/operation/CycleControlIntfControllee.h
@@ -0,0 +1,92 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#ifndef CYCLECONTROLINTFCONTROLLEE_H_
+#define CYCLECONTROLINTFCONTROLLEE_H_
+
+#include <qcc/String.h>
+#include <alljoyn/Status.h>
+#include <alljoyn/hae/interfaces/operation/CycleControlInterface.h>
+
+namespace ajn {
+namespace services {
+
+
+/**
+ * CycleControl Interface Controllee class
+ */
+class CycleControlIntfControllee : public CycleControlInterface {
+  public:
+    /**
+     * Constructor of CycleControlIntfControllee
+     */
+    CycleControlIntfControllee() {}
+
+    /**
+     * Destructor of CycleControlIntfControllee
+     */
+    virtual ~CycleControlIntfControllee() {}
+
+    /**
+     * Get OpertaionalState
+     * @return OpertaionalState
+     */
+    virtual const CycleControlOperationalState GetOperationalState() const = 0 ;
+
+    /**
+     * Set OperationalState
+     * @param[in]  state the state to set
+     * @return ER_OK on success
+     */
+    virtual QStatus SetOperationalState(CycleControlOperationalState state) = 0;
+
+    /**
+     * Get SupportedCommands
+     * @return The list of supported commands
+     */
+    virtual const SupportedOperationalCommands& GetSupportedCommands() const = 0;
+
+    /**
+     * Get SupportedStates
+     * @return The list of supported states
+     */
+    virtual const SupportedOperationalStates& GetSupportedStates() const = 0;
+    /**
+     * Set SupportedCommands
+     * @param[in]  commands the list of commands to set
+     * @return ER_OK on success
+     */
+    virtual QStatus SetSupportedCommands(SupportedOperationalCommands commands) = 0;
+
+    /**
+     * Set SupportedStates
+     * @param[in]  states the list of states to set
+     * @return ER_OK on success
+     */
+    virtual QStatus SetSupportedStates(SupportedOperationalStates states) = 0;
+
+    /**
+     * Emitter of EndOfCycle signal
+     * @return ER_OK on success
+     */
+    virtual QStatus EmitEndOfCycle() = 0;
+
+};
+
+} //namespace services
+} //namespace ajn
+
+#endif /* CYCLECONTROLINTFCONTROLLEE_H_ */
diff --git a/cpp/inc/alljoyn/hae/interfaces/operation/CycleControlIntfControlleeListener.h b/cpp/inc/alljoyn/hae/interfaces/operation/CycleControlIntfControlleeListener.h
new file mode 100644
index 0000000..34c6b33
--- /dev/null
+++ b/cpp/inc/alljoyn/hae/interfaces/operation/CycleControlIntfControlleeListener.h
@@ -0,0 +1,60 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#ifndef CYCLECONTROLINTFCONTROLLEELISTENER_H_
+#define CYCLECONTROLINTFCONTROLLEELISTENER_H_
+
+#include <qcc/String.h>
+#include <alljoyn/Status.h>
+#include <alljoyn/hae/interfaces/InterfaceControlleeListener.h>
+#include <alljoyn/hae/interfaces/HaeInterfaceErrors.h>
+#include <alljoyn/hae/interfaces/operation/CycleControlInterface.h>
+
+namespace ajn {
+namespace services {
+
+/**
+ * CycleControl Interface Controllee Listener class
+ */
+class CycleControlIntfControlleeListener : public InterfaceControlleeListener {
+  public:
+    /**
+     * Destructor of CycleControlIntfControlleeListener
+     */
+    virtual ~CycleControlIntfControlleeListener() {}
+
+    /**
+     * Handler for getting current operational state
+     * This function is only called, when InterfaceControllee::s_retrievingActualPropertyValue is true.
+     * @param[out] currentState currentState
+     * @return ER_OK on success
+     */
+    virtual QStatus OnGetOperationalState(CycleControlInterface::CycleControlOperationalState& currentState) = 0;
+
+    /**
+     * Handler for executing command
+     * @param[in] command command to execute
+     * @param[out] currentState currentState
+     * @param[out] error Internal error code occurred during command execution
+     * @return ER_OK on success
+     */
+    virtual QStatus OnExecuteCommand(CycleControlInterface::CycleControlOperationalCommand command, CycleControlInterface::CycleControlOperationalState& newState, ErrorCode& error) = 0;
+};
+
+} //namespace services
+} //namespace ajn
+
+#endif /* CYCLECONTROLINTFCONTROLLEELISTENER_H_ */
diff --git a/cpp/inc/alljoyn/hae/interfaces/operation/CycleControlIntfController.h b/cpp/inc/alljoyn/hae/interfaces/operation/CycleControlIntfController.h
new file mode 100644
index 0000000..e7419d4
--- /dev/null
+++ b/cpp/inc/alljoyn/hae/interfaces/operation/CycleControlIntfController.h
@@ -0,0 +1,76 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#ifndef CYCLECONTROLINTFCONTROLLER_H_
+#define CYCLECONTROLINTFCONTROLLER_H_
+
+#include <qcc/String.h>
+#include <alljoyn/Status.h>
+#include <alljoyn/hae/interfaces/operation/CycleControlInterface.h>
+
+namespace ajn {
+namespace services {
+
+/**
+ * CycleControl Interface Controller class
+ */
+class CycleControlIntfController : public CycleControlInterface {
+  public:
+    /**
+     * Constructor of CycleControlIntfController
+     */
+    CycleControlIntfController() {}
+
+    /**
+     * Destructor of CycleControlIntfController
+     */
+    virtual ~CycleControlIntfController() {}
+
+    /**
+     * Get OperationalState
+     * @param[in] context the context that is passed to the callback handler
+     * @return ER_OK on success
+     */
+    virtual QStatus GetOperationalState(void* context = NULL) = 0;
+
+    /**
+     * Get SupportedOperationalCommands
+     * @param[in] context the context that is passed to the callback handler
+     * @return ER_OK on success
+     */
+    virtual QStatus GetSupportedOperationalCommands(void* context = NULL) = 0;
+
+    /**
+     * Get SupportedOperationalStates
+     * @param[in] context the context that is passed to the callback handler
+     * @return ER_OK on success
+     */
+    virtual QStatus GetSupportedOperationalStates(void* context = NULL) = 0;
+
+    /**
+     * Execute command
+     * @param[in] command command to execude
+     * @param[in] context the context that is passed to the callback handler
+     * @return ER_OK on success
+     */
+    virtual QStatus ExecuteCommand(const CycleControlOperationalCommand command, void* context = NULL) = 0;
+
+};
+
+} //namespace services
+} //namespace ajn
+
+#endif /* CYCLECONTROLINTFCONTROLLER_H_ */
diff --git a/cpp/inc/alljoyn/hae/interfaces/operation/CycleControlIntfControllerListener.h b/cpp/inc/alljoyn/hae/interfaces/operation/CycleControlIntfControllerListener.h
new file mode 100644
index 0000000..a586fb5
--- /dev/null
+++ b/cpp/inc/alljoyn/hae/interfaces/operation/CycleControlIntfControllerListener.h
@@ -0,0 +1,104 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#ifndef CYCLECONTROLINTFCONTROLLERLISTENER_H_
+#define CYCLECONTROLINTFCONTROLLERLISTENER_H_
+
+#include <qcc/String.h>
+#include <alljoyn/Status.h>
+#include <alljoyn/hae/interfaces/InterfaceControllerListener.h>
+#include <alljoyn/hae/interfaces/operation/CycleControlInterface.h>
+
+namespace ajn {
+namespace services {
+
+/**
+ * CycleControl Interface Controller Listener class
+ */
+class CycleControlIntfControllerListener : public InterfaceControllerListener {
+  public:
+    virtual ~CycleControlIntfControllerListener() {}
+
+    /**
+     * Callback handler for getting OperaionalState property
+     * @param[in] status ER_OK on success
+     * @param[in] objectPath the object path
+     * @param[in] currentState current state
+     * @param[in] context the context that is passed from application
+     */
+    virtual void GetOperationalStatePropertyCallback(QStatus status, const qcc::String& objectPath, const CycleControlInterface::CycleControlOperationalState& currentState, void* context) {}
+
+    /**
+     * Callback handler for getting SupportedOperationalStates property
+     * @param[in] status ER_OK on success
+     * @param[in] objectPath the object path
+     * @param[in] states The list of states
+     * @param[in] context the context that is passed from application
+     */
+    virtual void GetSupportedStatesPropertyCallbalck(QStatus status, const qcc::String& objectPath, const CycleControlInterface::SupportedOperationalStates& states, void* context) {}
+
+    /**
+     * Callback handler for getting SupportedOpearionalCommands property
+     * @param[in] status ER_OK on success
+     * @param[in] objectPath the object path
+     * @param[in] commands The list of commands
+     * @param[in] context the context that is passed from application
+     */
+    virtual void GetSupportedCommandsPropertyCallbalck(QStatus status, const qcc::String& objectPath, const CycleControlInterface::SupportedOperationalCommands& commands, void* context) {}
+
+    /**
+     * Handler for OperationalState property changed
+     * @param[in] objectPath the object path
+     * @param[in] currentState current state
+     */
+    virtual void OperationalStatePropertyChanged(const qcc::String& objectPath, const CycleControlInterface::CycleControlOperationalState& currentState) {}
+
+    /**
+     * Handler for SupportedOperationalStates property changed
+     * @param[in] objectPath the object path
+     * @param[in] states The list of states
+     */
+    virtual void SupportedOperationalStatesProperyChanged(const qcc::String& objectPath, const CycleControlInterface::SupportedOperationalStates& states) {}
+
+    /**
+     * Handler for SupportedOperationalCommands property changed
+     * @param[in] objectPath the object path
+     * @param[in] commands The list of commands
+     */
+    virtual void SupportedOperationalCommandsProperyChanged(const qcc::String& objectPath, const CycleControlInterface::SupportedOperationalCommands& commands) {}
+
+    /**
+     * Callback handler for ExecuteCommand method
+     * @param[in] status ER_OK on success
+     * @param[in] objectPath the object path
+     * @param[in] context the context that is passed from application
+     * @param[in] errorName the detail errorName is passed when the method call is failed
+     * @param[in] errorMessage the errorMessage that describes the error
+     */
+    virtual void OnExecuteCommandRespose(QStatus status, const qcc::String& objectPath, void* context, const char* errorName, const char* errorMessage) {}
+
+    /**
+     * Handler for EndOfCycle Signal
+     * @param[in] objectPath the object path
+     */
+    virtual void OnEndOfCycle( const qcc::String& objectPath ) {}
+
+};
+
+} //namespace services
+} //namespace ajn
+
+#endif /* CYCLECONTROLINTFCONTROLLERLISTENER_H_ */
diff --git a/cpp/inc/alljoyn/hae/interfaces/operation/DishWashingCyclePhaseInterface.h b/cpp/inc/alljoyn/hae/interfaces/operation/DishWashingCyclePhaseInterface.h
new file mode 100644
index 0000000..532bfab
--- /dev/null
+++ b/cpp/inc/alljoyn/hae/interfaces/operation/DishWashingCyclePhaseInterface.h
@@ -0,0 +1,95 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#ifndef DISHWASHINGCYCLEPHASEINTERFACE_H_
+#define DISHWASHINGCYCLEPHASEINTERFACE_H_
+
+#include <vector>
+#include <qcc/String.h>
+#include <alljoyn/Status.h>
+#include <alljoyn/hae/interfaces/HaeInterface.h>
+
+namespace ajn {
+namespace services {
+
+/**
+ * DishWashingCyclePhase Interface class
+ */
+class DishWashingCyclePhaseInterface : public HaeInterface {
+  public:
+
+    typedef struct {
+        uint8_t phase;
+        qcc::String name;
+        qcc::String description;
+    }DishWashingPhaseDescriptor;
+
+    typedef enum {
+        DISH_WASHING_PHASE_UNAVAILABLE,
+        DISH_WASHING_PHASE_PRE_WASH,
+        DISH_WASHING_PHASE_WASH,
+        DISH_WASHING_PHASE_RINSE,
+        DISH_WASHING_PHASE_DRY
+    }DishWashingCyclePhase;
+
+    typedef std::vector<DishWashingCyclePhase> StandardCyclePhases;
+
+    typedef std::vector<uint8_t> SupportedCyclePhases;
+    typedef std::vector<DishWashingPhaseDescriptor> CyclePhaseDescriptions;
+
+    static const StandardCyclePhases m_standardCyclePhases;
+    /**
+     * Constructor of DishWashingCyclePhase
+     */
+    DishWashingCyclePhaseInterface() {}
+
+    /**
+     * Destructor of DishWashingCyclePhase
+     */
+    virtual ~DishWashingCyclePhaseInterface() {}
+
+    /**
+     * Get Interface Type
+     * @return interface type
+     */
+    const HaeInterfaceType GetInterfaceType() const { return DISH_WASHING_CYCLE_PHASE_INTERFACE; }
+
+    /**
+     * Get Introspection Xml
+     * @return xml
+     */
+    virtual const qcc::String& GetIntrospectionXml() { return s_xml; }
+
+    /**
+     * Get Interface version
+     * @return interface version
+     */
+    virtual const uint16_t GetInterfaceVersion() const { return s_interfaceVersion; }
+
+  protected:
+    static const qcc::String s_prop_Version;
+    static const qcc::String s_prop_CyclePhase;
+    static const qcc::String s_prop_SupportedCyclePhases;
+    static const qcc::String s_method_GetVendorPhasesDescription;
+  private:
+    static const qcc::String s_xml;
+    static const uint16_t s_interfaceVersion;
+};
+
+} //namespace services
+} //namespace ajn
+
+#endif /* DISHWASHINGCYCLEPHASEINTERFACE_H_ */
diff --git a/cpp/inc/alljoyn/hae/interfaces/operation/DishWashingCyclePhaseIntfControllee.h b/cpp/inc/alljoyn/hae/interfaces/operation/DishWashingCyclePhaseIntfControllee.h
new file mode 100644
index 0000000..92ddd72
--- /dev/null
+++ b/cpp/inc/alljoyn/hae/interfaces/operation/DishWashingCyclePhaseIntfControllee.h
@@ -0,0 +1,80 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#ifndef DISHWASHINGCYCLEPHASEINTFCONTROLLEE_H_
+#define DISHWASHINGCYCLEPHASEINTFCONTROLLEE_H_
+
+#include <qcc/String.h>
+#include <alljoyn/Status.h>
+#include <alljoyn/hae/interfaces/operation/DishWashingCyclePhaseInterface.h>
+
+namespace ajn {
+namespace services {
+
+/**
+ * DishWashingCyclePhase Interface Controllee class
+ */
+class DishWashingCyclePhaseIntfControllee : public DishWashingCyclePhaseInterface {
+  public:
+    /**
+     * Constructor of DishWashingCyclePhaseIntfControllee
+     */
+    DishWashingCyclePhaseIntfControllee() {}
+
+    /**
+     * Destructor of DishWashingCyclePhaseIntfControllee
+     */
+    virtual ~DishWashingCyclePhaseIntfControllee() {}
+
+    /**
+     * Get CyclePhase
+     * @return current cycle phase
+     */
+    virtual const uint8_t GetCyclePhase() const = 0;
+
+    /**
+     * Set CyclePhase
+     * @param[in]  cyclePhase the cycle phase to set
+     * @return ER_OK on success
+     */
+    virtual QStatus SetCyclePhase(const uint8_t cyclePhase) = 0;
+
+    /**
+     * Get SupportedCyclePhases
+     * @return the list of supported cycle phases
+     */
+    virtual const SupportedCyclePhases& GetSupportedCyclePhases() const = 0;
+
+    /**
+     * Set OperationalState
+     * @param[in]  supportedCyclePhases the list of supported cycle phases to set
+     * @return ER_OK on success
+     */
+    virtual QStatus SetSupportedCyclePhases(const SupportedCyclePhases& supportedCyclePhases) = 0;
+
+    /**
+     * Set VendorDefinedCyclePhases
+     * @param[in]  vendorPhases the list of vendor defined cycle phases to set
+     * @return ER_OK on success
+     */
+    virtual QStatus SetVendorDefinedCyclePhases(const std::vector<uint8_t>& vendorPhases) = 0;
+
+};
+
+} //namespace services
+} //namespace ajn
+
+#endif /* DISHWASHINGCYCLEPHASEINTFCONTROLLEE_H_ */
diff --git a/cpp/inc/alljoyn/hae/interfaces/operation/DishWashingCyclePhaseIntfControlleeListener.h b/cpp/inc/alljoyn/hae/interfaces/operation/DishWashingCyclePhaseIntfControlleeListener.h
new file mode 100644
index 0000000..4825e80
--- /dev/null
+++ b/cpp/inc/alljoyn/hae/interfaces/operation/DishWashingCyclePhaseIntfControlleeListener.h
@@ -0,0 +1,71 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#ifndef DISHWASHINGCYCLEPHASEINTFCONTROLLEELISTENER_H_
+#define DISHWASHINGCYCLEPHASEINTFCONTROLLEELISTENER_H_
+
+#include <qcc/String.h>
+#include <alljoyn/Status.h>
+#include <alljoyn/hae/interfaces/HaeInterfaceErrors.h>
+#include <alljoyn/hae/interfaces/InterfaceControlleeListener.h>
+#include <alljoyn/hae/interfaces/operation/DishWashingCyclePhaseInterface.h>
+
+namespace ajn {
+namespace services {
+
+/**
+ * DishWashingCyclePhase Interface Controllee Listener class
+ */
+class DishWashingCyclePhaseIntfControlleeListener : public InterfaceControlleeListener {
+  public:
+    /**
+     * Destructor of DishWashingCyclePhaseIntfControlleeListener
+     */
+    virtual ~DishWashingCyclePhaseIntfControlleeListener() {}
+
+    /**
+     * Handler for getting current cycle phase
+     * This function is only called, when InterfaceControllee::s_retrievingActualPropertyValue is true.
+     * @param[out] cyclePhase cyclePhase
+     * @return ER_OK on success
+     */
+    virtual QStatus OnGetCyclePhase(uint8_t& cyclePhase) = 0;
+
+    /**
+     * Handler for getting list of supported cycle phases
+     * This function is only called, when InterfaceControllee::s_retrievingActualPropertyValue is true.
+     * @param[out] listOfSupportedCyclePhases list of supported cycle phases
+     * @return ER_OK on success
+     */
+    virtual QStatus OnGetSupportedCyclePhases(DishWashingCyclePhaseInterface::SupportedCyclePhases& listOfSupportedCyclePhases) = 0;
+
+    /**
+     * Handler for getting list cycle phases descriptions
+     * This function is only called, when InterfaceControllee::s_retrievingActualPropertyValue is true.
+     * @param[in] language language
+     * @param[out] listOfPhaseDescs list of cycle phases descriptions
+     * @return ER_OK on success
+     */
+    virtual QStatus OnGetCyclePhasesDescriptions(const qcc::String language,
+                                                 DishWashingCyclePhaseInterface::CyclePhaseDescriptions& listOfPhaseDescs,
+                                                 ErrorCode& errorCode) = 0;
+
+};
+
+} //namespace services
+} //namespace ajn
+
+#endif /* DISHWASHINGCYCLEPHASEINTFCONTROLLEELISTENER_H_ */
diff --git a/cpp/inc/alljoyn/hae/interfaces/operation/DishWashingCyclePhaseIntfController.h b/cpp/inc/alljoyn/hae/interfaces/operation/DishWashingCyclePhaseIntfController.h
new file mode 100644
index 0000000..f577430
--- /dev/null
+++ b/cpp/inc/alljoyn/hae/interfaces/operation/DishWashingCyclePhaseIntfController.h
@@ -0,0 +1,68 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#ifndef DISHWASHINGCYCLEPHASEINTFCONTROLLER_H_
+#define DISHWASHINGCYCLEPHASEINTFCONTROLLER_H_
+
+#include <qcc/String.h>
+#include <alljoyn/Status.h>
+#include <alljoyn/hae/interfaces/operation/DishWashingCyclePhaseInterface.h>
+
+namespace ajn {
+namespace services {
+
+/**
+ * DishWashingCyclePhase Interface Controller class
+ */
+class DishWashingCyclePhaseIntfController : public DishWashingCyclePhaseInterface {
+  public:
+    /**
+     * Constructor of DishWashingCyclePhaseIntfController
+     */
+    DishWashingCyclePhaseIntfController() {}
+
+    /**
+     * Destructor of DishWashingCyclePhaseIntfController
+     */
+    virtual ~DishWashingCyclePhaseIntfController() {}
+
+    /**
+     * Get CyclePhase
+     * @param[in] context the context that is passed to the callback handler
+     * @return ER_OK on success
+     */
+    virtual QStatus GetCyclePhase(void* context = NULL) = 0;
+
+    /**
+     * Get SupportedCyclePhases
+     * @param[in] context the context that is passed to the callback handler
+     * @return ER_OK on success
+     */
+    virtual QStatus GetSupportedCyclePhases(void* context = NULL) = 0;
+
+    /**
+     * Get CyclePhasesDescriptions
+     * @param[in] language language
+     * @param[in] context the context that is passed to the callback handler
+     * @return ER_OK on success
+     */
+    virtual QStatus GetCyclePhasesDescriptions(const qcc::String& language, void* context = NULL) = 0;
+};
+
+} //namespace services
+} //namespace ajn
+
+#endif /* DISHWASHINGCYCLEPHASEINTFCONTROLLER_H_ */
diff --git a/cpp/inc/alljoyn/hae/interfaces/operation/DishWashingCyclePhaseIntfControllerListener.h b/cpp/inc/alljoyn/hae/interfaces/operation/DishWashingCyclePhaseIntfControllerListener.h
new file mode 100644
index 0000000..9882c57
--- /dev/null
+++ b/cpp/inc/alljoyn/hae/interfaces/operation/DishWashingCyclePhaseIntfControllerListener.h
@@ -0,0 +1,83 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#ifndef DISHWASHINGCYCLEPHASEINTFCONTROLLERLISTENER_H_
+#define DISHWASHINGCYCLEPHASEINTFCONTROLLERLISTENER_H_
+
+#include <qcc/String.h>
+#include <alljoyn/Status.h>
+#include <alljoyn/hae/interfaces/InterfaceControllerListener.h>
+#include <alljoyn/hae/interfaces/operation/DishWashingCyclePhaseInterface.h>
+
+namespace ajn {
+namespace services {
+
+/**
+ * DishWashingCyclePhase Interface Controller Listener class
+ */
+class DishWashingCyclePhaseIntfControllerListener : public InterfaceControllerListener {
+  public:
+    virtual ~DishWashingCyclePhaseIntfControllerListener() {}
+
+    /**
+     * Callback handler for getting CyclePhase property
+     * @param[in] status ER_OK on success
+     * @param[in] objectPath the object path
+     * @param[in] cycle phase current cycle phase
+     * @param[in] context the context that is passed from application
+     */
+    virtual void OnResponseGetCyclePhase(QStatus status, const qcc::String& objectPath, const uint8_t& cyclePhase, void* context) {}
+
+    /**
+     * Callback handler for getting list of supported cyclePhases
+     * @param[in] status ER_OK on success
+     * @param[in] objectPath the object path
+     * @param[in] listOfCyclePhases list of supported cycle phases
+     * @param[in] context the context that is passed from application
+     */
+    virtual void OnResponseGetSupportedCyclePhases(QStatus status, const qcc::String& objectPath, const DishWashingCyclePhaseInterface::SupportedCyclePhases& listOfCyclePhases, void* context) {}
+
+    /**
+     * Handler for CyclePhase property changed
+     * @param[in] objectPath the object path
+     * @param[in] cyclePhase current cycle phase
+     */
+    virtual void OnCyclePhasePropertyChanged(const qcc::String& objectPath, const uint8_t cyclePhase) {}
+
+    /**
+     * Handler for SupportedCyclePhases property changed
+     * @param[in] objectPath the object path
+     * @param[in] listOfCyclePhases list of cycle phases
+     */
+    virtual void OnSupportedCyclePhasesPropertyChanged(const qcc::String& objectPath, const DishWashingCyclePhaseInterface::SupportedCyclePhases listOfCyclePhases) {}
+
+    /**
+     * Callback handler for GetCyclePhasesDescriptions method
+     * @param[in] status ER_OK on success
+     * @param[in] objectPath the object path
+     * @param[in] context the context that is passed from application
+     * @param[in] errorName the detail errorName is passed when the method call is failed
+     * @param[in] errorMessage the errorMessage that describes the error
+     * @param[out]listOfCycleDescriptions list of cycle phases descriptions
+     */
+    virtual void OnResponseGetCyclePhasesDescriptions(QStatus status, const qcc::String& objectPath, const DishWashingCyclePhaseInterface::CyclePhaseDescriptions& listOfCycleDescriptions,
+                                                      void* context, const char* errorName, const char* errorMessage) {}
+};
+
+} //namespace services
+} //namespace ajn
+
+#endif /* DISHWASHINGCYCLEPHASEINTFCONTROLLERLISTENER_H_ */
diff --git a/cpp/inc/alljoyn/hae/interfaces/operation/HeatingZoneInterface.h b/cpp/inc/alljoyn/hae/interfaces/operation/HeatingZoneInterface.h
new file mode 100644
index 0000000..964c76a
--- /dev/null
+++ b/cpp/inc/alljoyn/hae/interfaces/operation/HeatingZoneInterface.h
@@ -0,0 +1,75 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#ifndef HEATINGZONEINTERFACE_H_
+#define HEATINGZONEINTERFACE_H_
+
+#include <qcc/String.h>
+#include <alljoyn/Status.h>
+#include <alljoyn/hae/interfaces/HaeInterface.h>
+
+namespace ajn {
+namespace services {
+
+/**
+ * HeatingZone Interface class
+ */
+class HeatingZoneInterface : public HaeInterface {
+  public:
+    /**
+     * Constructor of HeatingZone
+     */
+    HeatingZoneInterface() {}
+
+    /**
+     * Destructor of HeatingZone
+     */
+    virtual ~HeatingZoneInterface() {}
+
+    /**
+     * Get Interface Type
+     * @return interface type
+     */
+    const HaeInterfaceType GetInterfaceType() const { return HEATING_ZONE_INTERFACE; }
+
+    /**
+     * Get Introspection Xml
+     * @return xml
+     */
+    virtual const qcc::String& GetIntrospectionXml() { return s_xml; }
+
+    /**
+     * Get Interface version
+     * @return interface version
+     */
+    virtual const uint16_t GetInterfaceVersion() const { return s_interfaceVersion; }
+
+  protected:
+    static const qcc::String s_prop_Version;
+    static const qcc::String s_prop_NumberOfHeatingZones;
+    static const qcc::String s_prop_MaxHeatingLevels;
+    static const qcc::String s_prop_HeatingLevels;
+
+
+  private:
+    static const qcc::String s_xml;
+    static const uint16_t s_interfaceVersion;
+};
+
+} //namespace services
+} //namespace ajn
+
+#endif /* HEATINGZONEINTERFACE_H_ */
diff --git a/cpp/inc/alljoyn/hae/interfaces/operation/HeatingZoneIntfControllee.h b/cpp/inc/alljoyn/hae/interfaces/operation/HeatingZoneIntfControllee.h
new file mode 100644
index 0000000..3b7b7ab
--- /dev/null
+++ b/cpp/inc/alljoyn/hae/interfaces/operation/HeatingZoneIntfControllee.h
@@ -0,0 +1,86 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#ifndef HEATINGZONEINTFCONTROLLEE_H_
+#define HEATINGZONEINTFCONTROLLEE_H_
+
+#include <qcc/String.h>
+#include <alljoyn/Status.h>
+#include <vector>
+#include <alljoyn/hae/interfaces/operation/HeatingZoneInterface.h>
+
+namespace ajn {
+namespace services {
+
+/**
+ * HeatingZone Interface Controllee class
+ */
+class HeatingZoneIntfControllee : public HeatingZoneInterface {
+  public:
+    /**
+     * Constructor of HeatingZoneIntfControllee
+     */
+    HeatingZoneIntfControllee() {}
+
+    /**
+     * Destructor of HeatingZoneIntfControllee
+     */
+    virtual ~HeatingZoneIntfControllee() {}
+
+    /**
+     * Get number of heating zones
+     * @return NumberOfHeatingZones
+     */
+    virtual const uint8_t GetNumberOfHeatingZones() const = 0;
+
+    /**
+     * Set NumberOfHeatingZones
+     * @param[in] numberOfZones number of heating zones
+     * @return ER_OK on success
+     */
+    virtual QStatus SetNumberOfHeatingZones(const uint8_t numberOfZones) = 0;
+
+    /**
+     * Get MaxHeatingLevels
+     * @return the list of maximum heating levels
+     */
+    virtual const std::vector<uint8_t>& GetMaxHeatingLevels() const = 0;
+
+    /**
+     * Set MaxHeatingLevels
+     * @param[in] maxHeatingLevels maxHeatingLevels
+     * @return ER_OK on success
+     */
+    virtual QStatus SetMaxHeatingLevels(const std::vector<uint8_t>& maxHeatingLevels) = 0;
+
+    /**
+     * Get HeatingLevels
+     * @return the list of heating levels
+     */
+    virtual const std::vector<uint8_t>& GetHeatingLevels() const = 0;
+
+    /**
+     * Set HeatingLevels
+     * @param[in] heatingLevels heatingLevels
+     * @return ER_OK on success
+     */
+    virtual QStatus SetHeatingLevels(const std::vector<uint8_t>& heatingLevels) = 0;
+};
+
+} //namespace services
+} //namespace ajn
+
+#endif /* HEATINGZONEINTFCONTROLLEE_H_ */
diff --git a/cpp/inc/alljoyn/hae/interfaces/operation/HeatingZoneIntfControlleeListener.h b/cpp/inc/alljoyn/hae/interfaces/operation/HeatingZoneIntfControlleeListener.h
new file mode 100644
index 0000000..8f3706a
--- /dev/null
+++ b/cpp/inc/alljoyn/hae/interfaces/operation/HeatingZoneIntfControlleeListener.h
@@ -0,0 +1,65 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#ifndef HEATINGZONEINTFCONTROLLEELISTENER_H_
+#define HEATINGZONEINTFCONTROLLEELISTENER_H_
+
+#include <vector>
+#include <qcc/String.h>
+#include <alljoyn/Status.h>
+#include <alljoyn/hae/interfaces/HaeInterfaceErrors.h>
+#include <alljoyn/hae/interfaces/InterfaceControlleeListener.h>
+
+namespace ajn {
+namespace services {
+
+/**
+ * HeatingZone Interface Controllee Listener class
+ */
+class HeatingZoneIntfControlleeListener : public InterfaceControlleeListener {
+  public:
+    /**
+     * Destructor of HeatingZoneIntfControlleeListener
+     */
+    virtual ~HeatingZoneIntfControlleeListener() {}
+
+    /**
+     * Handler for getting number of heating zones
+     * This function is only called, when InterfaceControllee::s_retrievingActualPropertyValue is true.
+     * @param[out] currentState currentState
+     * @return ER_OK on success
+     */
+    virtual QStatus OnGetNumberOfHeatingZones(uint8_t& currentState) = 0;
+    /**
+     * Handler for getting max heating levels
+     * This function is only called, when InterfaceControllee::s_retrievingActualPropertyValue is true.
+     * @param[out] maxHeatingLevels maxHeatingLevels
+     * @return ER_OK on success
+     */
+    virtual QStatus OnGetMaxHeatingLevels(std::vector<uint8_t>& maxHeatingLevels) = 0;
+    /**
+     * Handler for getting heating levels
+     * This function is only called, when InterfaceControllee::s_retrievingActualPropertyValue is true.
+     * @param[out] heatingLevels heatingLevels
+     * @return ER_OK on success
+     */
+    virtual QStatus OnGetHeatingLevels(std::vector<uint8_t>& heatingLevels) = 0;
+};
+
+} //namespace services
+} //namespace ajn
+
+#endif /* HEATINGZONEINTFCONTROLLEELISTENER_H_ */
diff --git a/cpp/inc/alljoyn/hae/interfaces/operation/HeatingZoneIntfController.h b/cpp/inc/alljoyn/hae/interfaces/operation/HeatingZoneIntfController.h
new file mode 100644
index 0000000..4dbcde1
--- /dev/null
+++ b/cpp/inc/alljoyn/hae/interfaces/operation/HeatingZoneIntfController.h
@@ -0,0 +1,52 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#ifndef HEATINGZONEINTFCONTROLLER_H_
+#define HEATINGZONEINTFCONTROLLER_H_
+
+#include <qcc/String.h>
+#include <alljoyn/Status.h>
+#include <alljoyn/hae/interfaces/operation/HeatingZoneInterface.h>
+
+namespace ajn {
+namespace services {
+
+/**
+ * HeatingZone Interface Controller class
+ */
+class HeatingZoneIntfController : public HeatingZoneInterface {
+  public:
+    /**
+     * Constructor of HeatingZoneIntfController
+     */
+    HeatingZoneIntfController() {}
+
+    /**
+     * Destructor of HeatingZoneIntfController
+     */
+    virtual ~HeatingZoneIntfController() {}
+
+    virtual QStatus GetNumberOfHeatingZones(void* context = NULL) = 0;
+
+    virtual QStatus GetMaxHeatingLevels(void* context = NULL) = 0;
+
+    virtual QStatus GetHeatingLevels(void* context = NULL) = 0;
+};
+
+} //namespace services
+} //namespace ajn
+
+#endif /* HEATINGZONEINTFCONTROLLER_H_ */
diff --git a/cpp/inc/alljoyn/hae/interfaces/operation/HeatingZoneIntfControllerListener.h b/cpp/inc/alljoyn/hae/interfaces/operation/HeatingZoneIntfControllerListener.h
new file mode 100644
index 0000000..cc3e5fa
--- /dev/null
+++ b/cpp/inc/alljoyn/hae/interfaces/operation/HeatingZoneIntfControllerListener.h
@@ -0,0 +1,87 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#ifndef HEATINGZONEINTFCONTROLLERLISTENER_H_
+#define HEATINGZONEINTFCONTROLLERLISTENER_H_
+
+#include <vector>
+#include <qcc/String.h>
+#include <alljoyn/Status.h>
+#include <alljoyn/hae/interfaces/InterfaceControllerListener.h>
+
+namespace ajn {
+namespace services {
+
+/**
+ * HeatingZone Interface Controller Listener class
+ */
+class HeatingZoneIntfControllerListener : public InterfaceControllerListener {
+  public:
+    virtual ~HeatingZoneIntfControllerListener() {}
+
+    /**
+     * Callback handler for getting NumberOfHeatingZones property
+     * @param[in] status ER_OK on success
+     * @param[in] objectPath the object path
+     * @param[in] numberOfZones number of heating zones
+     * @param[in] context the context that is passed from application
+     */
+    virtual void OnGetNumberOfHeatingZonesPropertyCallback(QStatus status, const qcc::String& objectPath, const uint8_t numberOfZones, void* context) {}
+
+    /**
+     * Callback handler for getting MaxHeatingLevels property
+     * @param[in] status ER_OK on success
+     * @param[in] objectPath the object path
+     * @param[in] maxHeatingLevels The list of max heating levels
+     * @param[in] context the context that is passed from application
+     */
+    virtual void OnGetMaxHeatingLevelsPropertyCallback(QStatus status, const qcc::String& objectPath, const std::vector<uint8_t>& maxHeatingLevels, void* context) {}
+
+    /**
+     * Callback handler for getting HeatingLevels property
+     * @param[in] status ER_OK on success
+     * @param[in] objectPath the object path
+     * @param[in] heatingLevels The list heating levels
+     * @param[in] context the context that is passed from application
+     */
+    virtual void OnGetHeatingLevelsPropertyCallback(QStatus status, const qcc::String& objectPath, const std::vector<uint8_t>& heatingLevels, void* context) {}
+
+    /**
+     * Handler for NumberOfHeating property changed
+     * @param[in] objectPath the object path
+     * @param[in] numberOfHeatingZones number of heating zones
+     */
+    virtual void NumberOfHeatingZonesPropertyChanged(const qcc::String& objectPath, const uint8_t numberOfHeatingZones) {}
+
+    /**
+     * Handler for MaxHeatingLevels property changed
+     * @param[in] objectPath the object path
+     * @param[in] maxHeatingLevels max heating levels
+     */
+    virtual void MaxHeatingLevelsPropertyChanged(const qcc::String& objectPath, const std::vector<uint8_t>& maxHeatingLevels) {}
+
+    /**
+     * Handler for HeatingLevels property changed
+     * @param[in] objectPath the object path
+     * @param[in] heatingLevels heating levels
+     */
+    virtual void HeatingLevelsPropertyChanged(const qcc::String& objectPath, const std::vector<uint8_t>& heatingLevels) {}
+};
+
+} //namespace services
+} //namespace ajn
+
+#endif /* HEATINGZONEINTFCONTROLLERLISTENER_H_ */
diff --git a/cpp/inc/alljoyn/hae/interfaces/operation/LaundryCyclePhaseInterface.h b/cpp/inc/alljoyn/hae/interfaces/operation/LaundryCyclePhaseInterface.h
new file mode 100644
index 0000000..66ed389
--- /dev/null
+++ b/cpp/inc/alljoyn/hae/interfaces/operation/LaundryCyclePhaseInterface.h
@@ -0,0 +1,100 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#ifndef LAUNDRYCYCLEPHASEINTERFACE_H_
+#define LAUNDRYCYCLEPHASEINTERFACE_H_
+
+#include <vector>
+#include <qcc/String.h>
+#include <alljoyn/Status.h>
+#include <alljoyn/hae/interfaces/HaeInterface.h>
+
+namespace ajn {
+namespace services {
+
+/**
+ * LaundryCyclePhase Interface class
+ */
+class LaundryCyclePhaseInterface : public HaeInterface {
+  public:
+    typedef struct {
+        uint8_t phase;
+        qcc::String name;
+        qcc::String description;
+    }LaundryPhaseDescriptor;
+
+    typedef enum {
+        LAUNDRY_PHASE_UNAVAILABLE,
+        LAUNDRY_PHASE_PRE_WASHING,
+        LAUNDRY_PHASE_WASHING,
+        LAUNDRY_PHASE_RINSING,
+        LAUNDRY_PHASE_SPINNING,
+        LAUNDRY_PHASE_STEAM,
+        LAUNDRY_PHASE_DRYING,
+        LAUNDRY_PHASE_COOLING,
+        LAUNDRY_PHASE_ANTICREASING
+    }LaundryCyclePhase;
+
+    typedef std::vector<LaundryCyclePhase> StandardCyclePhases;
+
+    typedef std::vector<uint8_t> SupportedCyclePhases;
+    typedef std::vector<LaundryPhaseDescriptor> CyclePhaseDescriptions;
+
+    static const StandardCyclePhases m_standardCyclePhases;
+    /**
+     * Constructor of LaundryCyclePhase
+     */
+    LaundryCyclePhaseInterface() {}
+
+    /**
+     * Destructor of LaundryCyclePhase
+     */
+    virtual ~LaundryCyclePhaseInterface() {}
+
+    /**
+     * Get Interface Type
+     * @return interface type
+     */
+    const HaeInterfaceType GetInterfaceType() const { return LAUNDRY_CYCLE_PHASE_INTERFACE; }
+
+    /**
+     * Get Introspection Xml
+     * @return xml
+     */
+    virtual const qcc::String& GetIntrospectionXml() { return s_xml; }
+
+    /**
+     * Get Interface version
+     * @return interface version
+     */
+    virtual const uint16_t GetInterfaceVersion() const { return s_interfaceVersion; }
+
+  protected:
+    static const qcc::String s_prop_Version;
+    static const qcc::String s_prop_CyclePhase;
+    static const qcc::String s_prop_SupportedCyclePhases;
+    static const qcc::String s_method_GetVendorPhasesDescription;
+
+
+  private:
+    static const qcc::String s_xml;
+    static const uint16_t s_interfaceVersion;
+};
+
+} //namespace services
+} //namespace ajn
+
+#endif /* LAUNDRYCYCLEPHASEINTERFACE_H_ */
diff --git a/cpp/inc/alljoyn/hae/interfaces/operation/LaundryCyclePhaseIntfControllee.h b/cpp/inc/alljoyn/hae/interfaces/operation/LaundryCyclePhaseIntfControllee.h
new file mode 100644
index 0000000..d8a7159
--- /dev/null
+++ b/cpp/inc/alljoyn/hae/interfaces/operation/LaundryCyclePhaseIntfControllee.h
@@ -0,0 +1,80 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#ifndef LAUNDRYCYCLEPHASEINTFCONTROLLEE_H_
+#define LAUNDRYCYCLEPHASEINTFCONTROLLEE_H_
+
+#include <qcc/String.h>
+#include <alljoyn/Status.h>
+#include <alljoyn/hae/interfaces/operation/LaundryCyclePhaseInterface.h>
+
+namespace ajn {
+namespace services {
+
+/**
+ * LaundryCyclePhase Interface Controllee class
+ */
+class LaundryCyclePhaseIntfControllee : public LaundryCyclePhaseInterface {
+  public:
+    /**
+     * Constructor of LaundryCyclePhaseIntfControllee
+     */
+    LaundryCyclePhaseIntfControllee() {}
+
+    /**
+     * Destructor of LaundryCyclePhaseIntfControllee
+     */
+    virtual ~LaundryCyclePhaseIntfControllee() {}
+
+    /**
+     * Get CyclePhase
+     * @return current cycle phase
+     */
+    virtual const uint8_t GetCyclePhase() const = 0;
+
+    /**
+     * Set CyclePhase
+     * @param[in]  cyclePhase the cycle phase to set
+     * @return ER_OK on success
+     */
+    virtual QStatus SetCyclePhase(const uint8_t cyclePhase) = 0;
+
+    /**
+     * Get SupportedCyclePhases
+     * @return the list of supported cycle phases
+     */
+    virtual const SupportedCyclePhases& GetSupportedCyclePhases() const = 0;
+
+    /**
+     * Set OperationalState
+     * @param[in]  supportedCyclePhases the list of supported cycle phases to set
+     * @return ER_OK on success
+     */
+    virtual QStatus SetSupportedCyclePhases(const SupportedCyclePhases& supportedCyclePhases) = 0;
+
+    /**
+     * Set VendorDefinedCyclePhases
+     * @param[in]  vendorPhases the list of vendor defined cycle phases to set
+     * @return ER_OK on success
+     */
+    virtual QStatus SetVendorDefinedCyclePhases(const std::vector<uint8_t>& vendorPhases) = 0;
+
+};
+
+} //namespace services
+} //namespace ajn
+
+#endif /* LAUNDRYCYCLEPHASEINTFCONTROLLEE_H_ */
diff --git a/cpp/inc/alljoyn/hae/interfaces/operation/LaundryCyclePhaseIntfControlleeListener.h b/cpp/inc/alljoyn/hae/interfaces/operation/LaundryCyclePhaseIntfControlleeListener.h
new file mode 100644
index 0000000..2f37108
--- /dev/null
+++ b/cpp/inc/alljoyn/hae/interfaces/operation/LaundryCyclePhaseIntfControlleeListener.h
@@ -0,0 +1,70 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#ifndef LAUNDRYCYCLEPHASEINTFCONTROLLEELISTENER_H_
+#define LAUNDRYCYCLEPHASEINTFCONTROLLEELISTENER_H_
+
+#include <qcc/String.h>
+#include <alljoyn/Status.h>
+#include <alljoyn/hae/interfaces/HaeInterfaceErrors.h>
+#include <alljoyn/hae/interfaces/InterfaceControlleeListener.h>
+#include <alljoyn/hae/interfaces/operation/LaundryCyclePhaseInterface.h>
+
+namespace ajn {
+namespace services {
+
+/**
+ * LaundryCyclePhase Interface Controllee Listener class
+ */
+class LaundryCyclePhaseIntfControlleeListener : public InterfaceControlleeListener {
+  public:
+    /**
+     * Destructor of LaundryCyclePhaseIntfControlleeListener
+     */
+    virtual ~LaundryCyclePhaseIntfControlleeListener() {}
+
+    /**
+     * Handler for getting current cycle phase
+     * This function is only called, when InterfaceControllee::s_retrievingActualPropertyValue is true.
+     * @param[out] cyclePhase cyclePhase
+     * @return ER_OK on success
+     */
+    virtual QStatus OnGetCyclePhase(uint8_t& cyclePhase) = 0;
+
+    /**
+     * Handler for getting list of supported cycle phases
+     * This function is only called, when InterfaceControllee::s_retrievingActualPropertyValue is true.
+     * @param[out] listOfSupportedCyclePhases list of supported cycle phases
+     * @return ER_OK on success
+     */
+    virtual QStatus OnGetSupportedCyclePhases(LaundryCyclePhaseInterface::SupportedCyclePhases& listOfSupportedCyclePhases) = 0;
+
+    /**
+     * Handler for getting list cycle phases descriptions
+     * This function is only called, when InterfaceControllee::s_retrievingActualPropertyValue is true.
+     * @param[in] language language
+     * @param[out] listOfPhaseDescs list of cycle phases descriptions
+     * @return ER_OK on success
+     */
+    virtual QStatus OnGetCyclePhasesDescriptions(const qcc::String& language,
+                                                 LaundryCyclePhaseInterface::CyclePhaseDescriptions& listOfPhaseDescs,
+                                                 ErrorCode& errorCode) = 0;
+};
+
+} //namespace services
+} //namespace ajn
+
+#endif /* LAUNDRYCYCLEPHASEINTFCONTROLLEELISTENER_H_ */
diff --git a/cpp/inc/alljoyn/hae/interfaces/operation/LaundryCyclePhaseIntfController.h b/cpp/inc/alljoyn/hae/interfaces/operation/LaundryCyclePhaseIntfController.h
new file mode 100644
index 0000000..f00d838
--- /dev/null
+++ b/cpp/inc/alljoyn/hae/interfaces/operation/LaundryCyclePhaseIntfController.h
@@ -0,0 +1,68 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#ifndef LAUNDRYCYCLEPHASEINTFCONTROLLER_H_
+#define LAUNDRYCYCLEPHASEINTFCONTROLLER_H_
+
+#include <qcc/String.h>
+#include <alljoyn/Status.h>
+#include <alljoyn/hae/interfaces/operation/LaundryCyclePhaseInterface.h>
+
+namespace ajn {
+namespace services {
+
+/**
+ * LaundryCyclePhase Interface Controller class
+ */
+class LaundryCyclePhaseIntfController : public LaundryCyclePhaseInterface {
+  public:
+    /**
+     * Constructor of LaundryCyclePhaseIntfController
+     */
+    LaundryCyclePhaseIntfController() {}
+
+    /**
+     * Destructor of LaundryCyclePhaseIntfController
+     */
+    virtual ~LaundryCyclePhaseIntfController() {}
+
+    /**
+     * Get CyclePhase
+     * @param[in] context the context that is passed to the callback handler
+     * @return ER_OK on success
+     */
+    virtual QStatus GetCyclePhase(void* context = NULL) = 0;
+
+    /**
+     * Get SupportedCyclePhases
+     * @param[in] context the context that is passed to the callback handler
+     * @return ER_OK on success
+     */
+    virtual QStatus GetSupportedCyclePhases(void* context = NULL) = 0;
+
+    /**
+     * Get CyclePhasesDescriptions
+     * @param[in] language language
+     * @param[in] context the context that is passed to the callback handler
+     * @return ER_OK on success
+     */
+    virtual QStatus GetCyclePhasesDescriptions(const qcc::String& language, void* context = NULL) = 0;
+};
+
+} //namespace services
+} //namespace ajn
+
+#endif /* LAUNDRYCYCLEPHASEINTFCONTROLLER_H_ */
diff --git a/cpp/inc/alljoyn/hae/interfaces/operation/LaundryCyclePhaseIntfControllerListener.h b/cpp/inc/alljoyn/hae/interfaces/operation/LaundryCyclePhaseIntfControllerListener.h
new file mode 100644
index 0000000..bcd273d
--- /dev/null
+++ b/cpp/inc/alljoyn/hae/interfaces/operation/LaundryCyclePhaseIntfControllerListener.h
@@ -0,0 +1,83 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#ifndef LAUNDRYCYCLEPHASEINTFCONTROLLERLISTENER_H_
+#define LAUNDRYCYCLEPHASEINTFCONTROLLERLISTENER_H_
+
+#include <qcc/String.h>
+#include <alljoyn/Status.h>
+#include <alljoyn/hae/interfaces/InterfaceControllerListener.h>
+#include <alljoyn/hae/interfaces/operation/LaundryCyclePhaseInterface.h>
+
+namespace ajn {
+namespace services {
+
+/**
+ * LaundryCyclePhase Interface Controller Listener class
+ */
+class LaundryCyclePhaseIntfControllerListener : public InterfaceControllerListener {
+  public:
+    virtual ~LaundryCyclePhaseIntfControllerListener() {}
+
+    /**
+     * Callback handler for getting CyclePhase property
+     * @param[in] status ER_OK on success
+     * @param[in] objectPath the object path
+     * @param[in] cycle phase current cycle phase
+     * @param[in] context the context that is passed from application
+     */
+    virtual void OnResponseGetCyclePhase(QStatus status, const qcc::String& objectPath, const uint8_t& cyclePhase, void* context) {}
+
+    /**
+     * Callback handler for getting list of supported cyclePhases
+     * @param[in] status ER_OK on success
+     * @param[in] objectPath the object path
+     * @param[in] listOfCyclePhases list of supported cycle phases
+     * @param[in] context the context that is passed from application
+     */
+    virtual void OnResponseGetSupportedCyclePhases(QStatus status, const qcc::String& objectPath, const LaundryCyclePhaseInterface::SupportedCyclePhases& listOfCyclePhases, void* context) {}
+
+    /**
+     * Handler for CyclePhase property changed
+     * @param[in] objectPath the object path
+     * @param[in] cyclePhase current cycle phase
+     */
+    virtual void OnCyclePhasePropertyChanged(const qcc::String& objectPath, const uint8_t cyclePhase) {}
+
+    /**
+     * Handler for SupportedCyclePhases property changed
+     * @param[in] objectPath the object path
+     * @param[in] listOfCyclePhases list of cycle phases
+     */
+    virtual void OnSupportedCyclePhasesPropertyChanged(const qcc::String& objectPath, const LaundryCyclePhaseInterface::SupportedCyclePhases& listOfCyclePhases) {}
+
+    /**
+     * Callback handler for GetCyclePhasesDescriptions method
+     * @param[in] status ER_OK on success
+     * @param[in] objectPath the object path
+     * @param[in] context the context that is passed from application
+     * @param[in] errorName the detail errorName is passed when the method call is failed
+     * @param[in] errorMessage the errorMessage that describes the error
+     * @param[out]listOfCycleDescriptions list of cycle phases descriptions
+     */
+    virtual void OnResponseGetCyclePhasesDescriptions(QStatus status, const qcc::String& objectPath, const LaundryCyclePhaseInterface::CyclePhaseDescriptions& listOfCycleDescriptions,
+                                                      void* context, const char* errorName, const char* errorMessage) {}
+};
+
+} //namespace services
+} //namespace ajn
+
+#endif /* LAUNDRYCYCLEPHASEINTFCONTROLLERLISTENER_H_ */
diff --git a/cpp/inc/alljoyn/hae/interfaces/operation/OvenCyclePhaseInterface.h b/cpp/inc/alljoyn/hae/interfaces/operation/OvenCyclePhaseInterface.h
new file mode 100644
index 0000000..18871b4
--- /dev/null
+++ b/cpp/inc/alljoyn/hae/interfaces/operation/OvenCyclePhaseInterface.h
@@ -0,0 +1,96 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#ifndef OVENCYCLEPHASEINTERFACE_H_
+#define OVENCYCLEPHASEINTERFACE_H_
+
+#include <vector>
+#include <qcc/String.h>
+#include <alljoyn/Status.h>
+#include <alljoyn/hae/interfaces/HaeInterface.h>
+
+namespace ajn {
+namespace services {
+
+/**
+ * OvenCyclePhase Interface class
+ */
+class OvenCyclePhaseInterface : public HaeInterface {
+  public:
+
+    typedef struct {
+        uint8_t phase;
+        qcc::String name;
+        qcc::String description;
+    }OvenPhaseDescriptor;
+
+    typedef enum {
+        OVEN_PHASE_UNAVAILABLE,
+        OVEN_PHASE_PREHEATING,
+        OVEN_PHASE_COOKING,
+        OVEN_PHASE_CLEANING
+    }OvenCyclePhase;
+
+    typedef std::vector<OvenCyclePhase> StandardCyclePhases;
+
+    typedef std::vector<uint8_t> SupportedCyclePhases;
+    typedef std::vector<OvenPhaseDescriptor> CyclePhaseDescriptions;
+
+    static const StandardCyclePhases m_standardCyclePhases;
+    /**
+     * Constructor of OvenCyclePhase
+     */
+    OvenCyclePhaseInterface() {}
+
+    /**
+     * Destructor of OvenCyclePhase
+     */
+    virtual ~OvenCyclePhaseInterface() {}
+
+    /**
+     * Get Interface Type
+     * @return interface type
+     */
+    const HaeInterfaceType GetInterfaceType() const { return OVEN_CYCLE_PHASE_INTERFACE; }
+
+    /**
+     * Get Introspection Xml
+     * @return xml
+     */
+    virtual const qcc::String& GetIntrospectionXml() { return s_xml; }
+
+    /**
+     * Get Interface version
+     * @return interface version
+     */
+    virtual const uint16_t GetInterfaceVersion() const { return s_interfaceVersion; }
+
+  protected:
+    static const qcc::String s_prop_Version;
+    static const qcc::String s_prop_CyclePhase;
+    static const qcc::String s_prop_SupportedCyclePhases;
+    static const qcc::String s_method_GetVendorPhasesDescription;
+
+
+  private:
+    static const qcc::String s_xml;
+    static const uint16_t s_interfaceVersion;
+};
+
+} //namespace services
+} //namespace ajn
+
+#endif /* OVENCYCLEPHASEINTERFACE_H_ */
diff --git a/cpp/inc/alljoyn/hae/interfaces/operation/OvenCyclePhaseIntfControllee.h b/cpp/inc/alljoyn/hae/interfaces/operation/OvenCyclePhaseIntfControllee.h
new file mode 100644
index 0000000..204a6d9
--- /dev/null
+++ b/cpp/inc/alljoyn/hae/interfaces/operation/OvenCyclePhaseIntfControllee.h
@@ -0,0 +1,79 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#ifndef OVENCYCLEPHASEINTFCONTROLLEE_H_
+#define OVENCYCLEPHASEINTFCONTROLLEE_H_
+
+#include <qcc/String.h>
+#include <alljoyn/Status.h>
+#include <alljoyn/hae/interfaces/operation/OvenCyclePhaseInterface.h>
+
+namespace ajn {
+namespace services {
+
+/**
+ * OvenCyclePhase Interface Controllee class
+ */
+class OvenCyclePhaseIntfControllee : public OvenCyclePhaseInterface {
+  public:
+    /**
+     * Constructor of OvenCyclePhaseIntfControllee
+     */
+    OvenCyclePhaseIntfControllee() {}
+
+    /**
+     * Destructor of OvenCyclePhaseIntfControllee
+     */
+    virtual ~OvenCyclePhaseIntfControllee() {}
+
+    /**
+     * Get CyclePhase
+     * @return current cycle phase
+     */
+    virtual const uint8_t GetCyclePhase() const = 0;
+
+    /**
+     * Set CyclePhase
+     * @param[in]  cyclePhase the cycle phase to set
+     * @return ER_OK on success
+     */
+    virtual QStatus SetCyclePhase(const uint8_t cyclePhase) = 0;
+
+    /**
+     * Get SupportedCyclePhases
+     * @return the list of supported cycle phases
+     */
+    virtual const SupportedCyclePhases& GetSupportedCyclePhases() const = 0;
+
+    /**
+     * Set OperationalState
+     * @param[in]  supportedCyclePhases the list of supported cycle phases to set
+     * @return ER_OK on success
+     */
+    virtual QStatus SetSupportedCyclePhases(const SupportedCyclePhases& supportedCyclePhases) = 0;
+
+    /**
+     * Set VendorDefinedCyclePhases
+     * @param[in]  vendorPhases the list of vendor defined cycle phases to set
+     * @return ER_OK on success
+     */
+    virtual QStatus SetVendorDefinedCyclePhases(const std::vector<uint8_t>& vendorPhases) = 0;
+};
+
+} //namespace services
+} //namespace ajn
+
+#endif /* OVENCYCLEPHASEINTFCONTROLLEE_H_ */
diff --git a/cpp/inc/alljoyn/hae/interfaces/operation/OvenCyclePhaseIntfControlleeListener.h b/cpp/inc/alljoyn/hae/interfaces/operation/OvenCyclePhaseIntfControlleeListener.h
new file mode 100644
index 0000000..faf56b2
--- /dev/null
+++ b/cpp/inc/alljoyn/hae/interfaces/operation/OvenCyclePhaseIntfControlleeListener.h
@@ -0,0 +1,70 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#ifndef OVENCYCLEPHASEINTFCONTROLLEELISTENER_H_
+#define OVENCYCLEPHASEINTFCONTROLLEELISTENER_H_
+
+#include <qcc/String.h>
+#include <alljoyn/Status.h>
+#include <alljoyn/hae/interfaces/HaeInterfaceErrors.h>
+#include <alljoyn/hae/interfaces/InterfaceControlleeListener.h>
+#include <alljoyn/hae/interfaces/operation/OvenCyclePhaseInterface.h>
+
+namespace ajn {
+namespace services {
+
+/**
+ * OvenCyclePhase Interface Controllee Listener class
+ */
+class OvenCyclePhaseIntfControlleeListener : public InterfaceControlleeListener {
+  public:
+    /**
+     * Destructor of OvenCyclePhaseIntfControlleeListener
+     */
+    virtual ~OvenCyclePhaseIntfControlleeListener() {}
+
+    /**
+     * Handler for getting current cycle phase
+     * This function is only called, when InterfaceControllee::s_retrievingActualPropertyValue is true.
+     * @param[out] cyclePhase cyclePhase
+     * @return ER_OK on success
+     */
+    virtual QStatus OnGetCyclePhase(uint8_t& cyclePhase) = 0;
+
+    /**
+     * Handler for getting list of supported cycle phases
+     * This function is only called, when InterfaceControllee::s_retrievingActualPropertyValue is true.
+     * @param[out] listOfSupportedCyclePhases list of supported cycle phases
+     * @return ER_OK on success
+     */
+    virtual QStatus OnGetSupportedCyclePhases(OvenCyclePhaseInterface::SupportedCyclePhases& listOfSupportedCyclePhases) = 0;
+
+    /**
+     * Handler for getting list cycle phases descriptions
+     * This function is only called, when InterfaceControllee::s_retrievingActualPropertyValue is true.
+     * @param[in] language language
+     * @param[out] listOfPhaseDescs list of cycle phases descriptions
+     * @return ER_OK on success
+     */
+    virtual QStatus OnGetCyclePhasesDescriptions(const qcc::String language,
+                                                 OvenCyclePhaseInterface::CyclePhaseDescriptions& listOfPhaseDescs,
+                                                 ErrorCode& errorCode) = 0;
+};
+
+} //namespace services
+} //namespace ajn
+
+#endif /* OVENCYCLEPHASEINTFCONTROLLEELISTENER_H_ */
diff --git a/cpp/inc/alljoyn/hae/interfaces/operation/OvenCyclePhaseIntfController.h b/cpp/inc/alljoyn/hae/interfaces/operation/OvenCyclePhaseIntfController.h
new file mode 100644
index 0000000..8f26737
--- /dev/null
+++ b/cpp/inc/alljoyn/hae/interfaces/operation/OvenCyclePhaseIntfController.h
@@ -0,0 +1,68 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#ifndef OVENCYCLEPHASEINTFCONTROLLER_H_
+#define OVENCYCLEPHASEINTFCONTROLLER_H_
+
+#include <qcc/String.h>
+#include <alljoyn/Status.h>
+#include <alljoyn/hae/interfaces/operation/OvenCyclePhaseInterface.h>
+
+namespace ajn {
+namespace services {
+
+/**
+ * OvenCyclePhase Interface Controller class
+ */
+class OvenCyclePhaseIntfController : public OvenCyclePhaseInterface {
+  public:
+    /**
+     * Constructor of OvenCyclePhaseIntfController
+     */
+    OvenCyclePhaseIntfController() {}
+
+    /**
+     * Destructor of OvenCyclePhaseIntfController
+     */
+    virtual ~OvenCyclePhaseIntfController() {}
+
+    /**
+     * Get CyclePhase
+     * @param[in] context the context that is passed to the callback handler
+     * @return ER_OK on success
+     */
+    virtual QStatus GetCyclePhase(void* context = NULL) = 0;
+
+    /**
+     * Get SupportedCyclePhases
+     * @param[in] context the context that is passed to the callback handler
+     * @return ER_OK on success
+     */
+    virtual QStatus GetSupportedCyclePhases(void* context = NULL) = 0;
+
+    /**
+     * Get CyclePhasesDescriptions
+     * @param[in] language language
+     * @param[in] context the context that is passed to the callback handler
+     * @return ER_OK on success
+     */
+    virtual QStatus GetCyclePhasesDescriptions(const qcc::String& language, void* context = NULL) = 0;
+};
+
+} //namespace services
+} //namespace ajn
+
+#endif /* OVENCYCLEPHASEINTFCONTROLLER_H_ */
diff --git a/cpp/inc/alljoyn/hae/interfaces/operation/OvenCyclePhaseIntfControllerListener.h b/cpp/inc/alljoyn/hae/interfaces/operation/OvenCyclePhaseIntfControllerListener.h
new file mode 100644
index 0000000..230d343
--- /dev/null
+++ b/cpp/inc/alljoyn/hae/interfaces/operation/OvenCyclePhaseIntfControllerListener.h
@@ -0,0 +1,83 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#ifndef OVENCYCLEPHASEINTFCONTROLLERLISTENER_H_
+#define OVENCYCLEPHASEINTFCONTROLLERLISTENER_H_
+
+#include <qcc/String.h>
+#include <alljoyn/Status.h>
+#include <alljoyn/hae/interfaces/InterfaceControllerListener.h>
+#include <alljoyn/hae/interfaces/operation/OvenCyclePhaseInterface.h>
+
+namespace ajn {
+namespace services {
+
+/**
+ * OvenCyclePhase Interface Controller Listener class
+ */
+class OvenCyclePhaseIntfControllerListener : public InterfaceControllerListener {
+  public:
+    virtual ~OvenCyclePhaseIntfControllerListener() {}
+
+    /**
+     * Callback handler for getting CyclePhase property
+     * @param[in] status ER_OK on success
+     * @param[in] objectPath the object path
+     * @param[in] cycle phase current cycle phase
+     * @param[in] context the context that is passed from application
+     */
+    virtual void OnResponseGetCyclePhase(QStatus status, const qcc::String& objectPath, const uint8_t& cyclePhase, void* context) {}
+
+    /**
+     * Callback handler for getting list of supported cyclePhases
+     * @param[in] status ER_OK on success
+     * @param[in] objectPath the object path
+     * @param[in] listOfCyclePhases list of supported cycle phases
+     * @param[in] context the context that is passed from application
+     */
+    virtual void OnResponseGetSupportedCyclePhases(QStatus status, const qcc::String& objectPath, const OvenCyclePhaseInterface::SupportedCyclePhases& listOfCyclePhases, void* context) {}
+
+    /**
+     * Handler for CyclePhase property changed
+     * @param[in] objectPath the object path
+     * @param[in] cyclePhase current cycle phase
+     */
+    virtual void OnCyclePhasePropertyChanged(const qcc::String& objectPath, const uint8_t cyclePhase) {}
+
+    /**
+     * Handler for SupportedCyclePhases property changed
+     * @param[in] objectPath the object path
+     * @param[in] listOfCyclePhases list of cycle phases
+     */
+    virtual void OnSupportedCyclePhasesPropertyChanged(const qcc::String& objectPath, const OvenCyclePhaseInterface::SupportedCyclePhases& listOfCyclePhases) {}
+
+    /**
+     * Callback handler for GetCyclePhasesDescriptions method
+     * @param[in] status ER_OK on success
+     * @param[in] objectPath the object path
+     * @param[in] context the context that is passed from application
+     * @param[in] errorName the detail errorName is passed when the method call is failed
+     * @param[in] errorMessage the errorMessage that describes the error
+     * @param[out]listOfCycleDescriptions list of cycle phases descriptions
+     */
+    virtual void OnResponseGetCyclePhasesDescriptions(QStatus status, const qcc::String& objectPath, const OvenCyclePhaseInterface::CyclePhaseDescriptions& listOfCycleDescriptions,
+                                                      void* context, const char* errorName, const char* errorMessage) {}
+};
+
+} //namespace services
+} //namespace ajn
+
+#endif /* OVENCYCLEPHASEINTFCONTROLLERLISTENER_H_ */
diff --git a/cpp/inc/alljoyn/hae/interfaces/operation/RapidModeInterface.h b/cpp/inc/alljoyn/hae/interfaces/operation/RapidModeInterface.h
new file mode 100644
index 0000000..5563af2
--- /dev/null
+++ b/cpp/inc/alljoyn/hae/interfaces/operation/RapidModeInterface.h
@@ -0,0 +1,76 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#ifndef RAPIDMODEINTERFACE_H_
+#define RAPIDMODEINTERFACE_H_
+
+#include <qcc/String.h>
+#include <alljoyn/Status.h>
+#include <alljoyn/hae/interfaces/HaeInterface.h>
+
+namespace ajn {
+namespace services {
+
+/**
+ * RapidMode Interface class
+ */
+class RapidModeInterface : public HaeInterface {
+  public:
+    /**
+     * Constructor of RapidMode
+     */
+    RapidModeInterface() {}
+
+    /**
+     * Destructor of RapidMode
+     */
+    virtual ~RapidModeInterface() {}
+
+    /**
+     * Get Interface Type
+     * @return interface type
+     */
+    const HaeInterfaceType GetInterfaceType() const { return RAPID_MODE_INTERFACE; }
+
+    /**
+     * Get Introspection Xml
+     * @return xml
+     */
+    virtual const qcc::String& GetIntrospectionXml() { return s_xml; }
+
+    /**
+     * Get Interface version
+     * @return interface version
+     */
+    virtual const uint16_t GetInterfaceVersion() const { return s_interfaceVersion; }
+
+  protected:
+    static const qcc::String s_prop_Version;
+    static const qcc::String s_prop_RapidMode;
+    /**
+     * TODO: add property, method and signal name variable
+     */
+
+
+  private:
+    static const qcc::String s_xml;
+    static const uint16_t s_interfaceVersion;
+};
+
+} //namespace services
+} //namespace ajn
+
+#endif /* RAPIDMODEINTERFACE_H_ */
diff --git a/cpp/inc/alljoyn/hae/interfaces/operation/RapidModeIntfControllee.h b/cpp/inc/alljoyn/hae/interfaces/operation/RapidModeIntfControllee.h
new file mode 100644
index 0000000..15e9144
--- /dev/null
+++ b/cpp/inc/alljoyn/hae/interfaces/operation/RapidModeIntfControllee.h
@@ -0,0 +1,60 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#ifndef RAPIDMODEINTFCONTROLLEE_H_
+#define RAPIDMODEINTFCONTROLLEE_H_
+
+#include <qcc/String.h>
+#include <alljoyn/Status.h>
+#include <alljoyn/hae/interfaces/operation/RapidModeInterface.h>
+
+namespace ajn {
+namespace services {
+
+/**
+ * RapidMode Interface Controllee class
+ */
+class RapidModeIntfControllee : public RapidModeInterface {
+  public:
+    /**
+     * Constructor of RapidModeIntfControllee
+     */
+    RapidModeIntfControllee() {}
+
+    /**
+     * Destructor of RapidModeIntfControllee
+     */
+    virtual ~RapidModeIntfControllee() {}
+
+    /**
+     * Get RapidMode
+     * @return rapid mode
+     */
+    virtual const bool GetRapidMode() const = 0;
+
+    /**
+     * Set RapidMode
+     * @param[in] rapidMode rapidMode
+     * @return ER_OK on success
+     */
+    virtual QStatus SetRapidMode(const bool rapidMode) = 0;
+
+};
+
+} //namespace services
+} //namespace ajn
+
+#endif /* RAPIDMODEINTFCONTROLLEE_H_ */
diff --git a/cpp/inc/alljoyn/hae/interfaces/operation/RapidModeIntfControlleeListener.h b/cpp/inc/alljoyn/hae/interfaces/operation/RapidModeIntfControlleeListener.h
new file mode 100644
index 0000000..972f297
--- /dev/null
+++ b/cpp/inc/alljoyn/hae/interfaces/operation/RapidModeIntfControlleeListener.h
@@ -0,0 +1,50 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#ifndef RAPIDMODEINTFCONTROLLEELISTENER_H_
+#define RAPIDMODEINTFCONTROLLEELISTENER_H_
+
+#include <qcc/String.h>
+#include <alljoyn/Status.h>
+#include <alljoyn/hae/interfaces/HaeInterfaceErrors.h>
+#include <alljoyn/hae/interfaces/InterfaceControlleeListener.h>
+
+namespace ajn {
+namespace services {
+
+/**
+ * RapidMode Interface Controllee Listener class
+ */
+class RapidModeIntfControlleeListener : public InterfaceControlleeListener {
+  public:
+    /**
+     * Destructor of RapidModeIntfControlleeListener
+     */
+    virtual ~RapidModeIntfControlleeListener() {}
+
+    /**
+     * TODO: define functions that receives the SetProperty, GetProperty and other method call
+     */
+    virtual QStatus OnSetRapidMode(const bool& rapidMode) = 0;
+
+    virtual QStatus OnGetRapidMode(bool& volume) = 0;
+
+};
+
+} //namespace services
+} //namespace ajn
+
+#endif /* RAPIDMODEINTFCONTROLLEELISTENER_H_ */
diff --git a/cpp/inc/alljoyn/hae/interfaces/operation/RapidModeIntfController.h b/cpp/inc/alljoyn/hae/interfaces/operation/RapidModeIntfController.h
new file mode 100644
index 0000000..7624a21
--- /dev/null
+++ b/cpp/inc/alljoyn/hae/interfaces/operation/RapidModeIntfController.h
@@ -0,0 +1,50 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#ifndef RAPIDMODEINTFCONTROLLER_H_
+#define RAPIDMODEINTFCONTROLLER_H_
+
+#include <qcc/String.h>
+#include <alljoyn/Status.h>
+#include <alljoyn/hae/interfaces/operation/RapidModeInterface.h>
+
+namespace ajn {
+namespace services {
+
+/**
+ * RapidMode Interface Controller class
+ */
+class RapidModeIntfController : public RapidModeInterface {
+  public:
+    /**
+     * Constructor of RapidModeIntfController
+     */
+    RapidModeIntfController() {}
+
+    /**
+     * Destructor of RapidModeIntfController
+     */
+    virtual ~RapidModeIntfController() {}
+
+    virtual QStatus GetRapidMode(void* context = NULL) = 0;
+
+    virtual QStatus SetRapidMode(const bool rapidMode, void* context = NULL) = 0;
+};
+
+} //namespace services
+} //namespace ajn
+
+#endif /* RAPIDMODEINTFCONTROLLER_H_ */
diff --git a/cpp/inc/alljoyn/hae/interfaces/operation/RapidModeIntfControllerListener.h b/cpp/inc/alljoyn/hae/interfaces/operation/RapidModeIntfControllerListener.h
new file mode 100644
index 0000000..db17901
--- /dev/null
+++ b/cpp/inc/alljoyn/hae/interfaces/operation/RapidModeIntfControllerListener.h
@@ -0,0 +1,44 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#ifndef RAPIDMODEINTFCONTROLLERLISTENER_H_
+#define RAPIDMODEINTFCONTROLLERLISTENER_H_
+
+#include <qcc/String.h>
+#include <alljoyn/Status.h>
+#include <alljoyn/hae/interfaces/InterfaceControllerListener.h>
+
+namespace ajn {
+namespace services {
+
+/**
+ * RapidMode Interface Controller Listener class
+ */
+class RapidModeIntfControllerListener : public InterfaceControllerListener {
+  public:
+    virtual ~RapidModeIntfControllerListener() {}
+
+    virtual void RapidModePropertyChanged(const qcc::String& objectPath, const bool rapidMode) {}
+
+    virtual void OnSetRapidModePropertyCallback(QStatus status, const qcc::String& objectPath, void* context) {}
+
+    virtual void OnGetRapidModePropertyCallback(QStatus status, const qcc::String& objectPath, const bool rapidMode, void* context) {}
+};
+
+} //namespace services
+} //namespace ajn
+
+#endif /* RAPIDMODEINTFCONTROLLERLISTENER_H_ */
diff --git a/cpp/inc/alljoyn/hae/interfaces/operation/RemoteControllabilityInterface.h b/cpp/inc/alljoyn/hae/interfaces/operation/RemoteControllabilityInterface.h
new file mode 100644
index 0000000..fcf755c
--- /dev/null
+++ b/cpp/inc/alljoyn/hae/interfaces/operation/RemoteControllabilityInterface.h
@@ -0,0 +1,72 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#ifndef REMOTECONTROLLABILITYINTERFACE_H_
+#define REMOTECONTROLLABILITYINTERFACE_H_
+
+#include <qcc/String.h>
+#include <alljoyn/Status.h>
+#include <alljoyn/hae/interfaces/HaeInterface.h>
+
+namespace ajn {
+namespace services {
+
+/**
+ * RemoteControllability Interface class
+ */
+class RemoteControllabilityInterface : public HaeInterface {
+  public:
+    /**
+     * Constructor of RemoteControllability
+     */
+    RemoteControllabilityInterface() {}
+
+    /**
+     * Destructor of RemoteControllability
+     */
+    virtual ~RemoteControllabilityInterface() {}
+
+    /**
+     * Get Interface Type
+     * @return interface type
+     */
+    const HaeInterfaceType GetInterfaceType() const { return REMOTE_CONTROLLABILITY_INTERFACE; }
+
+    /**
+     * Get Introspection Xml
+     * @return xml
+     */
+    virtual const qcc::String& GetIntrospectionXml() { return s_xml; }
+
+    /**
+     * Get Interface version
+     * @return interface version
+     */
+    virtual const uint16_t GetInterfaceVersion() const { return s_interfaceVersion; }
+
+  protected:
+    static const qcc::String s_prop_Version;
+    static const qcc::String s_prop_IsControllable;
+
+  private:
+    static const qcc::String s_xml;
+    static const uint16_t s_interfaceVersion;
+};
+
+} //namespace services
+} //namespace ajn
+
+#endif /* REMOTECONTROLLABILITYINTERFACE_H_ */
diff --git a/cpp/inc/alljoyn/hae/interfaces/operation/RemoteControllabilityIntfControllee.h b/cpp/inc/alljoyn/hae/interfaces/operation/RemoteControllabilityIntfControllee.h
new file mode 100644
index 0000000..8bfda6a
--- /dev/null
+++ b/cpp/inc/alljoyn/hae/interfaces/operation/RemoteControllabilityIntfControllee.h
@@ -0,0 +1,60 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#ifndef REMOTECONTROLLABILITYINTFCONTROLLEE_H_
+#define REMOTECONTROLLABILITYINTFCONTROLLEE_H_
+
+#include <qcc/String.h>
+#include <alljoyn/Status.h>
+#include <alljoyn/hae/interfaces/operation/RemoteControllabilityInterface.h>
+
+namespace ajn {
+namespace services {
+
+/**
+ * RemoteControllability Interface Controllee class
+ */
+class RemoteControllabilityIntfControllee : public RemoteControllabilityInterface {
+  public:
+    /**
+     * Constructor of RemoteControllabilityIntfControllee
+     */
+    RemoteControllabilityIntfControllee() {}
+
+    /**
+     * Destructor of RemoteControllabilityIntfControllee
+     */
+    virtual ~RemoteControllabilityIntfControllee() {}
+
+    /**
+     * Get IsControllable
+     * @return IsControllable
+     */
+    virtual const bool GetIsControllable() const = 0;
+
+    /**
+     * Set IsControllable
+     * @param[in] isControllable IsControllable
+     * @return ER_OK on success
+     */
+    virtual QStatus SetIsControllable(const bool isControllable) = 0;
+
+};
+
+} //namespace services
+} //namespace ajn
+
+#endif /* REMOTECONTROLLABILITYINTFCONTROLLEE_H_ */
diff --git a/cpp/inc/alljoyn/hae/interfaces/operation/RemoteControllabilityIntfControlleeListener.h b/cpp/inc/alljoyn/hae/interfaces/operation/RemoteControllabilityIntfControlleeListener.h
new file mode 100644
index 0000000..bb1c315
--- /dev/null
+++ b/cpp/inc/alljoyn/hae/interfaces/operation/RemoteControllabilityIntfControlleeListener.h
@@ -0,0 +1,50 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#ifndef REMOTECONTROLLABILITYINTFCONTROLLEELISTENER_H_
+#define REMOTECONTROLLABILITYINTFCONTROLLEELISTENER_H_
+
+#include <qcc/String.h>
+#include <alljoyn/Status.h>
+#include <alljoyn/hae/interfaces/InterfaceControlleeListener.h>
+
+namespace ajn {
+namespace services {
+
+/**
+ * RemoteControllability Interface Controllee Listener class
+ */
+class RemoteControllabilityIntfControlleeListener : public InterfaceControlleeListener {
+  public:
+    /**
+     * Destructor of RemoteControllabilityIntfControlleeListener
+     */
+    virtual ~RemoteControllabilityIntfControlleeListener() {}
+
+    /**
+     * Handler for getting isControllable
+     * This function is only called, when InterfaceControllee::s_retrievingActualPropertyValue is true.
+     * @param[out] isControllable isControllable
+     * @return ER_OK on success
+     */
+    virtual QStatus OnGetIsControllable(bool& isControllable) = 0;
+
+};
+
+} //namespace services
+} //namespace ajn
+
+#endif /* REMOTECONTROLLABILITYINTFCONTROLLEELISTENER_H_ */
diff --git a/cpp/inc/alljoyn/hae/interfaces/operation/RemoteControllabilityIntfController.h b/cpp/inc/alljoyn/hae/interfaces/operation/RemoteControllabilityIntfController.h
new file mode 100644
index 0000000..0e77ebc
--- /dev/null
+++ b/cpp/inc/alljoyn/hae/interfaces/operation/RemoteControllabilityIntfController.h
@@ -0,0 +1,54 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#ifndef REMOTECONTROLLABILITYINTFCONTROLLER_H_
+#define REMOTECONTROLLABILITYINTFCONTROLLER_H_
+
+#include <qcc/String.h>
+#include <alljoyn/Status.h>
+#include <alljoyn/hae/interfaces/operation/RemoteControllabilityInterface.h>
+
+namespace ajn {
+namespace services {
+
+/**
+ * RemoteControllability Interface Controller class
+ */
+class RemoteControllabilityIntfController : public RemoteControllabilityInterface {
+  public:
+    /**
+     * Constructor of RemoteControllabilityIntfController
+     */
+    RemoteControllabilityIntfController() {}
+
+    /**
+     * Destructor of RemoteControllabilityIntfController
+     */
+    virtual ~RemoteControllabilityIntfController() {}
+
+    /**
+     * Get isControllable
+     * @param[in] context the context that is passed to the callback handler
+     * @return ER_OK on success
+     */
+    virtual QStatus GetIsControllable(void* context = NULL) = 0;
+
+};
+
+} //namespace services
+} //namespace ajn
+
+#endif /* REMOTECONTROLLABILITYINTFCONTROLLER_H_ */
diff --git a/cpp/inc/alljoyn/hae/interfaces/operation/RemoteControllabilityIntfControllerListener.h b/cpp/inc/alljoyn/hae/interfaces/operation/RemoteControllabilityIntfControllerListener.h
new file mode 100644
index 0000000..e606ae4
--- /dev/null
+++ b/cpp/inc/alljoyn/hae/interfaces/operation/RemoteControllabilityIntfControllerListener.h
@@ -0,0 +1,55 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#ifndef REMOTECONTROLLABILITYINTFCONTROLLERLISTENER_H_
+#define REMOTECONTROLLABILITYINTFCONTROLLERLISTENER_H_
+
+#include <qcc/String.h>
+#include <alljoyn/Status.h>
+#include <alljoyn/hae/interfaces/InterfaceControllerListener.h>
+
+namespace ajn {
+namespace services {
+
+/**
+ * RemoteControllability Interface Controller Listener class
+ */
+class RemoteControllabilityIntfControllerListener : public InterfaceControllerListener {
+  public:
+    virtual ~RemoteControllabilityIntfControllerListener() {}
+
+    /**
+     * Callback handler for getting IsControllableproperty
+     * @param[in] status ER_OK on success
+     * @param[in] objectPath the object path
+     * @param[in] isControllable isControllable
+     * @param[in] context the context that is passed from application
+     */
+    virtual void GetIsControllablePropertyCallback(QStatus status, const qcc::String& objectPath, const bool isControllable, void* context) {}
+
+    /**
+     * Handler for IsControllable property changed
+     * @param[in] objectPath the object path
+     * @param[in] isControllable isControllable
+     */
+    virtual void IsControllalbePropertyChanged(const qcc::String& objectPath, const bool isControllable) {}
+
+};
+
+} //namespace services
+} //namespace ajn
+
+#endif /* REMOTECONTROLLABILITYINTFCONTROLLERLISTENER_H_ */
diff --git a/cpp/inc/alljoyn/hae/interfaces/operation/SoilLevelInterface.h b/cpp/inc/alljoyn/hae/interfaces/operation/SoilLevelInterface.h
new file mode 100644
index 0000000..cb723ee
--- /dev/null
+++ b/cpp/inc/alljoyn/hae/interfaces/operation/SoilLevelInterface.h
@@ -0,0 +1,78 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#ifndef SOILLEVELINTERFACE_H_
+#define SOILLEVELINTERFACE_H_
+
+#include <qcc/String.h>
+#include <alljoyn/Status.h>
+#include <alljoyn/hae/interfaces/HaeInterface.h>
+
+namespace ajn {
+namespace services {
+
+/**
+ * SoilLevel Interface class
+ */
+class SoilLevelInterface : public HaeInterface {
+  public:
+    /**
+     * Constructor of SoilLevel
+     */
+    SoilLevelInterface() {}
+
+    /**
+     * Destructor of SoilLevel
+     */
+    virtual ~SoilLevelInterface() {}
+
+    /**
+     * Get Interface Type
+     * @return interface type
+     */
+    const HaeInterfaceType GetInterfaceType() const { return SOIL_LEVEL_INTERFACE; }
+
+    /**
+     * Get Introspection Xml
+     * @return xml
+     */
+    virtual const qcc::String& GetIntrospectionXml() { return s_xml; }
+
+    /**
+     * Get Interface version
+     * @return interface version
+     */
+    virtual const uint16_t GetInterfaceVersion() const { return s_interfaceVersion; }
+
+  protected:
+    static const qcc::String s_prop_Version;
+    static const qcc::String s_prop_MaxLevel;
+    static const qcc::String s_prop_TargetLevel;
+    static const qcc::String s_prop_SelectableLevels;
+    /**
+     * TODO: add property, method and signal name variable
+     */
+
+
+  private:
+    static const qcc::String s_xml;
+    static const uint16_t s_interfaceVersion;
+};
+
+} //namespace services
+} //namespace ajn
+
+#endif /* SOILLEVELINTERFACE_H_ */
diff --git a/cpp/inc/alljoyn/hae/interfaces/operation/SoilLevelIntfControllee.h b/cpp/inc/alljoyn/hae/interfaces/operation/SoilLevelIntfControllee.h
new file mode 100644
index 0000000..0e93613
--- /dev/null
+++ b/cpp/inc/alljoyn/hae/interfaces/operation/SoilLevelIntfControllee.h
@@ -0,0 +1,86 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#ifndef SOILLEVELINTFCONTROLLEE_H_
+#define SOILLEVELINTFCONTROLLEE_H_
+
+#include <qcc/String.h>
+#include <alljoyn/Status.h>
+#include <alljoyn/hae/interfaces/operation/SoilLevelInterface.h>
+#include <vector>
+
+namespace ajn {
+namespace services {
+
+/**
+ * SoilLevel Interface Controllee class
+ */
+class SoilLevelIntfControllee : public SoilLevelInterface {
+  public:
+    /**
+     * Constructor of SoilLevelIntfControllee
+     */
+    SoilLevelIntfControllee() {}
+
+    /**
+     * Destructor of SoilLevelIntfControllee
+     */
+    virtual ~SoilLevelIntfControllee() {}
+
+    /**
+     * Get MaxLevel
+     * @return MaxLevel
+     */
+    virtual const uint8_t GetMaxLevel() const = 0;
+
+    /**
+     * Set MaxLevel
+     * @param[in] maxLevel maxLevel
+     * @return ER_OK on success
+     */
+    virtual QStatus SetMaxLevel(uint8_t maxLevel) = 0;
+
+    /**
+     * Get TargetLevel
+     * @return TargetLevel
+     */
+    virtual const uint8_t GetTargetLevel () const = 0;
+
+    /**
+     * Set TargetLevel
+     * @param[in] targetLevel targetLevel
+     * @return ER_OK on success
+     */
+    virtual QStatus SetTargetLevel(uint8_t targetLevel) = 0;
+
+    /**
+     * Get SelectableLevels
+     * @return The list of selectable levels
+     */
+    virtual const std::vector<uint8_t>& GetSelectableLevels() const = 0;
+
+    /**
+     * Set SelectableLevels
+     * @param[in] selectableLevels the list of levels
+     * @return ER_OK on success
+     */
+    virtual QStatus SetSelectableLevels(const std::vector<uint8_t>& selectableLevels) = 0;
+};
+
+} //namespace services
+} //namespace ajn
+
+#endif /* SOILLEVELINTFCONTROLLEE_H_ */
diff --git a/cpp/inc/alljoyn/hae/interfaces/operation/SoilLevelIntfControlleeListener.h b/cpp/inc/alljoyn/hae/interfaces/operation/SoilLevelIntfControlleeListener.h
new file mode 100644
index 0000000..625856d
--- /dev/null
+++ b/cpp/inc/alljoyn/hae/interfaces/operation/SoilLevelIntfControlleeListener.h
@@ -0,0 +1,88 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#ifndef SOILLEVELINTFCONTROLLEELISTENER_H_
+#define SOILLEVELINTFCONTROLLEELISTENER_H_
+
+#include <qcc/String.h>
+#include <alljoyn/Status.h>
+#include <vector>
+#include <alljoyn/hae/interfaces/HaeInterfaceErrors.h>
+#include <alljoyn/hae/interfaces/InterfaceControlleeListener.h>
+
+namespace ajn {
+namespace services {
+
+/**
+ * SoilLevel Interface Controllee Listener class
+ */
+class SoilLevelIntfControlleeListener : public InterfaceControlleeListener {
+  public:
+    /**
+     * Destructor of SoilLevelIntfControlleeListener
+     */
+    virtual ~SoilLevelIntfControlleeListener() {}
+
+    /**
+     * Handler for getting MaxLevel
+     * This function is only called, when InterfaceControllee::s_retrievingActualPropertyValue is true.
+     * @param[out] maxLevel maxLevel
+     * @return ER_OK on success
+     */
+    virtual QStatus OnGetMaxLevel(uint8_t& maxLevel) = 0;
+
+    /**
+     * Handler for setting MaxLevel
+     * @param[in] maxLevel maxLevel
+     * @return ER_OK on success
+     */
+    virtual QStatus OnSetMaxLevel(const uint8_t& maxLevel) = 0;
+
+    /**
+     * Handler for getting TargetLevel
+     * This function is only called, when InterfaceControllee::s_retrievingActualPropertyValue is true.
+     * @param[out] targetLevel targetLevel
+     * @return ER_OK on success
+     */
+    virtual QStatus OnGetTargetLevel(uint8_t& targetLevel) = 0;
+
+    /**
+     * Handler for setting TargetLevel
+     * @param[in] targetLevel targetLevel
+     * @return ER_OK on success
+     */
+    virtual QStatus OnSetTargetLevel(const uint8_t& targetLevel) = 0;
+
+    /**
+     * Handler for getting SelectableLevels
+     * This function is only called, when InterfaceControllee::s_retrievingActualPropertyValue is true.
+     * @param[out] selectableLevels the list of selectable levels
+     * @return ER_OK on success
+     */
+    virtual QStatus OnGetSelectableLevels(std::vector<uint8_t>& selectableLevels) = 0;
+
+    /**
+     * Handler for setting SelectableLevels
+     * @param[in] selectableLevels the list of selectable levels
+     * @return ER_OK on success
+     */
+    virtual QStatus OnSetSelectableLevels(const std::vector<uint8_t>& selectableLevels) = 0;
+};
+
+} //namespace services
+} //namespace ajn
+
+#endif /* SOILLEVELINTFCONTROLLEELISTENER_H_ */
diff --git a/cpp/inc/alljoyn/hae/interfaces/operation/SoilLevelIntfController.h b/cpp/inc/alljoyn/hae/interfaces/operation/SoilLevelIntfController.h
new file mode 100644
index 0000000..a5a9074
--- /dev/null
+++ b/cpp/inc/alljoyn/hae/interfaces/operation/SoilLevelIntfController.h
@@ -0,0 +1,75 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#ifndef SOILLEVELINTFCONTROLLER_H_
+#define SOILLEVELINTFCONTROLLER_H_
+
+#include <qcc/String.h>
+#include <alljoyn/Status.h>
+#include <alljoyn/hae/interfaces/operation/SoilLevelInterface.h>
+
+namespace ajn {
+namespace services {
+
+/**
+ * SoilLevel Interface Controller class
+ */
+class SoilLevelIntfController : public SoilLevelInterface {
+  public:
+    /**
+     * Constructor of SoilLevelIntfController
+     */
+    SoilLevelIntfController() {}
+
+    /**
+     * Destructor of SoilLevelIntfController
+     */
+    virtual ~SoilLevelIntfController() {}
+
+    /**
+     * Get MaxLevel
+     * @param[in] context the context that is passed to the callback handler
+     * @return ER_OK on success
+     */
+    virtual QStatus GetMaxLevel(void* context = NULL) = 0;
+
+    /**
+     * Get TargetLevel
+     * @param[in] context the context that is passed to the callback handler
+     * @return ER_OK on success
+     */
+    virtual QStatus GetTargetLevel(void* context = NULL) = 0;
+
+    /**
+     * Set TargetLevel
+     * @param[in] targetLevel targetLevel
+     * @param[in] context the context that is passed to the callback handler
+     * @return ER_OK on success
+     */
+    virtual QStatus SetTargetLevel(const uint8_t targetLevel, void* context = NULL) = 0;
+
+    /**
+     * Get SelectableLevels
+     * @param[in] context the context that is passed to the callback handler
+     * @return ER_OK on success
+     */
+    virtual QStatus GetSelectableLevels(void* context = NULL) = 0;
+};
+
+} //namespace services
+} //namespace ajn
+
+#endif /* SOILLEVELINTFCONTROLLER_H_ */
diff --git a/cpp/inc/alljoyn/hae/interfaces/operation/SoilLevelIntfControllerListener.h b/cpp/inc/alljoyn/hae/interfaces/operation/SoilLevelIntfControllerListener.h
new file mode 100644
index 0000000..07577cc
--- /dev/null
+++ b/cpp/inc/alljoyn/hae/interfaces/operation/SoilLevelIntfControllerListener.h
@@ -0,0 +1,96 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#ifndef SOILLEVELINTFCONTROLLERLISTENER_H_
+#define SOILLEVELINTFCONTROLLERLISTENER_H_
+
+#include <qcc/String.h>
+#include <alljoyn/Status.h>
+#include <vector>
+#include <alljoyn/hae/interfaces/InterfaceControllerListener.h>
+
+namespace ajn {
+namespace services {
+
+/**
+ * SoilLevel Interface Controller Listener class
+ */
+class SoilLevelIntfControllerListener : public InterfaceControllerListener {
+  public:
+    virtual ~SoilLevelIntfControllerListener() {}
+
+    /**
+     * Callback handler for getting MaxLevel
+     * @param[in] status ER_OK on success
+     * @param[in] objectPath the object path
+     * @param[in] maxLevel maxLevel
+     * @param[in] context the context that is passed from application
+     */
+    virtual void GetMaxLevelPropertyCallback(QStatus status, const qcc::String& objectPath, const uint8_t maxLevel, void* context) {};
+
+    /**
+     * Callback handler for getting TargetLevel
+     * @param[in] status ER_OK on success
+     * @param[in] objectPath the object path
+     * @param[in] targetLevel targetLevel
+     * @param[in] context the context that is passed from application
+     */
+    virtual void GetTargetLevelPropertyCallback(QStatus status, const qcc::String& objectPath, const uint8_t targetLevel, void* context) {};
+
+    /**
+     * Callback handler for setting TargetLevel
+     * @param[in] status ER_OK on success
+     * @param[in] objectPath the object path
+     * @param[in] targetLevel targetLevel
+     * @param[in] context the context that is passed from application
+     */
+    virtual void SetTargetLevelPropertyCallback(QStatus status, const qcc::String& objectPath, void* context) {};
+
+    /**
+     * Callback handler for getting SelectableLevels
+     * @param[in] status ER_OK on success
+     * @param[in] objectPath the object path
+     * @param[in] selectableLevels selectableLevels
+     * @param[in] context the context that is passed from application
+     */
+    virtual void GetSelectableLevelsPropertyCallback(QStatus status, const qcc::String& objectPath, const std::vector<uint8_t> selectableLevels, void* context) {};
+
+    /**
+     * Handler for MaxLevel property changed
+     * @param[in] objectPath the object path
+     * @param[in] maxLevel maxLevel
+     */
+    virtual void MaxLevelPropertyChanged(const qcc::String& objectPath, const uint8_t maxLevel) {};
+
+    /**
+     * Handler for TargetLevel property changed
+     * @param[in] objectPath the object path
+     * @param[in] targetLevel targetLevel
+     */
+    virtual void TargetLevelPropertyChanged(const qcc::String& objectPath, const uint8_t targetLevel) {};
+
+    /**
+     * Handler for SelectableLevels property changed
+     * @param[in] objectPath the object path
+     * @param[in] selectableLevels selectableLevels
+     */
+    virtual void SelectableLevelsPropertyChanged(const qcc::String& objectPath, const std::vector<uint8_t>& selectableLevels) {};
+};
+
+} //namespace services
+} //namespace ajn
+
+#endif /* SOILLEVELINTFCONTROLLERLISTENER_H_ */
diff --git a/cpp/inc/alljoyn/hae/interfaces/operation/SpinSpeedLevelInterface.h b/cpp/inc/alljoyn/hae/interfaces/operation/SpinSpeedLevelInterface.h
new file mode 100644
index 0000000..0037b8a
--- /dev/null
+++ b/cpp/inc/alljoyn/hae/interfaces/operation/SpinSpeedLevelInterface.h
@@ -0,0 +1,75 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#ifndef SPINSPEEDLEVELINTERFACE_H_
+#define SPINSPEEDLEVELINTERFACE_H_
+
+#include <qcc/String.h>
+#include <alljoyn/Status.h>
+#include <alljoyn/hae/interfaces/HaeInterface.h>
+
+namespace ajn {
+namespace services {
+
+/**
+ * SpinSpeedLevel Interface class
+ */
+class SpinSpeedLevelInterface : public HaeInterface {
+  public:
+    /**
+     * Constructor of SpinSpeedLevel
+     */
+    SpinSpeedLevelInterface() {}
+
+    /**
+     * Destructor of SpinSpeedLevel
+     */
+    virtual ~SpinSpeedLevelInterface() {}
+
+    /**
+     * Get Interface Type
+     * @return interface type
+     */
+    const HaeInterfaceType GetInterfaceType() const { return SPIN_SPEED_LEVEL_INTERFACE; }
+
+    /**
+     * Get Introspection Xml
+     * @return xml
+     */
+    virtual const qcc::String& GetIntrospectionXml() { return s_xml; }
+
+    /**
+     * Get Interface version
+     * @return interface version
+     */
+    virtual const uint16_t GetInterfaceVersion() const { return s_interfaceVersion; }
+
+  protected:
+    static const qcc::String s_prop_Version;
+    static const qcc::String s_prop_MaxLevel;
+    static const qcc::String s_prop_TargetLevel;
+    static const qcc::String s_prop_SelectableLevels;
+
+
+  private:
+    static const qcc::String s_xml;
+    static const uint16_t s_interfaceVersion;
+};
+
+} //namespace services
+} //namespace ajn
+
+#endif /* SPINSPEEDLEVELINTERFACE_H_ */
diff --git a/cpp/inc/alljoyn/hae/interfaces/operation/SpinSpeedLevelIntfControllee.h b/cpp/inc/alljoyn/hae/interfaces/operation/SpinSpeedLevelIntfControllee.h
new file mode 100644
index 0000000..c51e04a
--- /dev/null
+++ b/cpp/inc/alljoyn/hae/interfaces/operation/SpinSpeedLevelIntfControllee.h
@@ -0,0 +1,86 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#ifndef SPINSPEEDLEVELINTFCONTROLLEE_H_
+#define SPINSPEEDLEVELINTFCONTROLLEE_H_
+
+#include <qcc/String.h>
+#include <alljoyn/Status.h>
+#include <vector>
+#include <alljoyn/hae/interfaces/operation/SpinSpeedLevelInterface.h>
+
+namespace ajn {
+namespace services {
+
+/**
+ * SpinSpeedLevel Interface Controllee class
+ */
+class SpinSpeedLevelIntfControllee : public SpinSpeedLevelInterface {
+  public:
+    /**
+     * Constructor of SpinSpeedLevelIntfControllee
+     */
+    SpinSpeedLevelIntfControllee() {}
+
+    /**
+     * Destructor of SpinSpeedLevelIntfControllee
+     */
+    virtual ~SpinSpeedLevelIntfControllee() {}
+
+    /**
+     * Get MaxLevel
+     * @return MaxLevel
+     */
+    virtual const uint8_t GetMaxLevel() const = 0;
+
+    /**
+     * Set MaxLevel
+     * @param[in] maxLevel maxLevel
+     * @return ER_OK on success
+     */
+    virtual QStatus SetMaxLevel(uint8_t maxLevel) = 0;
+
+    /**
+     * Get TargetLevel
+     * @return TargetLevel
+     */
+    virtual const uint8_t GetTargetLevel () const = 0;
+
+    /**
+     * Set TargetLevel
+     * @param[in] targetLevel targetLevel
+     * @return ER_OK on success
+     */
+    virtual QStatus SetTargetLevel(uint8_t targetLevel) = 0;
+
+    /**
+     * Get SelectableLevels
+     * @return The list of selectable levels
+     */
+    virtual const std::vector<uint8_t>& GetSelectableLevels() const = 0;
+
+    /**
+     * Set SelectableLevels
+     * @param[in] selectableLevels the list of levels
+     * @return ER_OK on success
+     */
+    virtual QStatus SetSelectableLevels(const std::vector<uint8_t>& selectableLevels) = 0;
+};
+
+} //namespace services
+} //namespace ajn
+
+#endif /* SPINSPEEDLEVELINTFCONTROLLEE_H_ */
diff --git a/cpp/inc/alljoyn/hae/interfaces/operation/SpinSpeedLevelIntfControlleeListener.h b/cpp/inc/alljoyn/hae/interfaces/operation/SpinSpeedLevelIntfControlleeListener.h
new file mode 100644
index 0000000..04c7abd
--- /dev/null
+++ b/cpp/inc/alljoyn/hae/interfaces/operation/SpinSpeedLevelIntfControlleeListener.h
@@ -0,0 +1,88 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#ifndef SPINSPEEDLEVELINTFCONTROLLEELISTENER_H_
+#define SPINSPEEDLEVELINTFCONTROLLEELISTENER_H_
+
+#include <qcc/String.h>
+#include <alljoyn/Status.h>
+#include <vector>
+#include <alljoyn/hae/interfaces/HaeInterfaceErrors.h>
+#include <alljoyn/hae/interfaces/InterfaceControlleeListener.h>
+
+namespace ajn {
+namespace services {
+
+/**
+ * SpinSpeedLevel Interface Controllee Listener class
+ */
+class SpinSpeedLevelIntfControlleeListener : public InterfaceControlleeListener {
+  public:
+    /**
+     * Destructor of SpinSpeedLevelIntfControlleeListener
+     */
+    virtual ~SpinSpeedLevelIntfControlleeListener() {}
+
+    /**
+     * Handler for getting MaxLevel
+     * This function is only called, when InterfaceControllee::s_retrievingActualPropertyValue is true.
+     * @param[out] maxLevel maxLevel
+     * @return ER_OK on success
+     */
+    virtual QStatus OnGetMaxLevel(uint8_t& maxLevel) = 0;
+
+    /**
+     * Handler for setting MaxLevel
+     * @param[in] maxLevel maxLevel
+     * @return ER_OK on success
+     */
+    virtual QStatus OnSetMaxLevel(const uint8_t& maxLevel) = 0;
+
+    /**
+     * Handler for getting TargetLevel
+     * This function is only called, when InterfaceControllee::s_retrievingActualPropertyValue is true.
+     * @param[out] targetLevel targetLevel
+     * @return ER_OK on success
+     */
+    virtual QStatus OnGetTargetLevel(uint8_t& targetLevel) = 0;
+
+    /**
+     * Handler for setting TargetLevel
+     * @param[in] targetLevel targetLevel
+     * @return ER_OK on success
+     */
+    virtual QStatus OnSetTargetLevel(const uint8_t& targetLevel) = 0;
+
+    /**
+     * Handler for getting SelectableLevels
+     * This function is only called, when InterfaceControllee::s_retrievingActualPropertyValue is true.
+     * @param[out] selectableLevels the list of selectable levels
+     * @return ER_OK on success
+     */
+    virtual QStatus OnGetSelectableLevels(std::vector<uint8_t>& selectableLevels) = 0;
+
+    /**
+     * Handler for setting SelectableLevels
+     * @param[in] selectableLevels the list of selectable levels
+     * @return ER_OK on success
+     */
+    virtual QStatus OnSetSelectableLevels(const std::vector<uint8_t>& selectableLevels) = 0;
+};
+
+} //namespace services
+} //namespace ajn
+
+#endif /* SPINSPEEDLEVELINTFCONTROLLEELISTENER_H_ */
diff --git a/cpp/inc/alljoyn/hae/interfaces/operation/SpinSpeedLevelIntfController.h b/cpp/inc/alljoyn/hae/interfaces/operation/SpinSpeedLevelIntfController.h
new file mode 100644
index 0000000..345fefe
--- /dev/null
+++ b/cpp/inc/alljoyn/hae/interfaces/operation/SpinSpeedLevelIntfController.h
@@ -0,0 +1,75 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#ifndef SPINSPEEDLEVELINTFCONTROLLER_H_
+#define SPINSPEEDLEVELINTFCONTROLLER_H_
+
+#include <qcc/String.h>
+#include <alljoyn/Status.h>
+#include <alljoyn/hae/interfaces/operation/SpinSpeedLevelInterface.h>
+
+namespace ajn {
+namespace services {
+
+/**
+ * SpinSpeedLevel Interface Controller class
+ */
+class SpinSpeedLevelIntfController : public SpinSpeedLevelInterface {
+  public:
+    /**
+     * Constructor of SpinSpeedLevelIntfController
+     */
+    SpinSpeedLevelIntfController() {}
+
+    /**
+     * Destructor of SpinSpeedLevelIntfController
+     */
+    virtual ~SpinSpeedLevelIntfController() {}
+
+    /**
+     * Get MaxLevel
+     * @param[in] context the context that is passed to the callback handler
+     * @return ER_OK on success
+     */
+    virtual QStatus GetMaxLevel(void* context = NULL) = 0;
+
+    /**
+     * Get TargetLevel
+     * @param[in] context the context that is passed to the callback handler
+     * @return ER_OK on success
+     */
+    virtual QStatus GetTargetLevel(void* context = NULL) = 0;
+
+    /**
+     * Set TargetLevel
+     * @param[in] targetLevel targetLevel
+     * @param[in] context the context that is passed to the callback handler
+     * @return ER_OK on success
+     */
+    virtual QStatus SetTargetLevel(const uint8_t targetLevel, void* context = NULL) = 0;
+
+    /**
+     * Get SelectableLevels
+     * @param[in] context the context that is passed to the callback handler
+     * @return ER_OK on success
+     */
+    virtual QStatus GetSelectableLevels(void* context = NULL) = 0;
+};
+
+} //namespace services
+} //namespace ajn
+
+#endif /* SPINSPEEDLEVELINTFCONTROLLER_H_ */
diff --git a/cpp/inc/alljoyn/hae/interfaces/operation/SpinSpeedLevelIntfControllerListener.h b/cpp/inc/alljoyn/hae/interfaces/operation/SpinSpeedLevelIntfControllerListener.h
new file mode 100644
index 0000000..b028971
--- /dev/null
+++ b/cpp/inc/alljoyn/hae/interfaces/operation/SpinSpeedLevelIntfControllerListener.h
@@ -0,0 +1,96 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#ifndef SPINSPEEDLEVELINTFCONTROLLERLISTENER_H_
+#define SPINSPEEDLEVELINTFCONTROLLERLISTENER_H_
+
+#include <qcc/String.h>
+#include <alljoyn/Status.h>
+#include <vector>
+#include <alljoyn/hae/interfaces/InterfaceControllerListener.h>
+
+namespace ajn {
+namespace services {
+
+/**
+ * SpinSpeedLevel Interface Controller Listener class
+ */
+class SpinSpeedLevelIntfControllerListener : public InterfaceControllerListener {
+  public:
+    virtual ~SpinSpeedLevelIntfControllerListener() {}
+
+    /**
+     * Callback handler for getting MaxLevel
+     * @param[in] status ER_OK on success
+     * @param[in] objectPath the object path
+     * @param[in] maxLevel maxLevel
+     * @param[in] context the context that is passed from application
+     */
+    virtual void GetMaxLevelPropertyCallback(QStatus status, const qcc::String& objectPath, const uint8_t maxLevel, void* context) {};
+
+    /**
+     * Callback handler for getting TargetLevel
+     * @param[in] status ER_OK on success
+     * @param[in] objectPath the object path
+     * @param[in] targetLevel targetLevel
+     * @param[in] context the context that is passed from application
+     */
+    virtual void GetTargetLevelPropertyCallback(QStatus status, const qcc::String& objectPath, const uint8_t targetLevel, void* context) {};
+
+    /**
+     * Callback handler for setting TargetLevel
+     * @param[in] status ER_OK on success
+     * @param[in] objectPath the object path
+     * @param[in] targetLevel targetLevel
+     * @param[in] context the context that is passed from application
+     */
+    virtual void SetTargetLevelPropertyCallback(QStatus status, const qcc::String& objectPath, void* context) {};
+
+    /**
+     * Callback handler for getting SelectableLevels
+     * @param[in] status ER_OK on success
+     * @param[in] objectPath the object path
+     * @param[in] selectableLevels selectableLevels
+     * @param[in] context the context that is passed from application
+     */
+    virtual void GetSelectableLevelsPropertyCallback(QStatus status, const qcc::String& objectPath, const std::vector<uint8_t>& selectableLevels, void* context) {};
+
+    /**
+     * Handler for MaxLevel property changed
+     * @param[in] objectPath the object path
+     * @param[in] maxLevel maxLevel
+     */
+    virtual void MaxLevelPropertyChanged(const qcc::String& objectPath, const uint8_t maxLevel) {};
+
+    /**
+     * Handler for TargetLevel property changed
+     * @param[in] objectPath the object path
+     * @param[in] targetLevel targetLevel
+     */
+    virtual void TargetLevelPropertyChanged(const qcc::String& objectPath, const uint8_t targetLevel) {};
+
+    /**
+     * Handler for SelectableLevels property changed
+     * @param[in] objectPath the object path
+     * @param[in] selectableLevels selectableLevels
+     */
+    virtual void SelectableLevelsPropertyChanged(const qcc::String& objectPath, const std::vector<uint8_t>& selectableLevels) {};
+};
+
+} //namespace services
+} //namespace ajn
+
+#endif /* SPINSPEEDLEVELINTFCONTROLLERLISTENER_H_ */
diff --git a/cpp/inc/alljoyn/hae/interfaces/operation/TimerInterface.h b/cpp/inc/alljoyn/hae/interfaces/operation/TimerInterface.h
new file mode 100644
index 0000000..cd10896
--- /dev/null
+++ b/cpp/inc/alljoyn/hae/interfaces/operation/TimerInterface.h
@@ -0,0 +1,81 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#ifndef TIMERINTERFACE_H_
+#define TIMERINTERFACE_H_
+
+#include <qcc/String.h>
+#include <alljoyn/Status.h>
+#include <alljoyn/hae/interfaces/HaeInterface.h>
+
+namespace ajn {
+namespace services {
+
+/**
+ * Timer Interface class
+ */
+class TimerInterface : public HaeInterface {
+  public:
+    /**
+     * Constructor of Timer
+     */
+    TimerInterface() {}
+
+    /**
+     * Destructor of Timer
+     */
+    virtual ~TimerInterface() {}
+
+    /**
+     * Get Interface Type
+     * @return interface type
+     */
+    const HaeInterfaceType GetInterfaceType() const { return TIMER_INTERFACE; }
+
+    /**
+     * Get Introspection Xml
+     * @return xml
+     */
+    virtual const qcc::String& GetIntrospectionXml() { return s_xml; }
+
+    /**
+     * Get Interface version
+     * @return interface version
+     */
+    virtual const uint16_t GetInterfaceVersion() const { return s_interfaceVersion; }
+
+  protected:
+    static const qcc::String s_prop_Version;
+    static const qcc::String s_prop_ReferenceTimer;
+    static const qcc::String s_prop_TargetTimeToStart;
+    static const qcc::String s_prop_TargetTimeToStop;
+    static const qcc::String s_prop_EstimatedTimeToEnd;
+    static const qcc::String s_prop_RunningTime;
+    static const qcc::String s_prop_TargetDuration;
+
+    static const qcc::String s_method_SetTargetTimeToStart;
+    static const qcc::String s_method_SetTargetTimeToStop;
+
+
+  private:
+    static const qcc::String s_xml;
+    static const uint16_t s_interfaceVersion;
+};
+
+} //namespace services
+} //namespace ajn
+
+#endif /* TIMERINTERFACE_H_ */
diff --git a/cpp/inc/alljoyn/hae/interfaces/operation/TimerIntfControllee.h b/cpp/inc/alljoyn/hae/interfaces/operation/TimerIntfControllee.h
new file mode 100644
index 0000000..fcb912d
--- /dev/null
+++ b/cpp/inc/alljoyn/hae/interfaces/operation/TimerIntfControllee.h
@@ -0,0 +1,110 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#ifndef TIMERINTFCONTROLLEE_H_
+#define TIMERINTFCONTROLLEE_H_
+
+#include <qcc/String.h>
+#include <alljoyn/Status.h>
+#include <alljoyn/hae/interfaces/operation/TimerInterface.h>
+
+namespace ajn {
+namespace services {
+
+/**
+ * Timer Interface Controllee class
+ */
+class TimerIntfControllee : public TimerInterface {
+  public:
+    /**
+     * Constructor of TimerIntfControllee
+     */
+    TimerIntfControllee() {}
+
+    /**
+     * Destructor of TimerIntfControllee
+     */
+    virtual ~TimerIntfControllee() {}
+
+    /**
+     * Get ReferenceTimer
+     * @return The current reference timer value
+     */
+    virtual const int32_t GetReferenceTimer() const = 0;
+
+    /**
+     * Set ReferenceTimer
+     * @param[in] time reference timer value
+     * @return ER_OK on success
+     */
+    virtual QStatus SetReferenceTimer(const int32_t time) = 0;
+
+    /**
+     * Get TargetTimeToStart
+     * @return Time to the start
+     */
+    virtual const int32_t GetTargetTimeToStart() const = 0;
+
+    /**
+     * Get TargetTimeToStop
+     * @return Time to the stop
+     */
+    virtual const int32_t GetTargetTimeToStop() const = 0;
+
+    /**
+     * Get EstimatedTimeToEnd
+     * @return estimated time to the end
+     */
+    virtual const int32_t GetEstimatedTimeToEnd() const = 0;
+
+    /**
+     * Set EstimatedTimeToEnd
+     * @param[in] time estimated time to the end
+     * @return ER_OK on success
+     */
+    virtual QStatus SetEstimatedTimeToEnd(const int32_t time) = 0;
+
+    /**
+     * Get RunningTime
+     * @return running time
+     */
+    virtual const int32_t GetRunningTime() const = 0;
+
+    /**
+     * Set RunningTime
+     * @param[in] time running time
+     * @return ER_OK on success
+     */
+    virtual QStatus SetRunningTime(const int32_t time) = 0;
+
+    /**
+     * Get TargetDuration
+     * @return target duration
+     */
+    virtual const int32_t GetTargetDuration() const = 0;
+
+    /**
+     * Set TargetDuration
+     * @param[in] time target duration
+     * @return ER_OK on success
+     */
+    virtual QStatus SetTargetDuration(const int32_t time) = 0;
+};
+
+} //namespace services
+} //namespace ajn
+
+#endif /* TIMERINTFCONTROLLEE_H_ */
diff --git a/cpp/inc/alljoyn/hae/interfaces/operation/TimerIntfControlleeListener.h b/cpp/inc/alljoyn/hae/interfaces/operation/TimerIntfControlleeListener.h
new file mode 100644
index 0000000..e21de01
--- /dev/null
+++ b/cpp/inc/alljoyn/hae/interfaces/operation/TimerIntfControlleeListener.h
@@ -0,0 +1,105 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#ifndef TIMERINTFCONTROLLEELISTENER_H_
+#define TIMERINTFCONTROLLEELISTENER_H_
+
+#include <qcc/String.h>
+#include <alljoyn/Status.h>
+#include <alljoyn/hae/interfaces/HaeInterfaceErrors.h>
+#include <alljoyn/hae/interfaces/InterfaceControlleeListener.h>
+
+namespace ajn {
+namespace services {
+
+/**
+ * Timer Interface Controllee Listener class
+ */
+class TimerIntfControlleeListener : public InterfaceControlleeListener {
+  public:
+    /**
+     * Destructor of TimerIntfControlleeListener
+     */
+    virtual ~TimerIntfControlleeListener() {}
+
+    /**
+     * Handler for getting ReferenceTimer
+     * This function is only called, when InterfaceControllee::s_retrievingActualPropertyValue is true.
+     * @param[out] time reference timer value
+     * @return ER_OK on success
+     */
+    virtual QStatus GetReferenceTimer(int32_t& time) = 0;
+
+    /**
+     * Handler for getting TargetTimeToStart
+     * This function is only called, when InterfaceControllee::s_retrievingActualPropertyValue is true.
+     * @param[out] time target time start
+     * @return ER_OK on success
+     */
+    virtual QStatus GetTargetTimeToStart(int32_t& time) = 0;
+
+    /**
+     * Handler for getting TargetTimeToStop
+     * This function is only called, when InterfaceControllee::s_retrievingActualPropertyValue is true.
+     * @param[out] time target time stop
+     * @return ER_OK on success
+     */
+    virtual QStatus GetTargetTimeToStop(int32_t& time) = 0;
+
+    /**
+     * Handler for getting EstimatedTimeToEnd
+     * This function is only called, when InterfaceControllee::s_retrievingActualPropertyValue is true.
+     * @param[out] time estimated time to end
+     * @return ER_OK on success
+     */
+    virtual QStatus GetEstimatedTimeToEnd(int32_t& time) = 0;
+
+    /**
+     * Handler for getting RunningTime
+     * This function is only called, when InterfaceControllee::s_retrievingActualPropertyValue is true.
+     * @param[out] time running time
+     * @return ER_OK on success
+     */
+    virtual QStatus GetRunningTime(int32_t& time) = 0;
+
+    /**
+     * Handler for getting TargetDuration
+     * This function is only called, when InterfaceControllee::s_retrievingActualPropertyValue is true.
+     * @param[out] time target duration
+     * @return ER_OK on success
+     */
+    virtual QStatus GetTargetDuration(int32_t& time) = 0;
+
+    /**
+     * Handler for setting TargetTimeToStart
+     * @param[in] time target time to start
+     * @return ER_OK on success
+     */
+    virtual QStatus OnSetTargetTimeToStart(int32_t time, ErrorCode& errorCode) = 0;
+
+    /**
+     * Handler for setting TargetTimeToStop
+     * @param[in] time target time to stop
+     * @return ER_OK on success
+     */
+    virtual QStatus OnSetTargetTimeToStop(int32_t time, ErrorCode& errorCode) = 0;
+
+};
+
+} //namespace services
+} //namespace ajn
+
+#endif /* TIMERINTFCONTROLLEELISTENER_H_ */
diff --git a/cpp/inc/alljoyn/hae/interfaces/operation/TimerIntfController.h b/cpp/inc/alljoyn/hae/interfaces/operation/TimerIntfController.h
new file mode 100644
index 0000000..f299802
--- /dev/null
+++ b/cpp/inc/alljoyn/hae/interfaces/operation/TimerIntfController.h
@@ -0,0 +1,105 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#ifndef TIMERINTFCONTROLLER_H_
+#define TIMERINTFCONTROLLER_H_
+
+#include <qcc/String.h>
+#include <alljoyn/Status.h>
+#include <alljoyn/hae/interfaces/operation/TimerInterface.h>
+
+namespace ajn {
+namespace services {
+
+/**
+ * Timer Interface Controller class
+ */
+class TimerIntfController : public TimerInterface {
+  public:
+    /**
+     * Constructor of TimerIntfController
+     */
+    TimerIntfController() {}
+
+    /**
+     * Destructor of TimerIntfController
+     */
+    virtual ~TimerIntfController() {}
+
+    /**
+     * Get ReferenceTimer
+     * @param[in] context the context that is passed to the callback handler
+     * @return ER_OK on success
+     */
+    virtual QStatus GetReferenceTimer(void* context = NULL) = 0;
+
+    /**
+     * Get TargetTimeToStart
+     * @param[in] context the context that is passed to the callback handler
+     * @return ER_OK on success
+     */
+    virtual QStatus GetTargetTimeToStart(void* context = NULL) = 0;
+
+    /**
+     * Get TargetTimeToStop
+     * @param[in] context the context that is passed to the callback handler
+     * @return ER_OK on success
+     */
+    virtual QStatus GetTargetTimeToStop(void* context = NULL) = 0;
+
+    /**
+     * Get EstimatedTimeToEnd
+     * @param[in] context the context that is passed to the callback handler
+     * @return ER_OK on success
+     */
+    virtual QStatus GetEstimatedTimeToEnd(void* context = NULL) = 0;
+
+    /**
+     * Get RunningTime
+     * @param[in] context the context that is passed to the callback handler
+     * @return ER_OK on success
+     */
+    virtual QStatus GetRunningTime(void* context = NULL) = 0;
+
+    /**
+     * Get TargetDuration
+     * @param[in] context the context that is passed to the callback handler
+     * @return ER_OK on success
+     */
+    virtual QStatus GetTargetDuration(void* context = NULL) = 0;
+
+    /**
+     * Set target time to start
+     * @param[in] time time to start
+     * @param[in] context the context that is passed to the callback handler
+     * @return ER_OK on success
+     */
+    virtual QStatus SetTargetTimeToStart(int32_t time, void* context = NULL) = 0;
+
+    /**
+     * Set target time to stop
+     * @param[in] time time to stop
+     * @param[in] context the context that is passed to the callback handler
+     * @return ER_OK on success
+     */
+    virtual QStatus SetTargetTimeToStop(int32_t time, void* context = NULL) = 0;
+
+};
+
+} //namespace services
+} //namespace ajn
+
+#endif /* TIMERINTFCONTROLLER_H_ */
diff --git a/cpp/inc/alljoyn/hae/interfaces/operation/TimerIntfControllerListener.h b/cpp/inc/alljoyn/hae/interfaces/operation/TimerIntfControllerListener.h
new file mode 100644
index 0000000..1d6efa6
--- /dev/null
+++ b/cpp/inc/alljoyn/hae/interfaces/operation/TimerIntfControllerListener.h
@@ -0,0 +1,144 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#ifndef TIMERINTFCONTROLLERLISTENER_H_
+#define TIMERINTFCONTROLLERLISTENER_H_
+
+#include <qcc/String.h>
+#include <alljoyn/Status.h>
+#include <alljoyn/hae/interfaces/InterfaceControllerListener.h>
+
+namespace ajn {
+namespace services {
+
+/**
+ * Timer Interface Controller Listener class
+ */
+class TimerIntfControllerListener : public InterfaceControllerListener
+{
+  public:
+    virtual ~TimerIntfControllerListener() {}
+
+    /**
+     * Callback handler for getting ReferenceTimer property
+     * @param[in] status ER_OK on success
+     * @param[in] objectPath the object path
+     * @param[in] time reference timer value
+     * @param[in] context the context that is passed from application
+     */
+    virtual void OnResponseGetReferenceTimer(QStatus status, const qcc::String& objectPath, int32_t& time, void* context) {}
+    /**
+     * Callback handler for getting TargetTimeToStart property
+     * @param[in] status ER_OK on success
+     * @param[in] objectPath the object path
+     * @param[in] time target time to start
+     * @param[in] context the context that is passed from application
+     */
+    virtual void OnResponseGetTargetTimeToStart(QStatus status, const qcc::String& objectPath, int32_t& time, void* context) {}
+    /**
+     * Callback handler for getting TargetTimeToStop property
+     * @param[in] status ER_OK on success
+     * @param[in] objectPath the object path
+     * @param[in] timt target time to stop
+     * @param[in] context the context that is passed from application
+     */
+    virtual void OnResponseGetTargetTimeToStop(QStatus status, const qcc::String& objectPath, int32_t& time, void* context) {}
+    /**
+     * Callback handler for getting EstimatedTimeToEnd property
+     * @param[in] status ER_OK on success
+     * @param[in] objectPath the object path
+     * @param[in] time estimated time to end
+     * @param[in] context the context that is passed from application
+     */
+    virtual void OnResponseGetEstimatedTimeToEnd(QStatus status, const qcc::String& objectPath, int32_t& time, void* context) {}
+    /**
+     * Callback handler for getting RunningTime property
+     * @param[in] status ER_OK on success
+     * @param[in] objectPath the object path
+     * @param[in] time running time
+     * @param[in] context the context that is passed from application
+     */
+    virtual void OnResponseGetRunningTime(QStatus status, const qcc::String& objectPath, int32_t& time, void* context) {}
+    /**
+     * Callback handler for getting TargetDuration property
+     * @param[in] status ER_OK on success
+     * @param[in] objectPath the object path
+     * @param[in] time target duration
+     * @param[in] context the context that is passed from application
+     */
+    virtual void OnResponseGetTargetDuration(QStatus status, const qcc::String& objectPath, int32_t& time, void* context) {}
+
+    /**
+     * Handler for ReferenceTimer property changed
+     * @param[in] objectPath the object path
+     * @param[in] time reference timer value
+     */
+    virtual void OnReferenceTimerPropertyChanged(const qcc::String& objectPath, int32_t time) {}
+    /**
+     * Handler for TargetTimeToStart property changed
+     * @param[in] objectPath the object path
+     * @param[in] time target time to start
+     */
+    virtual void OnTargetTimeToStartPropertyChanged(const qcc::String& objectPath, int32_t time) {}
+    /**
+     * Handler for TargetTimeToStop property changed
+     * @param[in] objectPath the object path
+     * @param[in] time target time to stop
+     */
+    virtual void OnTargetTimeToStopPropertyChanged(const qcc::String& objectPath, int32_t time) {}
+    /**
+     * Handler for EstimatedTimeToEnd property changed
+     * @param[in] objectPath the object path
+     * @param[in] time estimated time to end
+     */
+    virtual void OnEstimatedTimeToEndPropertyChanged(const qcc::String& objectPath, int32_t time) {}
+    /**
+     * Handler for RunningTime property changed
+     * @param[in] objectPath the object path
+     * @param[in] time running time
+     */
+    virtual void OnRunningTimePropertyChanged(const qcc::String& objectPath, int32_t time) {}
+    /**
+     * Handler for TargetDuration property changed
+     * @param[in] objectPath the object path
+     * @param[in] time target duration
+     */
+    virtual void OnTargetDurationPropertyChanged(const qcc::String& objectPath, int32_t time) {}
+
+    /**
+     * Callback handler for SetTargetTimerToStart method
+     * @param[in] status ER_OK on success
+     * @param[in] objectPath the object path
+     * @param[in] context the context that is passed from application
+     * @param[in] errorName the detail errorName is passed when the method call is failed
+     * @param[in] errorMessage the errorMessage that describes the error
+     */
+    virtual void OnResponseSetTargetTimerToStart(QStatus status, const qcc::String& objectPath, void* context, const char* errorName, const char* errorMessage) {};
+    /**
+     * Callback handler for SetTargetTimerToStop method
+     * @param[in] status ER_OK on success
+     * @param[in] objectPath the object path
+     * @param[in] context the context that is passed from application
+     * @param[in] errorName the detail errorName is passed when the method call is failed
+     * @param[in] errorMessage the errorMessage that describes the error
+     */
+    virtual void OnResponseSetTargetTimerToStop(QStatus status, const qcc::String& objectPath, void* context, const char* errorName, const char* errorMessage) {};
+};
+
+} //namespace services
+} //namespace ajn
+
+#endif /* TIMERINTFCONTROLLERLISTENER_H_ */
diff --git a/cpp/samples/BaseSample/Controllee/CycleControlListener.cc b/cpp/samples/BaseSample/Controllee/CycleControlListener.cc
new file mode 100644
index 0000000..a9a9d8b
--- /dev/null
+++ b/cpp/samples/BaseSample/Controllee/CycleControlListener.cc
@@ -0,0 +1,35 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#include <iostream>
+#include "CycleControlListener.h"
+
+using namespace std;
+
+QStatus CycleControlListener::OnGetOperationalState(CycleControlInterface::CycleControlOperationalState& state)
+{
+    cout << "CycleControlListener::OnGetOperationalState()" << endl;
+    return ER_OK;
+}
+
+QStatus CycleControlListener::OnExecuteCommand(CycleControlInterface::CycleControlOperationalCommand command, CycleControlInterface::CycleControlOperationalState& newState, ErrorCode& error)
+{
+    QStatus status = ER_OK;
+    cout << "CycleControlListener::OnExecuteCommand. Command: " << (int)command << ". Command name: " << CycleControlInterface::OPERATIONAL_COMMAND_STRINGS[command] <<endl;
+    error = NOT_ERROR;
+    newState = CycleControlInterface::CycleControlOperationalState::OPERATIONAL_STATE_END_OF_CYCLE;
+    return status;
+}
diff --git a/cpp/samples/BaseSample/Controllee/CycleControlListener.h b/cpp/samples/BaseSample/Controllee/CycleControlListener.h
new file mode 100644
index 0000000..e7842c5
--- /dev/null
+++ b/cpp/samples/BaseSample/Controllee/CycleControlListener.h
@@ -0,0 +1,35 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#ifndef CYCLECONTROLLISTENER_H_
+#define CYCLECONTROLLISTENER_H_
+
+#include <alljoyn/hae/interfaces/operation/CycleControlInterface.h>
+#include <alljoyn/hae/interfaces/operation/CycleControlIntfControlleeListener.h>
+using namespace ajn;
+using namespace services;
+
+
+class CycleControlListener : public CycleControlIntfControlleeListener
+{
+public:
+    virtual QStatus OnGetOperationalState(CycleControlInterface::CycleControlOperationalState& state);
+
+    virtual QStatus OnExecuteCommand(CycleControlInterface::CycleControlOperationalCommand command, CycleControlInterface::CycleControlOperationalState& newState, ErrorCode& error);
+
+};
+
+#endif /* CYCLECONTROLLISTENER_H_ */
diff --git a/cpp/samples/BaseSample/Controllee/DishWashingCyclePhaseListener.cc b/cpp/samples/BaseSample/Controllee/DishWashingCyclePhaseListener.cc
new file mode 100644
index 0000000..cb48b02
--- /dev/null
+++ b/cpp/samples/BaseSample/Controllee/DishWashingCyclePhaseListener.cc
@@ -0,0 +1,64 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#include <iostream>
+#include "DishWashingCyclePhaseListener.h"
+
+using namespace std;
+
+
+QStatus DishWashingCyclePhaseListener::OnGetCyclePhase(uint8_t& cyclePhase)
+{
+    QStatus status = ER_OK;
+    cout << "DishWashingCyclePhaseListener::OnGetCyclePhase" << endl;
+    return status;
+}
+
+QStatus DishWashingCyclePhaseListener::OnGetSupportedCyclePhases(DishWashingCyclePhaseInterface::SupportedCyclePhases& listOfSupportedCyclePhases)
+{
+    QStatus status = ER_OK;
+    cout << "DishWashingCyclePhaseListener::OnGetSupportedCyclePhases" << endl;
+    return status;
+}
+
+QStatus DishWashingCyclePhaseListener::OnGetCyclePhasesDescriptions(const qcc::String language, DishWashingCyclePhaseInterface::CyclePhaseDescriptions& listOfPhaseDescs, ErrorCode& errorCode)
+{
+    QStatus status = ER_OK;
+    cout << "DishWashingCyclePhaseListener::OnGetCyclePhasesDescriptions" << endl;
+
+    DishWashingCyclePhaseInterface::DishWashingPhaseDescriptor disc;
+    disc.phase = 1;
+    disc.name = "phase1";
+    disc.description = "this is phase 1";
+    listOfPhaseDescs.push_back(disc);
+
+    disc.phase = 2;
+    disc.name = "phase2";
+    disc.description = "this is phase 2";
+    listOfPhaseDescs.push_back(disc);
+
+    disc.phase = 3;
+    disc.name = "phase3";
+    disc.description = "this is phase 3";
+    listOfPhaseDescs.push_back(disc);
+
+    disc.phase = 4;
+    disc.name = "phase4";
+    disc.description = "this is phase 4";
+    listOfPhaseDescs.push_back(disc);
+
+    return status;
+}
diff --git a/cpp/samples/BaseSample/Controllee/DishWashingCyclePhaseListener.h b/cpp/samples/BaseSample/Controllee/DishWashingCyclePhaseListener.h
new file mode 100644
index 0000000..84f44e0
--- /dev/null
+++ b/cpp/samples/BaseSample/Controllee/DishWashingCyclePhaseListener.h
@@ -0,0 +1,38 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#ifndef DISHWASHINGCYCLEPHASELISTENER_H_
+#define DISHWASHINGCYCLEPHASELISTENER_H_
+
+#include <alljoyn/hae/interfaces/operation/DishWashingCyclePhaseIntfControlleeListener.h>
+using namespace ajn;
+using namespace services;
+
+
+class DishWashingCyclePhaseListener : public DishWashingCyclePhaseIntfControlleeListener
+{
+public:
+        virtual QStatus OnGetCyclePhase(uint8_t& cyclePhase);
+
+        virtual QStatus OnGetSupportedCyclePhases(DishWashingCyclePhaseInterface::SupportedCyclePhases& listOfSupportedCyclePhases);
+
+        virtual QStatus OnGetCyclePhasesDescriptions(const qcc::String language,
+                                                     DishWashingCyclePhaseInterface::CyclePhaseDescriptions& listOfPhasesDescs,
+                                                     ErrorCode& errorCode);
+
+};
+
+#endif /* DISHWASHINGCYCLEPHASELISTENER_H_ */
diff --git a/cpp/samples/BaseSample/Controllee/HeatingZoneListener.cc b/cpp/samples/BaseSample/Controllee/HeatingZoneListener.cc
new file mode 100644
index 0000000..80f29f1
--- /dev/null
+++ b/cpp/samples/BaseSample/Controllee/HeatingZoneListener.cc
@@ -0,0 +1,37 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#include <iostream>
+#include "HeatingZoneListener.h"
+
+using namespace std;
+
+
+QStatus HeatingZoneListener::OnGetNumberOfHeatingZones(uint8_t& currentState)
+{
+    cout << "HeatingZoneListener::OnGetNumberOfHeatingZones()" << endl;
+    return ER_OK;
+}
+QStatus HeatingZoneListener::OnGetMaxHeatingLevels(std::vector<uint8_t>& maxHeatingLevels)
+{
+    cout << "HeatingZoneListener::OnGetMaxHeatingLevels()" << endl;
+    return ER_OK;
+}
+QStatus HeatingZoneListener::OnGetHeatingLevels(std::vector<uint8_t>& heatingLevels)
+{
+    cout << "HeatingZoneListener::OnGetHeatingLevels()" << endl;
+    return ER_OK;
+}
diff --git a/cpp/samples/BaseSample/Controllee/HeatingZoneListener.h b/cpp/samples/BaseSample/Controllee/HeatingZoneListener.h
new file mode 100644
index 0000000..e932f41
--- /dev/null
+++ b/cpp/samples/BaseSample/Controllee/HeatingZoneListener.h
@@ -0,0 +1,53 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#ifndef HEATINGZONELISTENER_H_
+#define HEATINGZONELISTENER_H_
+
+#include <alljoyn/hae/interfaces/operation/HeatingZoneIntfControlleeListener.h>
+using namespace ajn;
+using namespace services;
+
+
+class HeatingZoneListener : public HeatingZoneIntfControlleeListener
+{
+
+public:
+        /**
+         * Handler for getting number of heating zones
+         * This function is only called, when InterfaceControllee::s_retrievingActualPropertyValue is true.
+         * @param[out] currentState currentState
+         * @return ER_OK on success
+         */
+        virtual QStatus OnGetNumberOfHeatingZones(uint8_t& currentState);
+        /**
+         * Handler for getting max heating levels
+         * This function is only called, when InterfaceControllee::s_retrievingActualPropertyValue is true.
+         * @param[out] maxHeatingLevels maxHeatingLevels
+         * @return ER_OK on success
+         */
+        virtual QStatus OnGetMaxHeatingLevels(std::vector<uint8_t>& maxHeatingLevels);
+        /**
+         * Handler for getting heating levels
+         * This function is only called, when InterfaceControllee::s_retrievingActualPropertyValue is true.
+         * @param[out] heatingLevels heatingLevels
+         * @return ER_OK on success
+         */
+        virtual QStatus OnGetHeatingLevels(std::vector<uint8_t>& heatingLevels);
+
+};
+
+#endif /* HEATINGZONELISTENER_H_ */
diff --git a/cpp/samples/BaseSample/Controllee/LaundryCyclePhaseListener.cc b/cpp/samples/BaseSample/Controllee/LaundryCyclePhaseListener.cc
new file mode 100644
index 0000000..ef6ea1d
--- /dev/null
+++ b/cpp/samples/BaseSample/Controllee/LaundryCyclePhaseListener.cc
@@ -0,0 +1,64 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#include <iostream>
+#include "LaundryCyclePhaseListener.h"
+
+using namespace std;
+
+
+QStatus LaundryCyclePhaseListener::OnGetCyclePhase(uint8_t& cyclePhase)
+{
+    QStatus status = ER_OK;
+    cout << "LaundryCyclePhaseListener::OnGetCyclePhase" << endl;
+    return status;
+}
+
+QStatus LaundryCyclePhaseListener::OnGetSupportedCyclePhases(LaundryCyclePhaseInterface::SupportedCyclePhases& listOfSupportedCyclePhases)
+{
+    QStatus status = ER_OK;
+    cout << "LaundryCyclePhaseListener::OnGetSupportedCyclePhases" << endl;
+    return status;
+}
+
+QStatus LaundryCyclePhaseListener::OnGetCyclePhasesDescriptions(const qcc::String& language, LaundryCyclePhaseInterface::CyclePhaseDescriptions& listOfPhaseDescs, ErrorCode& errorCode)
+{
+    QStatus status = ER_OK;
+    cout << "LaundryCyclePhaseListener::OnGetCyclePhasesDescriptions" << endl;
+
+    LaundryCyclePhaseInterface::LaundryPhaseDescriptor disc;
+    disc.phase = 1;
+    disc.name = "laundy phase1";
+    disc.description = "laundry this is phase 1";
+    listOfPhaseDescs.push_back(disc);
+
+    disc.phase = 2;
+    disc.name = "laundry phase2";
+    disc.description = "laundry this is phase 2";
+    listOfPhaseDescs.push_back(disc);
+
+    disc.phase = 3;
+    disc.name = "laundry phase3";
+    disc.description = "laundry this is phase 3";
+    listOfPhaseDescs.push_back(disc);
+
+    disc.phase = 4;
+    disc.name = "laundry phase4";
+    disc.description = "laundry this is phase 4";
+    listOfPhaseDescs.push_back(disc);
+
+    return status;
+}
diff --git a/cpp/samples/BaseSample/Controllee/LaundryCyclePhaseListener.h b/cpp/samples/BaseSample/Controllee/LaundryCyclePhaseListener.h
new file mode 100644
index 0000000..11940b3
--- /dev/null
+++ b/cpp/samples/BaseSample/Controllee/LaundryCyclePhaseListener.h
@@ -0,0 +1,38 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#ifndef LAUNDRYCYCLEPHASELISTENER_H_
+#define LAUNDRYCYCLEPHASELISTENER_H_
+
+#include <alljoyn/hae/interfaces/operation/LaundryCyclePhaseIntfControlleeListener.h>
+using namespace ajn;
+using namespace services;
+
+
+class LaundryCyclePhaseListener : public LaundryCyclePhaseIntfControlleeListener
+{
+public:
+        virtual QStatus OnGetCyclePhase(uint8_t& cyclePhase);
+
+        virtual QStatus OnGetSupportedCyclePhases(LaundryCyclePhaseInterface::SupportedCyclePhases& listOfSupportedCyclePhases);
+
+        virtual QStatus OnGetCyclePhasesDescriptions(const qcc::String& language,
+                                                     LaundryCyclePhaseInterface::CyclePhaseDescriptions& listOfPhasesDescs,
+                                                     ErrorCode& errorCode);
+
+};
+
+#endif /* LAUNDRYCYCLEPHASELISTENER_H_ */
diff --git a/cpp/samples/BaseSample/Controllee/OvenCyclePhaseListener.cc b/cpp/samples/BaseSample/Controllee/OvenCyclePhaseListener.cc
new file mode 100644
index 0000000..f19028b
--- /dev/null
+++ b/cpp/samples/BaseSample/Controllee/OvenCyclePhaseListener.cc
@@ -0,0 +1,64 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#include <iostream>
+#include "OvenCyclePhaseListener.h"
+
+using namespace std;
+
+
+QStatus OvenCyclePhaseListener::OnGetCyclePhase(uint8_t& cyclePhase)
+{
+    QStatus status = ER_OK;
+    cout << "OvenCyclePhaseListener::OnGetCyclePhase" << endl;
+    return status;
+}
+
+QStatus OvenCyclePhaseListener::OnGetSupportedCyclePhases(OvenCyclePhaseInterface::SupportedCyclePhases& listOfSupportedCyclePhases)
+{
+    QStatus status = ER_OK;
+    cout << "OvenCyclePhaseListener::OnGetSupportedCyclePhases" << endl;
+    return status;
+}
+
+QStatus OvenCyclePhaseListener::OnGetCyclePhasesDescriptions(const qcc::String language, OvenCyclePhaseInterface::CyclePhaseDescriptions& listOfPhaseDescs, ErrorCode& errorCode)
+{
+    QStatus status = ER_OK;
+    cout << "OvenCyclePhaseListener::OnGetCyclePhasesDescriptions" << endl;
+
+    OvenCyclePhaseInterface::OvenPhaseDescriptor disc;
+    disc.phase = 1;
+    disc.name = "Oven phase1";
+    disc.description = "Oven this is phase 1";
+    listOfPhaseDescs.push_back(disc);
+
+    disc.phase = 2;
+    disc.name = "Oven phase2";
+    disc.description = "Oven this is phase 2";
+    listOfPhaseDescs.push_back(disc);
+
+    disc.phase = 3;
+    disc.name = "Oven phase3";
+    disc.description = "Oven this is phase 3";
+    listOfPhaseDescs.push_back(disc);
+
+    disc.phase = 4;
+    disc.name = "Oven phase4";
+    disc.description = "Oven this is phase 4";
+    listOfPhaseDescs.push_back(disc);
+
+    return status;
+}
diff --git a/cpp/samples/BaseSample/Controllee/OvenCyclePhaseListener.h b/cpp/samples/BaseSample/Controllee/OvenCyclePhaseListener.h
new file mode 100644
index 0000000..59328f1
--- /dev/null
+++ b/cpp/samples/BaseSample/Controllee/OvenCyclePhaseListener.h
@@ -0,0 +1,38 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#ifndef OVENCYCLEPHASELISTENER_H_
+#define OVENCYCLEPHASELISTENER_H_
+
+#include <alljoyn/hae/interfaces/operation/OvenCyclePhaseIntfControlleeListener.h>
+using namespace ajn;
+using namespace services;
+
+
+class OvenCyclePhaseListener : public OvenCyclePhaseIntfControlleeListener
+{
+public:
+        virtual QStatus OnGetCyclePhase(uint8_t& cyclePhase);
+
+        virtual QStatus OnGetSupportedCyclePhases(OvenCyclePhaseInterface::SupportedCyclePhases& listOfSupportedCyclePhases);
+
+        virtual QStatus OnGetCyclePhasesDescriptions(const qcc::String language,
+                                                     OvenCyclePhaseInterface::CyclePhaseDescriptions& listOfPhasesDescs,
+                                                     ErrorCode& errorCode);
+
+};
+
+#endif /* OVENCYCLEPHASELISTENER_H_ */
diff --git a/cpp/samples/BaseSample/Controllee/RapidModeListener.cc b/cpp/samples/BaseSample/Controllee/RapidModeListener.cc
new file mode 100644
index 0000000..1e730a3
--- /dev/null
+++ b/cpp/samples/BaseSample/Controllee/RapidModeListener.cc
@@ -0,0 +1,33 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#include <iostream>
+#include "RapidModeListener.h"
+
+using namespace std;
+
+
+QStatus RapidModeListener::OnGetRapidMode(bool& isClosed)
+{
+    cout << "RapidModeListener::OnGetRapidMode()" << endl;
+    return ER_OK;
+}
+
+QStatus RapidModeListener::OnSetRapidMode(const bool& isClosed)
+{
+    cout << "RapidModeListener::OnSetRapidMode()" << endl;
+    return ER_OK;
+}
diff --git a/cpp/samples/BaseSample/Controllee/RapidModeListener.h b/cpp/samples/BaseSample/Controllee/RapidModeListener.h
new file mode 100644
index 0000000..d897864
--- /dev/null
+++ b/cpp/samples/BaseSample/Controllee/RapidModeListener.h
@@ -0,0 +1,34 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#ifndef RAPIDMODELISTENER_H_
+#define RAPIDMODELISTENER_H_
+
+#include <alljoyn/hae/interfaces/operation/RapidModeIntfControlleeListener.h>
+
+using namespace ajn;
+using namespace services;
+
+class RapidModeListener : public RapidModeIntfControlleeListener
+{
+  public:
+
+    virtual QStatus OnSetRapidMode(const bool& rapidMode);
+
+    virtual QStatus OnGetRapidMode(bool& volume);
+};
+
+#endif /* RAPIDMODELISTENER_H_ */
diff --git a/cpp/samples/BaseSample/Controllee/RemoteControllabilityListener.cc b/cpp/samples/BaseSample/Controllee/RemoteControllabilityListener.cc
new file mode 100644
index 0000000..c1863d8
--- /dev/null
+++ b/cpp/samples/BaseSample/Controllee/RemoteControllabilityListener.cc
@@ -0,0 +1,27 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#include <iostream>
+#include "RemoteControllabilityListener.h"
+
+using namespace std;
+
+QStatus RemoteControllabilityListener::OnGetIsControllable(bool& isControllable)
+{
+    cout << "ClosedStatusListener::OnGetIsControllable()" << endl;
+    return ER_OK;
+}
+
diff --git a/cpp/samples/BaseSample/Controllee/RemoteControllabilityListener.h b/cpp/samples/BaseSample/Controllee/RemoteControllabilityListener.h
new file mode 100644
index 0000000..4a6a562
--- /dev/null
+++ b/cpp/samples/BaseSample/Controllee/RemoteControllabilityListener.h
@@ -0,0 +1,31 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#ifndef REMOTECONTROLLABILITYLISTENER_H_
+#define REMOTECONTROLLABILITYLISTENER_H_
+
+#include <alljoyn/hae/interfaces/operation/RemoteControllabilityIntfControlleeListener.h>
+
+using namespace ajn;
+using namespace services;
+
+class RemoteControllabilityListener : public RemoteControllabilityIntfControlleeListener
+{
+  public:
+    virtual QStatus OnGetIsControllable(bool& isControllable);
+};
+
+#endif /* REMOTECONTROLLABILITYLISTENER_H_ */
diff --git a/cpp/samples/BaseSample/Controllee/SoilLevelListener.cc b/cpp/samples/BaseSample/Controllee/SoilLevelListener.cc
new file mode 100644
index 0000000..4c16c62
--- /dev/null
+++ b/cpp/samples/BaseSample/Controllee/SoilLevelListener.cc
@@ -0,0 +1,58 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#include <iostream>
+
+#include "SoilLevelListener.h"
+
+using namespace std;
+
+
+QStatus SoilLevelListener::OnGetMaxLevel(uint8_t& maxLevel)
+{
+    cout << " SoilLevelListener::OnGetMaxLevel" << endl;
+    return ER_OK;
+}
+
+QStatus SoilLevelListener::OnSetMaxLevel(const uint8_t& maxLevel)
+{
+    cout << "SoilLevelListener::OnSetMaxLevel " << endl;
+    return ER_OK;
+}
+
+QStatus SoilLevelListener::OnGetTargetLevel(uint8_t& targetLevel)
+{
+    cout << "SoilLevelListener::OnGetTargetLevel " << endl;
+    return ER_OK;
+}
+
+QStatus SoilLevelListener::OnSetTargetLevel(const uint8_t& targetLevel)
+{
+    cout << " SoilLevelListener::OnSetTargetLevel" << endl;
+    return ER_OK;
+}
+
+QStatus SoilLevelListener::OnGetSelectableLevels(std::vector<uint8_t>& selectableLevels)
+{
+    cout << "SoilLevelListener::OnGetSelectableLevels " << endl;
+    return ER_OK;
+}
+
+QStatus SoilLevelListener::OnSetSelectableLevels(const std::vector<uint8_t>& selectableLevels)
+{
+    cout << "SoilLevelListener::OnSetSelectableLevels " << endl;
+    return ER_OK;
+}
diff --git a/cpp/samples/BaseSample/Controllee/SoilLevelListener.h b/cpp/samples/BaseSample/Controllee/SoilLevelListener.h
new file mode 100644
index 0000000..dd38d82
--- /dev/null
+++ b/cpp/samples/BaseSample/Controllee/SoilLevelListener.h
@@ -0,0 +1,41 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#ifndef SOILLEVELLISTENER_H_
+#define SOILLEVELLISTENER_H_
+
+#include <alljoyn/hae/interfaces/operation/SoilLevelIntfControlleeListener.h>
+
+using namespace ajn;
+using namespace services;
+
+class SoilLevelListener : public SoilLevelIntfControlleeListener
+{
+  public:
+    virtual QStatus OnGetMaxLevel(uint8_t& maxLevel);
+
+    virtual QStatus OnSetMaxLevel(const uint8_t& maxLevel);
+
+    virtual QStatus OnGetTargetLevel(uint8_t& targetLevel);
+
+    virtual QStatus OnSetTargetLevel(const uint8_t& targetLevel);
+
+    virtual QStatus OnGetSelectableLevels(std::vector<uint8_t>& selectableLevels);
+
+    virtual QStatus OnSetSelectableLevels(const std::vector<uint8_t>& selectableLevels);
+};
+
+#endif /* SOILLEVELLISTENER_H_ */
diff --git a/cpp/samples/BaseSample/Controllee/SpinSpeedLevelListener.cc b/cpp/samples/BaseSample/Controllee/SpinSpeedLevelListener.cc
new file mode 100644
index 0000000..3bade67
--- /dev/null
+++ b/cpp/samples/BaseSample/Controllee/SpinSpeedLevelListener.cc
@@ -0,0 +1,58 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#include <iostream>
+
+#include "SpinSpeedLevelListener.h"
+
+using namespace std;
+
+
+QStatus SpinSpeedLevelListener::OnGetMaxLevel(uint8_t& maxLevel)
+{
+    cout << " SpinSpeedLevelListener::OnGetMaxLevel" << endl;
+    return ER_OK;
+}
+
+QStatus SpinSpeedLevelListener::OnSetMaxLevel(const uint8_t& maxLevel)
+{
+    cout << "SpinSpeedLevelListener::OnSetMaxLevel " << endl;
+    return ER_OK;
+}
+
+QStatus SpinSpeedLevelListener::OnGetTargetLevel(uint8_t& targetLevel)
+{
+    cout << "SpinSpeedLevelListener::OnGetTargetLevel " << endl;
+    return ER_OK;
+}
+
+QStatus SpinSpeedLevelListener::OnSetTargetLevel(const uint8_t& targetLevel)
+{
+    cout << " SpinSpeedLevelListener::OnSetTargetLevel" << endl;
+    return ER_OK;
+}
+
+QStatus SpinSpeedLevelListener::OnGetSelectableLevels(std::vector<uint8_t>& selectableLevels)
+{
+    cout << "SpinSpeedLevelListener::OnGetSelectableLevels " << endl;
+    return ER_OK;
+}
+
+QStatus SpinSpeedLevelListener::OnSetSelectableLevels(const std::vector<uint8_t>& selectableLevels)
+{
+    cout << "SpinSpeedLevelListener::OnSetSelectableLevels " << endl;
+    return ER_OK;
+}
diff --git a/cpp/samples/BaseSample/Controllee/SpinSpeedLevelListener.h b/cpp/samples/BaseSample/Controllee/SpinSpeedLevelListener.h
new file mode 100644
index 0000000..7aeece6
--- /dev/null
+++ b/cpp/samples/BaseSample/Controllee/SpinSpeedLevelListener.h
@@ -0,0 +1,41 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#ifndef SPINSPEEDLEVELLISTENER_H_
+#define SPINSPEEDLEVELLISTENER_H_
+
+#include <alljoyn/hae/interfaces/operation/SpinSpeedLevelIntfControlleeListener.h>
+
+using namespace ajn;
+using namespace services;
+
+class SpinSpeedLevelListener : public SpinSpeedLevelIntfControlleeListener
+{
+  public:
+    virtual QStatus OnGetMaxLevel(uint8_t& maxLevel);
+
+    virtual QStatus OnSetMaxLevel(const uint8_t& maxLevel);
+
+    virtual QStatus OnGetTargetLevel(uint8_t& targetLevel);
+
+    virtual QStatus OnSetTargetLevel(const uint8_t& targetLevel);
+
+    virtual QStatus OnGetSelectableLevels(std::vector<uint8_t>& selectableLevels);
+
+    virtual QStatus OnSetSelectableLevels(const std::vector<uint8_t>& selectableLevels);
+};
+
+#endif /* SPINSPEEDLEVELLISTENER_H_ */
diff --git a/cpp/samples/BaseSample/Controllee/TimerListener.cc b/cpp/samples/BaseSample/Controllee/TimerListener.cc
new file mode 100644
index 0000000..4c3164c
--- /dev/null
+++ b/cpp/samples/BaseSample/Controllee/TimerListener.cc
@@ -0,0 +1,70 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#include <iostream>
+
+#include "TimerListener.h"
+
+using namespace std;
+
+QStatus TimerListener::GetReferenceTimer(int32_t& time)
+{
+    return ER_OK;
+}
+
+QStatus TimerListener::GetTargetTimeToStart(int32_t& time)
+{
+    return ER_OK;
+
+}
+
+QStatus TimerListener::GetTargetTimeToStop(int32_t& time)
+{
+    return ER_OK;
+
+}
+
+QStatus TimerListener::GetEstimatedTimeToEnd(int32_t& time)
+{
+    return ER_OK;
+
+}
+
+QStatus TimerListener::GetRunningTime(int32_t& time)
+{
+    return ER_OK;
+
+}
+
+QStatus TimerListener::GetTargetDuration(int32_t& time)
+{
+    return ER_OK;
+
+}
+
+QStatus TimerListener::OnSetTargetTimeToStart(int32_t time, ErrorCode& errorCode)
+{
+    cout << "TimerListener::OnSetTargetTimeToStart" <<endl;
+    cout << "time: " << (int)time << endl;
+    return ER_OK;
+}
+
+QStatus TimerListener::OnSetTargetTimeToStop(int32_t time, ErrorCode& errorCode)
+{
+    cout << "TimerListener::OnSetTargetTimeToStop" <<endl;
+    cout << "time: " << (int)time << endl;
+    return ER_OK;
+}
diff --git a/cpp/samples/BaseSample/Controllee/TimerListener.h b/cpp/samples/BaseSample/Controllee/TimerListener.h
new file mode 100644
index 0000000..3ddfd32
--- /dev/null
+++ b/cpp/samples/BaseSample/Controllee/TimerListener.h
@@ -0,0 +1,46 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#ifndef TIMERLISTENER_H_
+#define TIMERLISTENER_H_
+
+#include <alljoyn/hae/interfaces/operation/TimerIntfControlleeListener.h>
+
+using namespace ajn;
+using namespace services;
+
+class TimerListener : public TimerIntfControlleeListener
+{
+  public:
+        virtual QStatus GetReferenceTimer(int32_t& time) ;
+
+        virtual QStatus GetTargetTimeToStart(int32_t& time) ;
+
+        virtual QStatus GetTargetTimeToStop(int32_t& time) ;
+
+        virtual QStatus GetEstimatedTimeToEnd(int32_t& time);
+
+        virtual QStatus GetRunningTime(int32_t& time) ;
+
+        virtual QStatus GetTargetDuration(int32_t& time);
+
+        virtual QStatus OnSetTargetTimeToStart(int32_t time, ErrorCode& errorCode) ;
+
+        virtual QStatus OnSetTargetTimeToStop(int32_t time, ErrorCode& errorCode) ;
+
+};
+
+#endif /* WATERLEVELLISTENER_H_ */
diff --git a/cpp/samples/BaseSample/Controllee/WaterLevelListener.cc b/cpp/samples/BaseSample/Controllee/WaterLevelListener.cc
new file mode 100644
index 0000000..fd9b433
--- /dev/null
+++ b/cpp/samples/BaseSample/Controllee/WaterLevelListener.cc
@@ -0,0 +1,46 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#include <iostream>
+
+#include "WaterLevelListener.h"
+
+using namespace std;
+
+
+QStatus WaterLevelListener::OnGetCurrentLevel(uint8_t& currentLevel)
+{
+    QStatus status = ER_OK;
+    cout << "# WaterLevelListener::OnGetCurrentLevel()" << endl;
+    cout << "Current level: " << (int)currentLevel << endl;
+    return status;
+}
+
+QStatus WaterLevelListener::OnGetMaxLevel(uint8_t& maxLevel)
+{
+    QStatus status = ER_OK;
+    cout << "# WaterLevelListener::OnGetMaxLevel()" << endl;
+    cout << "Max level: " << (int)maxLevel << endl;
+    return status;
+}
+
+QStatus WaterLevelListener::OnGetSupplySource(WaterLevelInterface::WaterLevelSupplySource& supplySource)
+{
+    QStatus status = ER_OK;
+    cout << "# WaterLevelListener::OnGetSupplySource()" << endl;
+    cout << "Supply Source: " << (int)supplySource << endl;
+    return status;
+}
diff --git a/cpp/samples/BaseSample/Controllee/WaterLevelListener.h b/cpp/samples/BaseSample/Controllee/WaterLevelListener.h
new file mode 100644
index 0000000..f26eb60
--- /dev/null
+++ b/cpp/samples/BaseSample/Controllee/WaterLevelListener.h
@@ -0,0 +1,35 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#ifndef WATERLEVELLISTENER_H_
+#define WATERLEVELLISTENER_H_
+
+#include <alljoyn/hae/interfaces/environment/WaterLevelIntfControlleeListener.h>
+
+using namespace ajn;
+using namespace services;
+
+class WaterLevelListener : public WaterLevelIntfControlleeListener
+{
+  public:
+        virtual QStatus OnGetCurrentLevel(uint8_t& currentLevel);
+
+        virtual QStatus OnGetMaxLevel(uint8_t& maxLevel);
+
+        virtual QStatus OnGetSupplySource(WaterLevelInterface::WaterLevelSupplySource& supplySource);
+};
+
+#endif /* WATERLEVELLISTENER_H_ */
diff --git a/cpp/samples/BaseSample/Controller/ClosedStatusCommands.cc b/cpp/samples/BaseSample/Controller/ClosedStatusCommands.cc
index 194c96c..884aa33 100644
--- a/cpp/samples/BaseSample/Controller/ClosedStatusCommands.cc
+++ b/cpp/samples/BaseSample/Controller/ClosedStatusCommands.cc
@@ -72,7 +72,7 @@ void ClosedStatusCommands::Init()
 
 void ClosedStatusCommands::OnCmdGetIsClosed(Commands* commands, std::string& cmd)
 {
-	ClosedStatusIntfController* intfController = static_cast<ClosedStatusCommands*>(commands)->GetInterface();
+    ClosedStatusIntfController* intfController = static_cast<ClosedStatusCommands*>(commands)->GetInterface();
 
     if (!intfController) {
         cout << "Interface is not exist." << endl;
diff --git a/cpp/samples/BaseSample/Controller/CycleControlCommands.cc b/cpp/samples/BaseSample/Controller/CycleControlCommands.cc
new file mode 100644
index 0000000..ed0ddb8
--- /dev/null
+++ b/cpp/samples/BaseSample/Controller/CycleControlCommands.cc
@@ -0,0 +1,193 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#include "CycleControlCommands.h"
+#include "ControllerSample.h"
+
+CycleControlListener::CycleControlListener()
+{
+}
+
+CycleControlListener::~CycleControlListener()
+{
+}
+
+
+void CycleControlListener::OperationalStatePropertyChanged(const qcc::String& objectPath, const CycleControlInterface::CycleControlOperationalState state)
+{
+    cout << __func__ << endl;
+    cout << "# path: " << objectPath << endl;
+    cout << "# state: " <<(int)state <<"; state string: "<< CycleControlInterface::OPERATIONAL_STATE_STRINGS[state] << endl;
+}
+
+
+void CycleControlListener::GetOperationalStatePropertyCallback(QStatus status, const qcc::String& objectPath, const CycleControlInterface::CycleControlOperationalState state, void* context)
+{
+    cout << __func__ << endl;
+    cout << "# status: " << QCC_StatusText(status) << endl;
+    cout << "# path: " << objectPath << endl;
+    cout << "# state: " <<(int)state <<"; state string: "<< CycleControlInterface::OPERATIONAL_STATE_STRINGS[state] << endl;
+}
+
+
+void CycleControlListener::GetSupportedStatesPropertyCallbalck(QStatus status, const qcc::String& objectPath, const CycleControlInterface::SupportedOperationalStates states, void* context)
+{
+    cout << __func__ << endl;
+    cout << "# status: " << QCC_StatusText(status) << endl;
+    cout << "# path: " << objectPath << endl;
+    cout << "# supported states: " << endl;
+    for (size_t i = 0 ; i < states.size() ; i++)
+    {
+        cout << "# state: " << (int)states[i] << "; state string: " << CycleControlInterface::OPERATIONAL_STATE_STRINGS[states[i]] << endl;
+    }
+}
+
+void CycleControlListener::GetSupportedCommandsPropertyCallbalck(QStatus status, const qcc::String& objectPath, const CycleControlInterface::SupportedOperationalCommands commands, void* context)
+{
+    cout << __func__ << endl;
+    cout << "# status: " << QCC_StatusText(status) << endl;
+    cout << "# path: " << objectPath << endl;
+    cout << "# supported commands: " << endl;
+    for (size_t i = 0 ; i < commands.size() ; i++)
+    {
+        cout << "# command: " << (int)commands[i] << "; command string: " << CycleControlInterface::OPERATIONAL_COMMAND_STRINGS[commands[i]] << endl;
+    }
+}
+
+void CycleControlListener::SupportedOperationalStatesProperyChanged(const qcc::String& objectPath, const CycleControlInterface::SupportedOperationalStates states)
+{
+    cout << __func__ << endl;
+    cout << "# path: " << objectPath << endl;
+    cout << "# supported states: " << endl;
+    for (size_t i = 0 ; i < states.size() ; i++)
+    {
+        cout << "# state: " << (int)states[i] << "state string: " << CycleControlInterface::OPERATIONAL_STATE_STRINGS[states[i]] << endl;
+    }
+}
+
+void CycleControlListener::SupportedOperationalCommandsProperyChanged(const qcc::String& objectPath, const CycleControlInterface::SupportedOperationalCommands commands)
+{
+    cout << __func__ << endl;
+    cout << "# path: " << objectPath << endl;
+    cout << "# supported commands: " << endl;
+    for (size_t i = 0 ; i < commands.size() ; i++)
+    {
+        cout << "# command: " << (int)commands[i] << "command string: " << CycleControlInterface::OPERATIONAL_COMMAND_STRINGS[commands[i]] << endl;
+    }
+
+}
+void CycleControlListener::OnExecuteCommandRespose(QStatus status, const qcc::String& objectPath, void* context, const char* errorName, const char* errorMessage)
+{
+    cout << "# CycleControlListener::OnExecuteCommandRespose()" << endl;
+    cout << "# status: " << QCC_StatusText(status) << endl;
+    cout << "# path: " << objectPath << endl;
+    if(status != ER_OK)
+    {
+        cout << "# error name: " << errorName << endl;
+        cout << "# error message: " << errorMessage << endl;
+    }
+}
+void CycleControlListener::OnEndOfCycle( const qcc::String& objectPath )
+{
+    cout << "# CycleControlListener::OnEndOfCycle()" << endl;
+    cout << "# path: " << objectPath << endl;
+}
+
+CycleControlCommands::CycleControlCommands(ControllerSample* sample, DeviceInfoPtr& info, const char* objectPath)
+: InterfaceCommands(sample, info, objectPath),
+  m_intfController(NULL)
+{
+}
+
+CycleControlCommands::~CycleControlCommands()
+{
+
+}
+
+void CycleControlCommands::Init()
+{
+    if (!m_intfController) {
+        HaeInterface* haeInterface = m_sample->CreateInterface(CYCLE_CONTROL_INTERFACE, m_deviceInfo->GetBusName(), m_objectPath, m_deviceInfo->GetSessionId(), m_listener);
+        if (!haeInterface) {
+            cout << "Interface creation failed." << endl;
+            return;
+        }
+
+        m_intfController = static_cast<CycleControlIntfController*>(haeInterface);
+    }
+
+    RegisterCommand(&CycleControlCommands::OnCmdGetOperationalState, "gos", "get operational state");
+    RegisterCommand(&CycleControlCommands::OnCmdExecuteCommand, "exec", "execute command");
+    RegisterCommand(&CycleControlCommands::OnCmdGetSupportedOperationalCommands, "gsop", "get supported operational commands");
+    RegisterCommand(&CycleControlCommands::OnCmdGetSupportedOperationalStates, "gsos", "get supported operational states");
+    PrintCommands();
+}
+
+void CycleControlCommands::OnCmdGetSupportedOperationalCommands(Commands* commands, std::string& cmd)
+{
+    CycleControlIntfController* intfController = static_cast<CycleControlCommands*>(commands)->GetInterface();
+
+    if (!intfController) {
+        cout << "Interface is not exist." << endl;
+        return;
+    }
+
+    intfController->GetSupportedOperationalCommands();
+}
+
+void CycleControlCommands::OnCmdGetSupportedOperationalStates(Commands* commands, std::string& cmd)
+{
+    CycleControlIntfController* intfController = static_cast<CycleControlCommands*>(commands)->GetInterface();
+
+    if (!intfController) {
+
+        cout << "Interface is not exist." << endl;
+        return;
+    }
+
+    intfController->GetSupportedOperationalStates();
+}
+
+void CycleControlCommands::OnCmdGetOperationalState(Commands* commands, std::string& cmd)
+{
+    CycleControlIntfController* intfController = static_cast<CycleControlCommands*>(commands)->GetInterface();
+
+    if (!intfController) {
+        cout << "Interface is not exist." << endl;
+        return;
+    }
+
+    intfController->GetOperationalState();
+}
+
+void CycleControlCommands::OnCmdExecuteCommand(Commands * commands, std::string& cmd)
+{
+    CycleControlIntfController* intfController = static_cast<CycleControlCommands*>(commands)->GetInterface();
+    if(!intfController)
+    {
+        cout << "Interface is not exist." << endl;
+        return;
+    }
+
+    cout << "Command string: " << cmd.c_str() << endl;
+    int command = strtol(cmd.c_str(), NULL, 10);
+    if ( command >=0 && command <=3 ) {
+        intfController->ExecuteCommand((CycleControlInterface::CycleControlOperationalCommand)command);
+    } else {
+        cout << "Input argument is wrong." << endl;
+        return;
+    }
+}
diff --git a/cpp/samples/BaseSample/Controller/CycleControlCommands.h b/cpp/samples/BaseSample/Controller/CycleControlCommands.h
new file mode 100644
index 0000000..9864f8a
--- /dev/null
+++ b/cpp/samples/BaseSample/Controller/CycleControlCommands.h
@@ -0,0 +1,72 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#ifndef CYCLECONTROLCOMMANDS_H_
+#define CYCLECONTROLCOMMANDS_H_
+
+#include "InterfaceCommands.h"
+#include <alljoyn/hae/interfaces/operation/CycleControlIntfController.h>
+#include <alljoyn/hae/interfaces/operation/CycleControlIntfControllerListener.h>
+
+class ControllerSample;
+
+using namespace ajn;
+using namespace services;
+
+class CycleControlListener : public CycleControlIntfControllerListener{
+  public:
+    CycleControlListener();
+    virtual ~CycleControlListener();
+    virtual void GetOperationalStatePropertyCallback(QStatus status, const qcc::String& objectPath, const CycleControlInterface::CycleControlOperationalState state, void* context);
+
+    virtual void GetSupportedStatesPropertyCallbalck(QStatus status, const qcc::String& objectPath, const CycleControlInterface::SupportedOperationalStates states, void* context);
+
+    virtual void GetSupportedCommandsPropertyCallbalck(QStatus status, const qcc::String& objectPath, const CycleControlInterface::SupportedOperationalCommands commands, void* context);
+
+    virtual void OperationalStatePropertyChanged(const qcc::String& objectPath, const CycleControlInterface::CycleControlOperationalState state);
+
+    virtual void SupportedOperationalStatesProperyChanged(const qcc::String& objectPath, const CycleControlInterface::SupportedOperationalStates states);
+
+    virtual void SupportedOperationalCommandsProperyChanged(const qcc::String& objectPath, const CycleControlInterface::SupportedOperationalCommands commands);
+
+    virtual void OnExecuteCommandRespose(QStatus status, const qcc::String& objectPath, void* context, const char* errorName, const char* errorMessage);
+
+    virtual void OnEndOfCycle( const qcc::String& objectPath );
+};
+
+class CycleControlCommands : public InterfaceCommands
+{
+  public:
+    CycleControlCommands(ControllerSample* sample, DeviceInfoPtr& info, const char* objectPath);
+    virtual ~CycleControlCommands();
+
+    virtual void Init();
+
+    CycleControlIntfController* GetInterface() { return m_intfController; }
+    static void OnCmdGetOperationalState(Commands* commands, std::string& cmd);
+
+    static void OnCmdExecuteCommand(Commands* commands, std::string& cmd);
+
+    static void OnCmdGetSupportedOperationalCommands(Commands* commands, std::string& cmd);
+
+    static void OnCmdGetSupportedOperationalStates(Commands* commands, std::string& cmd);
+  private:
+    CycleControlIntfController* m_intfController;
+    CycleControlListener m_listener;
+};
+
+
+#endif /* CYCLECONTROLCOMMANDS_H_ */
diff --git a/cpp/samples/BaseSample/Controller/DeviceCommands.cc b/cpp/samples/BaseSample/Controller/DeviceCommands.cc
index 3bc9011..9e41e64 100644
--- a/cpp/samples/BaseSample/Controller/DeviceCommands.cc
+++ b/cpp/samples/BaseSample/Controller/DeviceCommands.cc
@@ -20,6 +20,18 @@
 #include "VendorDefinedCommands.h"
 #include "BatteryStatusCommands.h"
 #include "RepeatModeCommands.h"
+#include "CycleControlCommands.h"
+#include "RemoteControllabilityCommands.h"
+#include "RapidModeCommands.h"
+#include "SoilLevelCommands.h"
+#include "SpinSpeedLevelCommands.h"
+#include "WaterLevelCommands.h"
+#include "HeatingZoneCommands.h"
+#include "DishWashingCyclePhaseCommands.h"
+#include "LaundryCyclePhaseCommands.h"
+#include "OvenCyclePhaseCommands.h"
+#include "TimerCommands.h"
+
 
 DeviceCommands::DeviceCommands(ControllerSample* sample, DeviceInfoPtr& info)
 : ControllerCommands(sample)
@@ -129,6 +141,28 @@ Commands* DeviceCommands::CreateInterfaceCommands(Commands* commands, const char
         intfCommands = new VendorDefinedCommands(sample, info, objectPath);
     } else if (!strncmp(intfName, "org.alljoyn.SmartSpaces.Operation.ClosedStatus", strlen(intfName))){
         intfCommands = new ClosedStatusCommands(sample, info, objectPath);
+    } else if (!strncmp(intfName, "org.alljoyn.SmartSpaces.Operation.CycleControl", strlen(intfName))) {
+        intfCommands = new CycleControlCommands(sample, info, objectPath);
+    } else if (!strncmp(intfName, "org.alljoyn.SmartSpaces.Operation.RapidMode", strlen(intfName))) {
+        intfCommands = new RapidModeCommands(sample, info, objectPath);
+    } else if (!strncmp(intfName, "org.alljoyn.SmartSpaces.Operation.SoilLevel", strlen(intfName))) {
+        intfCommands = new SoilLevelCommands(sample, info, objectPath);
+    } else if (!strncmp(intfName, "org.alljoyn.SmartSpaces.Operation.SpinSpeedLevel", strlen(intfName))) {
+        intfCommands = new SpinSpeedLevelCommands(sample, info, objectPath);
+    } else if (!strncmp(intfName, "org.alljoyn.SmartSpaces.Environment.WaterLevel", strlen(intfName))) {
+        intfCommands = new WaterLevelCommands(sample, info, objectPath);
+    } else if (!strncmp(intfName, "org.alljoyn.SmartSpaces.Operation.HeatingZone", strlen(intfName))) {
+        intfCommands = new HeatingZoneCommands(sample, info, objectPath);
+    } else if (!strncmp(intfName, "org.alljoyn.SmartSpaces.Operation.DishWashingCyclePhase", strlen(intfName))) {
+            intfCommands = new DishWashingCyclePhaseCommands(sample, info, objectPath);
+    } else if (!strncmp(intfName, "org.alljoyn.SmartSpaces.Operation.OvenCyclePhase", strlen(intfName))) {
+        intfCommands = new OvenCyclePhaseCommands(sample, info, objectPath);
+    } else if (!strncmp(intfName, "org.alljoyn.SmartSpaces.Operation.LaundryCyclePhase", strlen(intfName))) {
+        intfCommands = new LaundryCyclePhaseCommands(sample, info, objectPath);
+    } else if (!strncmp(intfName, "org.alljoyn.SmartSpaces.Operation.Timer", strlen(intfName))) {
+        intfCommands = new TimerCommands(sample, info, objectPath);
+    } else if (!strncmp(intfName, "org.alljoyn.SmartSpaces.Operation.RemoteControllability", strlen(intfName))) {
+        intfCommands = new RemoteControllabilityCommands(sample, info, objectPath);
     }
     return intfCommands;
 }
diff --git a/cpp/samples/BaseSample/Controller/DishWashingCyclePhaseCommands.cc b/cpp/samples/BaseSample/Controller/DishWashingCyclePhaseCommands.cc
new file mode 100644
index 0000000..976ffd7
--- /dev/null
+++ b/cpp/samples/BaseSample/Controller/DishWashingCyclePhaseCommands.cc
@@ -0,0 +1,142 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#include "DishWashingCyclePhaseCommands.h"
+#include "ControllerSample.h"
+
+DishWashingCyclePhaseListener::DishWashingCyclePhaseListener()
+{
+}
+
+DishWashingCyclePhaseListener::~DishWashingCyclePhaseListener()
+{
+}
+
+
+void DishWashingCyclePhaseListener::OnResponseGetCyclePhase(QStatus status, const qcc::String& objectPath, const uint8_t& cyclePhase, void* context)
+{
+    cout << __func__ << endl;
+    cout << "# status: " << QCC_StatusText(status) << endl;
+    cout << "# path: " << objectPath << endl;
+    cout << "# cyclePhase: " << (int)cyclePhase << endl;
+}
+
+void DishWashingCyclePhaseListener::OnResponseGetSupportedCyclePhases(QStatus status, const qcc::String& objectPath, const DishWashingCyclePhaseInterface::SupportedCyclePhases& listOfCyclePhases, void* context)
+{
+    cout << __func__ << endl;
+    cout << "# status: " << QCC_StatusText(status) << endl;
+    cout << "# path: " << objectPath << endl;
+    cout << "# supported cycle phases: " << endl;
+    for(size_t i = 0 ; i < listOfCyclePhases.size(); i++)
+        cout << (int)listOfCyclePhases[i] << endl;
+}
+
+void DishWashingCyclePhaseListener::OnCyclePhasePropertyChanged(const qcc::String& objectPath, const uint8_t cyclePhase)
+{
+    cout << __func__ << endl;
+    cout << "# path: " << objectPath << endl;
+    cout << "# cyclePhase: " << (int)cyclePhase << endl;
+}
+
+void DishWashingCyclePhaseListener::OnSupportedCyclePhasesPropertyChanged(const qcc::String& objectPath, const DishWashingCyclePhaseInterface::SupportedCyclePhases listOfCyclePhases)
+{
+    cout << __func__ << endl;
+    cout << "# path: " << objectPath << endl;
+    cout << "# supported cycle phases: " << endl;
+    for(size_t i = 0 ; i < listOfCyclePhases.size(); i++)
+        cout << (int)listOfCyclePhases[i] << endl;
+}
+
+void DishWashingCyclePhaseListener::OnResponseGetCyclePhasesDescriptions(QStatus status, const qcc::String& objectPath, const DishWashingCyclePhaseInterface::CyclePhaseDescriptions& listOfCycleDescriptions, void* context, const char* errorName, const char* errorMessage)
+{
+    cout << __func__ << endl;
+    cout << "# status: " << QCC_StatusText(status) << endl;
+    cout << "# path: " << objectPath << endl;
+    cout << "# phase descs: " << endl;
+    cout << "Status: " << QCC_StatusText(status) << endl;
+    if(status != ER_OK)
+    {
+        cout << "error name: " << errorName << endl;
+        cout << "error mess: " << errorMessage << endl;
+    }
+    for(size_t i = 0 ; i < listOfCycleDescriptions.size(); i++)
+        cout << (int)listOfCycleDescriptions[i].phase << " " << listOfCycleDescriptions[i].name << " " << listOfCycleDescriptions[i].description<<endl;
+}
+
+DishWashingCyclePhaseCommands::DishWashingCyclePhaseCommands(ControllerSample* sample, DeviceInfoPtr& info, const char* objectPath)
+: InterfaceCommands(sample, info, objectPath),
+  m_intfController(NULL)
+{
+}
+
+DishWashingCyclePhaseCommands::~DishWashingCyclePhaseCommands()
+{
+
+}
+
+void DishWashingCyclePhaseCommands::Init()
+{
+    if (!m_intfController) {
+        HaeInterface* haeInterface = m_sample->CreateInterface(DISH_WASHING_CYCLE_PHASE_INTERFACE, m_deviceInfo->GetBusName(), m_objectPath, m_deviceInfo->GetSessionId(), m_listener);
+        if (!haeInterface) {
+            cout << "Interface creation failed." << endl;
+            return;
+        }
+
+        m_intfController = static_cast<DishWashingCyclePhaseIntfController*>(haeInterface);
+    }
+
+    RegisterCommand(&DishWashingCyclePhaseCommands::OnCmdGetCyclePhase, "gcp", "get cycle phase");
+    RegisterCommand(&DishWashingCyclePhaseCommands::OnCmdGetSupportedCyclePhases, "gscp", "get supported cycle phases");
+    RegisterCommand(&DishWashingCyclePhaseCommands::OnCmdGetCyclePhasesDescriptions, "gcpd", "get cycle phase descriptions");
+    PrintCommands();
+}
+void DishWashingCyclePhaseCommands::OnCmdGetCyclePhase(Commands* commands, std::string& cmd)
+{
+    DishWashingCyclePhaseIntfController* intfController = static_cast<DishWashingCyclePhaseCommands*>(commands)->GetInterface();
+
+    if (!intfController) {
+        cout << "Interface is not exist." << endl;
+        return;
+    }
+
+    intfController->GetCyclePhase();
+}
+
+void DishWashingCyclePhaseCommands::OnCmdGetSupportedCyclePhases(Commands* commands, std::string& cmd)
+{
+    DishWashingCyclePhaseIntfController* intfController = static_cast<DishWashingCyclePhaseCommands*>(commands)->GetInterface();
+
+    if (!intfController) {
+        cout << "Interface is not exist." << endl;
+        return;
+    }
+
+    intfController->GetSupportedCyclePhases();
+}
+
+void DishWashingCyclePhaseCommands::OnCmdGetCyclePhasesDescriptions(Commands* commands, std::string& cmd)
+{
+    DishWashingCyclePhaseIntfController* intfController = static_cast<DishWashingCyclePhaseCommands*>(commands)->GetInterface();
+
+    if (!intfController) {
+        cout << "Interface is not exist." << endl;
+        return;
+    }
+
+    cout << "Command string: " << cmd.c_str() << endl;
+    intfController->GetCyclePhasesDescriptions(cmd.c_str());
+}
diff --git a/cpp/samples/BaseSample/Controller/DishWashingCyclePhaseCommands.h b/cpp/samples/BaseSample/Controller/DishWashingCyclePhaseCommands.h
new file mode 100644
index 0000000..d080a2e
--- /dev/null
+++ b/cpp/samples/BaseSample/Controller/DishWashingCyclePhaseCommands.h
@@ -0,0 +1,64 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#ifndef DISHWASHINGCYCLEPHASECOMMANDS_H_
+#define DISHWASHINGCYCLEPHASECOMMANDS_H_
+
+#include "InterfaceCommands.h"
+#include <alljoyn/hae/interfaces/operation/DishWashingCyclePhaseIntfController.h>
+#include <alljoyn/hae/interfaces/operation/DishWashingCyclePhaseIntfControllerListener.h>
+
+class ControllerSample;
+
+using namespace ajn;
+using namespace services;
+
+class DishWashingCyclePhaseListener : public DishWashingCyclePhaseIntfControllerListener{
+  public:
+    DishWashingCyclePhaseListener();
+    virtual ~DishWashingCyclePhaseListener();
+    virtual void OnResponseGetCyclePhase(QStatus status, const qcc::String& objectPath, const uint8_t& cyclePhase, void* context);
+
+    virtual void OnResponseGetSupportedCyclePhases(QStatus status, const qcc::String& objectPath, const DishWashingCyclePhaseInterface::SupportedCyclePhases& listOfCyclePhases, void* context);
+
+    virtual void OnCyclePhasePropertyChanged(const qcc::String& objectPath, const uint8_t cyclePhase);
+
+    virtual void OnSupportedCyclePhasesPropertyChanged(const qcc::String& objectPath, const DishWashingCyclePhaseInterface::SupportedCyclePhases listOfCyclePhases);
+
+    virtual void OnResponseGetCyclePhasesDescriptions(QStatus status, const qcc::String& objectPath, const DishWashingCyclePhaseInterface::CyclePhaseDescriptions& listOfCycleDescriptions, void* context, const char* errorName, const char* errorMessage);
+};
+
+class DishWashingCyclePhaseCommands : public InterfaceCommands
+{
+  public:
+        DishWashingCyclePhaseCommands(ControllerSample* sample, DeviceInfoPtr& info, const char* objectPath);
+    virtual ~DishWashingCyclePhaseCommands();
+
+    virtual void Init();
+
+    DishWashingCyclePhaseIntfController* GetInterface() { return m_intfController; }
+    static void OnCmdGetCyclePhase(Commands* commands, std::string& cmd);
+
+    static void OnCmdGetSupportedCyclePhases(Commands* commands, std::string& cmd);
+
+    static void OnCmdGetCyclePhasesDescriptions(Commands* commands, std::string& cmd);
+  private:
+    DishWashingCyclePhaseIntfController* m_intfController;
+    DishWashingCyclePhaseListener m_listener;
+};
+
+
+#endif /* DISHWASHINGCYCLEPHASECOMMANDS_H_ */
diff --git a/cpp/samples/BaseSample/Controller/HeatingZoneCommands.cc b/cpp/samples/BaseSample/Controller/HeatingZoneCommands.cc
new file mode 100644
index 0000000..f428dee
--- /dev/null
+++ b/cpp/samples/BaseSample/Controller/HeatingZoneCommands.cc
@@ -0,0 +1,149 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#include "HeatingZoneCommands.h"
+#include "ControllerSample.h"
+
+HeatingZoneListener::HeatingZoneListener()
+{
+}
+
+HeatingZoneListener::~HeatingZoneListener()
+{
+}
+
+
+void HeatingZoneListener::OnGetNumberOfHeatingZonesPropertyCallback(QStatus status, const qcc::String& objectPath, const uint8_t numberOfZones, void* context)
+{
+    cout << __func__ << endl;
+    cout << "# status: " << QCC_StatusText(status) << endl;
+    cout << "# path: " << objectPath << endl;
+    cout << "# number of heating zones: " << (int) numberOfZones << endl;
+}
+void HeatingZoneListener::OnGetMaxHeatingLevelsPropertyCallback(QStatus status, const qcc::String& objectPath, std::vector<uint8_t> maxHeatingLevels, void* context)
+{
+    cout << __func__ << endl;
+    cout << "# status: " << QCC_StatusText(status) << endl;
+    cout << "# path: " << objectPath << endl;
+    cout << "# max heating levels: " << endl;
+    for (size_t i = 0 ; i < maxHeatingLevels.size() ; i++)
+    {
+        cout << "# max level: " << (int)maxHeatingLevels[i] << endl;
+    }
+}
+void HeatingZoneListener::OnGetHeatingLevelsPropertyCallback(QStatus status, const qcc::String& objectPath, std::vector<uint8_t> heatingLevels, void* context)
+{
+    cout << __func__ << endl;
+    cout << "# status: " << QCC_StatusText(status) << endl;
+    cout << "# path: " << objectPath << endl;
+    cout << "# heating levels: " << endl;
+    for (size_t i = 0 ; i < heatingLevels.size() ; i++)
+    {
+        cout << "# level: " << (int)heatingLevels[i] << endl;
+    }
+}
+void HeatingZoneListener::NumberOfHeatingZonesPropertyChanged(const qcc::String& objectPath, const uint8_t numberOfHeatingZones)
+{
+    cout << __func__ << endl;
+    cout << "# path: " << objectPath << endl;
+    cout << "# number of heating zones: " << (int) numberOfHeatingZones << endl;
+}
+void HeatingZoneListener::MaxHeatingLevelsPropertyChanged(const qcc::String& objectPath, std::vector<uint8_t> maxHeatingLevels)
+{
+    cout << __func__ << endl;
+    cout << "# path: " << objectPath << endl;
+    cout << "# max heating levels: " << endl;
+    for (size_t i = 0 ; i < maxHeatingLevels.size() ; i++)
+    {
+        cout << "# max level: " << (int)maxHeatingLevels[i] << endl;
+    }
+}
+void HeatingZoneListener::HeatingLevelsPropertyChanged(const qcc::String& objectPath, std::vector<uint8_t> heatingLevels)
+{
+    cout << __func__ << endl;
+    cout << "# path: " << objectPath << endl;
+    cout << "# heating levels: " << endl;
+    for (size_t i = 0 ; i < heatingLevels.size() ; i++)
+    {
+        cout << "# level: " << (int)heatingLevels[i] << endl;
+    }
+}
+
+HeatingZoneCommands::HeatingZoneCommands(ControllerSample* sample, DeviceInfoPtr& info, const char* objectPath)
+: InterfaceCommands(sample, info, objectPath),
+  m_intfController(NULL)
+{
+}
+
+HeatingZoneCommands::~HeatingZoneCommands()
+{
+
+}
+
+void HeatingZoneCommands::Init()
+{
+    if (!m_intfController) {
+        HaeInterface* haeInterface = m_sample->CreateInterface(HEATING_ZONE_INTERFACE, m_deviceInfo->GetBusName(), m_objectPath, m_deviceInfo->GetSessionId(), m_listener);
+        if (!haeInterface) {
+            cout << "Interface creation failed." << endl;
+            return;
+        }
+
+        m_intfController = static_cast<HeatingZoneIntfController*>(haeInterface);
+    }
+
+    RegisterCommand(&HeatingZoneCommands::OnCmdGetNumberOfHeatingZones, "gnhz", "get number opf heating zones");
+    RegisterCommand(&HeatingZoneCommands::OnCmdGetMaxHeatingLevels, "gmhl", "get max heating levels");
+    RegisterCommand(&HeatingZoneCommands::OnCmdGetHeatingLevels, "ghl", "get get heating levels");
+    PrintCommands();
+}
+
+
+void HeatingZoneCommands::OnCmdGetHeatingLevels(Commands * commands, std::string& cmd)
+{
+    HeatingZoneIntfController* intfController = static_cast<HeatingZoneCommands*>(commands)->GetInterface();
+    if(!intfController)
+    {
+        cout << "Interface is not exist." << endl;
+        return;
+    }
+
+    intfController->GetHeatingLevels();
+}
+
+void HeatingZoneCommands::OnCmdGetMaxHeatingLevels(Commands * commands, std::string& cmd)
+{
+    HeatingZoneIntfController* intfController = static_cast<HeatingZoneCommands*>(commands)->GetInterface();
+    if(!intfController)
+    {
+        cout << "Interface is not exist." << endl;
+        return;
+    }
+
+    intfController->GetMaxHeatingLevels();
+}
+
+void HeatingZoneCommands::OnCmdGetNumberOfHeatingZones(Commands * commands, std::string& cmd)
+{
+    HeatingZoneIntfController* intfController = static_cast<HeatingZoneCommands*>(commands)->GetInterface();
+    if(!intfController)
+    {
+        cout << "Interface is not exist." << endl;
+        return;
+    }
+
+    intfController->GetNumberOfHeatingZones();
+}
diff --git a/cpp/samples/BaseSample/Controller/HeatingZoneCommands.h b/cpp/samples/BaseSample/Controller/HeatingZoneCommands.h
new file mode 100644
index 0000000..fb04374
--- /dev/null
+++ b/cpp/samples/BaseSample/Controller/HeatingZoneCommands.h
@@ -0,0 +1,62 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#ifndef HEATINGZONECOMMANDS_H_
+#define HEATINGZONECOMMANDS_H_
+
+#include "InterfaceCommands.h"
+#include <alljoyn/hae/interfaces/operation/HeatingZoneIntfController.h>
+#include <alljoyn/hae/interfaces/operation/HeatingZoneIntfControllerListener.h>
+
+class ControllerSample;
+
+using namespace ajn;
+using namespace services;
+
+class HeatingZoneListener : public HeatingZoneIntfControllerListener{
+  public:
+    HeatingZoneListener();
+    virtual ~HeatingZoneListener();
+
+    virtual void OnGetNumberOfHeatingZonesPropertyCallback(QStatus status, const qcc::String& objectPath, const uint8_t numberOfZones, void* context);
+    virtual void OnGetMaxHeatingLevelsPropertyCallback(QStatus status, const qcc::String& objectPath, std::vector<uint8_t> maxHeatingLevels, void* context);
+    virtual void OnGetHeatingLevelsPropertyCallback(QStatus status, const qcc::String& objectPath, std::vector<uint8_t> heatingLevels, void* context);
+    virtual void NumberOfHeatingZonesPropertyChanged(const qcc::String& objectPath, const uint8_t numberOfHeatingZones);
+    virtual void MaxHeatingLevelsPropertyChanged(const qcc::String& objectPath, std::vector<uint8_t> maxHeatingLevels);
+    virtual void HeatingLevelsPropertyChanged(const qcc::String& objectPath, std::vector<uint8_t> heatingLevels);
+};
+
+class HeatingZoneCommands : public InterfaceCommands
+{
+  public:
+    HeatingZoneCommands(ControllerSample* sample, DeviceInfoPtr& info, const char* objectPath);
+    virtual ~HeatingZoneCommands();
+
+    virtual void Init();
+
+    HeatingZoneIntfController* GetInterface() { return m_intfController; }
+    static void OnCmdGetNumberOfHeatingZones(Commands* commands, std::string& cmd);
+
+    static void OnCmdGetMaxHeatingLevels(Commands* commands, std::string& cmd);
+
+    static void OnCmdGetHeatingLevels(Commands* commands, std::string& cmd);
+  private:
+    HeatingZoneIntfController* m_intfController;
+    HeatingZoneListener m_listener;
+};
+
+
+#endif /* HEATINGZONECOMMANDS_H_ */
diff --git a/cpp/samples/BaseSample/Controller/LaundryCyclePhaseCommands.cc b/cpp/samples/BaseSample/Controller/LaundryCyclePhaseCommands.cc
new file mode 100644
index 0000000..3e1604d
--- /dev/null
+++ b/cpp/samples/BaseSample/Controller/LaundryCyclePhaseCommands.cc
@@ -0,0 +1,141 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#include "LaundryCyclePhaseCommands.h"
+#include "ControllerSample.h"
+
+LaundryCyclePhaseListener::LaundryCyclePhaseListener()
+{
+}
+
+LaundryCyclePhaseListener::~LaundryCyclePhaseListener()
+{
+}
+
+
+void LaundryCyclePhaseListener::OnResponseGetCyclePhase(QStatus status, const qcc::String& objectPath, const uint8_t& cyclePhase, void* context)
+{
+    cout << __func__ << endl;
+    cout << "# status: " << QCC_StatusText(status) << endl;
+    cout << "# path: " << objectPath << endl;
+    cout << "# cyclePhase: " << (int)cyclePhase << endl;
+}
+
+void LaundryCyclePhaseListener::OnResponseGetSupportedCyclePhases(QStatus status, const qcc::String& objectPath, const LaundryCyclePhaseInterface::SupportedCyclePhases& listOfCyclePhases, void* context)
+{
+    cout << __func__ << endl;
+    cout << "# status: " << QCC_StatusText(status) << endl;
+    cout << "# path: " << objectPath << endl;
+    cout << "# supported cycle phases: " << endl;
+    for(size_t i = 0 ; i < listOfCyclePhases.size(); i++)
+        cout << (int)listOfCyclePhases[i] << endl;
+}
+
+void LaundryCyclePhaseListener::OnCyclePhasePropertyChanged(const qcc::String& objectPath, const uint8_t cyclePhase)
+{
+    cout << __func__ << endl;
+    cout << "# path: " << objectPath << endl;
+    cout << "# cyclePhase: " << (int)cyclePhase << endl;
+}
+
+void LaundryCyclePhaseListener::OnSupportedCyclePhasesPropertyChanged(const qcc::String& objectPath, const LaundryCyclePhaseInterface::SupportedCyclePhases listOfCyclePhases)
+{
+    cout << __func__ << endl;
+    cout << "# path: " << objectPath << endl;
+    cout << "# supported cycle phases: " << endl;
+    for(size_t i = 0 ; i < listOfCyclePhases.size(); i++)
+        cout << (int)listOfCyclePhases[i] << endl;
+}
+
+void LaundryCyclePhaseListener::OnResponseGetCyclePhasesDescriptions(QStatus status, const qcc::String& objectPath, const LaundryCyclePhaseInterface::CyclePhaseDescriptions& listOfCycleDescriptions, void* context, const char* errorName, const char* errorMessage)
+{
+    cout << __func__ << endl;
+    cout << "# path: " << objectPath << endl;
+    cout << "# phase descs: " << endl;
+    cout << "Status: " << QCC_StatusText(status) << endl;
+    if(status != ER_OK)
+    {
+        cout << "error name: " << errorName << endl;
+        cout << "error mess: " << errorMessage << endl;
+    }
+    for(size_t i = 0 ; i < listOfCycleDescriptions.size(); i++)
+        cout << (int)listOfCycleDescriptions[i].phase << " " << listOfCycleDescriptions[i].name << " " << listOfCycleDescriptions[i].description<<endl;
+}
+
+LaundryCyclePhaseCommands::LaundryCyclePhaseCommands(ControllerSample* sample, DeviceInfoPtr& info, const char* objectPath)
+: InterfaceCommands(sample, info, objectPath),
+  m_intfController(NULL)
+{
+}
+
+LaundryCyclePhaseCommands::~LaundryCyclePhaseCommands()
+{
+
+}
+
+void LaundryCyclePhaseCommands::Init()
+{
+    if (!m_intfController) {
+        HaeInterface* haeInterface = m_sample->CreateInterface(LAUNDRY_CYCLE_PHASE_INTERFACE, m_deviceInfo->GetBusName(), m_objectPath, m_deviceInfo->GetSessionId(), m_listener);
+        if (!haeInterface) {
+            cout << "Interface creation failed." << endl;
+            return;
+        }
+
+        m_intfController = static_cast<LaundryCyclePhaseIntfController*>(haeInterface);
+    }
+
+    RegisterCommand(&LaundryCyclePhaseCommands::OnCmdGetCyclePhase, "gcp", "get cycle phase");
+    RegisterCommand(&LaundryCyclePhaseCommands::OnCmdGetSupportedCyclePhases, "gscp", "get supported cycle phases");
+    RegisterCommand(&LaundryCyclePhaseCommands::OnCmdGetCyclePhasesDescriptions, "gcpd", "get cycle phase descriptions");
+    PrintCommands();
+}
+void LaundryCyclePhaseCommands::OnCmdGetCyclePhase(Commands* commands, std::string& cmd)
+{
+    LaundryCyclePhaseIntfController* intfController = static_cast<LaundryCyclePhaseCommands*>(commands)->GetInterface();
+
+    if (!intfController) {
+        cout << "Interface is not exist." << endl;
+        return;
+    }
+
+    intfController->GetCyclePhase();
+}
+
+void LaundryCyclePhaseCommands::OnCmdGetSupportedCyclePhases(Commands* commands, std::string& cmd)
+{
+    LaundryCyclePhaseIntfController* intfController = static_cast<LaundryCyclePhaseCommands*>(commands)->GetInterface();
+
+    if (!intfController) {
+        cout << "Interface is not exist." << endl;
+        return;
+    }
+
+    intfController->GetSupportedCyclePhases();
+}
+
+void LaundryCyclePhaseCommands::OnCmdGetCyclePhasesDescriptions(Commands* commands, std::string& cmd)
+{
+    LaundryCyclePhaseIntfController* intfController = static_cast<LaundryCyclePhaseCommands*>(commands)->GetInterface();
+
+    if (!intfController) {
+        cout << "Interface is not exist." << endl;
+        return;
+    }
+
+    cout << "Command string: " << cmd.c_str() << endl;
+    intfController->GetCyclePhasesDescriptions(cmd.c_str());
+}
diff --git a/cpp/samples/BaseSample/Controller/LaundryCyclePhaseCommands.h b/cpp/samples/BaseSample/Controller/LaundryCyclePhaseCommands.h
new file mode 100644
index 0000000..722dc79
--- /dev/null
+++ b/cpp/samples/BaseSample/Controller/LaundryCyclePhaseCommands.h
@@ -0,0 +1,64 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#ifndef LAUNDRYCYCLEPHASECOMMANDS_H_
+#define LAUNDRYCYCLEPHASECOMMANDS_H_
+
+#include "InterfaceCommands.h"
+#include <alljoyn/hae/interfaces/operation/LaundryCyclePhaseIntfController.h>
+#include <alljoyn/hae/interfaces/operation/LaundryCyclePhaseIntfControllerListener.h>
+
+class ControllerSample;
+
+using namespace ajn;
+using namespace services;
+
+class LaundryCyclePhaseListener : public LaundryCyclePhaseIntfControllerListener{
+  public:
+    LaundryCyclePhaseListener();
+    virtual ~LaundryCyclePhaseListener();
+    virtual void OnResponseGetCyclePhase(QStatus status, const qcc::String& objectPath, const uint8_t& cyclePhase, void* context);
+
+    virtual void OnResponseGetSupportedCyclePhases(QStatus status, const qcc::String& objectPath, const LaundryCyclePhaseInterface::SupportedCyclePhases& listOfCyclePhases, void* context);
+
+    virtual void OnCyclePhasePropertyChanged(const qcc::String& objectPath, const uint8_t cyclePhase);
+
+    virtual void OnSupportedCyclePhasesPropertyChanged(const qcc::String& objectPath, const LaundryCyclePhaseInterface::SupportedCyclePhases listOfCyclePhases);
+
+    virtual void OnResponseGetCyclePhasesDescriptions(QStatus status, const qcc::String& objectPath, const LaundryCyclePhaseInterface::CyclePhaseDescriptions& listOfCycleDescriptions, void* context, const char* errorName, const char* errorMessage);
+};
+
+class LaundryCyclePhaseCommands : public InterfaceCommands
+{
+  public:
+        LaundryCyclePhaseCommands(ControllerSample* sample, DeviceInfoPtr& info, const char* objectPath);
+    virtual ~LaundryCyclePhaseCommands();
+
+    virtual void Init();
+
+    LaundryCyclePhaseIntfController* GetInterface() { return m_intfController; }
+    static void OnCmdGetCyclePhase(Commands* commands, std::string& cmd);
+
+    static void OnCmdGetSupportedCyclePhases(Commands* commands, std::string& cmd);
+
+    static void OnCmdGetCyclePhasesDescriptions(Commands* commands, std::string& cmd);
+  private:
+    LaundryCyclePhaseIntfController* m_intfController;
+    LaundryCyclePhaseListener m_listener;
+};
+
+
+#endif /* LAUNDRYCYCLEPHASECOMMANDS_H_ */
diff --git a/cpp/samples/BaseSample/Controller/OvenCyclePhaseCommands.cc b/cpp/samples/BaseSample/Controller/OvenCyclePhaseCommands.cc
new file mode 100644
index 0000000..7a91229
--- /dev/null
+++ b/cpp/samples/BaseSample/Controller/OvenCyclePhaseCommands.cc
@@ -0,0 +1,141 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#include "OvenCyclePhaseCommands.h"
+#include "ControllerSample.h"
+
+OvenCyclePhaseListener::OvenCyclePhaseListener()
+{
+}
+
+OvenCyclePhaseListener::~OvenCyclePhaseListener()
+{
+}
+
+
+void OvenCyclePhaseListener::OnResponseGetCyclePhase(QStatus status, const qcc::String& objectPath, const uint8_t& cyclePhase, void* context)
+{
+    cout << __func__ << endl;
+    cout << "# status: " << QCC_StatusText(status) << endl;
+    cout << "# path: " << objectPath << endl;
+    cout << "# cyclePhase: " << (int)cyclePhase << endl;
+}
+
+void OvenCyclePhaseListener::OnResponseGetSupportedCyclePhases(QStatus status, const qcc::String& objectPath, const OvenCyclePhaseInterface::SupportedCyclePhases& listOfCyclePhases, void* context)
+{
+    cout << __func__ << endl;
+    cout << "# status: " << QCC_StatusText(status) << endl;
+    cout << "# path: " << objectPath << endl;
+    cout << "# supported cycle phases: " << endl;
+    for(size_t i = 0 ; i < listOfCyclePhases.size(); i++)
+        cout << (int)listOfCyclePhases[i] << endl;
+}
+
+void OvenCyclePhaseListener::OnCyclePhasePropertyChanged(const qcc::String& objectPath, const uint8_t cyclePhase)
+{
+    cout << __func__ << endl;
+    cout << "# path: " << objectPath << endl;
+    cout << "# cyclePhase: " << (int)cyclePhase << endl;
+}
+
+void OvenCyclePhaseListener::OnSupportedCyclePhasesPropertyChanged(const qcc::String& objectPath, const OvenCyclePhaseInterface::SupportedCyclePhases listOfCyclePhases)
+{
+    cout << __func__ << endl;
+    cout << "# path: " << objectPath << endl;
+    cout << "# supported cycle phases: " << endl;
+    for(size_t i = 0 ; i < listOfCyclePhases.size(); i++)
+        cout << (int)listOfCyclePhases[i] << endl;
+}
+
+void OvenCyclePhaseListener::OnResponseGetCyclePhasesDescriptions(QStatus status, const qcc::String& objectPath, const OvenCyclePhaseInterface::CyclePhaseDescriptions& listOfCycleDescriptions, void* context, const char* errorName, const char* errorMessage)
+{
+    cout << __func__ << endl;
+    cout << "# path: " << objectPath << endl;
+    cout << "# phase descs: " << endl;
+    cout << "Status: " << QCC_StatusText(status) << endl;
+    if(status != ER_OK)
+    {
+        cout << "error name: " << errorName << endl;
+        cout << "error mess: " << errorMessage << endl;
+    }
+    for(size_t i = 0 ; i < listOfCycleDescriptions.size(); i++)
+        cout << (int)listOfCycleDescriptions[i].phase << " " << listOfCycleDescriptions[i].name << " " << listOfCycleDescriptions[i].description<<endl;
+}
+
+OvenCyclePhaseCommands::OvenCyclePhaseCommands(ControllerSample* sample, DeviceInfoPtr& info, const char* objectPath)
+: InterfaceCommands(sample, info, objectPath),
+  m_intfController(NULL)
+{
+}
+
+OvenCyclePhaseCommands::~OvenCyclePhaseCommands()
+{
+
+}
+
+void OvenCyclePhaseCommands::Init()
+{
+    if (!m_intfController) {
+        HaeInterface* haeInterface = m_sample->CreateInterface(OVEN_CYCLE_PHASE_INTERFACE, m_deviceInfo->GetBusName(), m_objectPath, m_deviceInfo->GetSessionId(), m_listener);
+        if (!haeInterface) {
+            cout << "Interface creation failed." << endl;
+            return;
+        }
+
+        m_intfController = static_cast<OvenCyclePhaseIntfController*>(haeInterface);
+    }
+
+    RegisterCommand(&OvenCyclePhaseCommands::OnCmdGetCyclePhase, "gcp", "get cycle phase");
+    RegisterCommand(&OvenCyclePhaseCommands::OnCmdGetSupportedCyclePhases, "gscp", "get supported cycle phases");
+    RegisterCommand(&OvenCyclePhaseCommands::OnCmdGetCyclePhasesDescriptions, "gcpd", "get cycle phase descriptions");
+    PrintCommands();
+}
+void OvenCyclePhaseCommands::OnCmdGetCyclePhase(Commands* commands, std::string& cmd)
+{
+    OvenCyclePhaseIntfController* intfController = static_cast<OvenCyclePhaseCommands*>(commands)->GetInterface();
+
+    if (!intfController) {
+        cout << "Interface is not exist." << endl;
+        return;
+    }
+
+    intfController->GetCyclePhase();
+}
+
+void OvenCyclePhaseCommands::OnCmdGetSupportedCyclePhases(Commands* commands, std::string& cmd)
+{
+    OvenCyclePhaseIntfController* intfController = static_cast<OvenCyclePhaseCommands*>(commands)->GetInterface();
+
+    if (!intfController) {
+        cout << "Interface is not exist." << endl;
+        return;
+    }
+
+    intfController->GetSupportedCyclePhases();
+}
+
+void OvenCyclePhaseCommands::OnCmdGetCyclePhasesDescriptions(Commands* commands, std::string& cmd)
+{
+    OvenCyclePhaseIntfController* intfController = static_cast<OvenCyclePhaseCommands*>(commands)->GetInterface();
+
+    if (!intfController) {
+        cout << "Interface is not exist." << endl;
+        return;
+    }
+
+    cout << "Command string: " << cmd.c_str() << endl;
+    intfController->GetCyclePhasesDescriptions(cmd.c_str());
+}
diff --git a/cpp/samples/BaseSample/Controller/OvenCyclePhaseCommands.h b/cpp/samples/BaseSample/Controller/OvenCyclePhaseCommands.h
new file mode 100644
index 0000000..9df6571
--- /dev/null
+++ b/cpp/samples/BaseSample/Controller/OvenCyclePhaseCommands.h
@@ -0,0 +1,64 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#ifndef OVENCYCLEPHASECOMMANDS_H_
+#define OVENCYCLEPHASECOMMANDS_H_
+
+#include "InterfaceCommands.h"
+#include <alljoyn/hae/interfaces/operation/OvenCyclePhaseIntfController.h>
+#include <alljoyn/hae/interfaces/operation/OvenCyclePhaseIntfControllerListener.h>
+
+class ControllerSample;
+
+using namespace ajn;
+using namespace services;
+
+class OvenCyclePhaseListener : public OvenCyclePhaseIntfControllerListener{
+  public:
+    OvenCyclePhaseListener();
+    virtual ~OvenCyclePhaseListener();
+    virtual void OnResponseGetCyclePhase(QStatus status, const qcc::String& objectPath, const uint8_t& cyclePhase, void* context);
+
+    virtual void OnResponseGetSupportedCyclePhases(QStatus status, const qcc::String& objectPath, const OvenCyclePhaseInterface::SupportedCyclePhases& listOfCyclePhases, void* context);
+
+    virtual void OnCyclePhasePropertyChanged(const qcc::String& objectPath, const uint8_t cyclePhase);
+
+    virtual void OnSupportedCyclePhasesPropertyChanged(const qcc::String& objectPath, const OvenCyclePhaseInterface::SupportedCyclePhases listOfCyclePhases);
+
+    virtual void OnResponseGetCyclePhasesDescriptions(QStatus status, const qcc::String& objectPath, const OvenCyclePhaseInterface::CyclePhaseDescriptions& listOfCycleDescriptions, void* context, const char* errorName, const char* errorMessage);
+};
+
+class OvenCyclePhaseCommands : public InterfaceCommands
+{
+  public:
+    OvenCyclePhaseCommands(ControllerSample* sample, DeviceInfoPtr& info, const char* objectPath);
+    virtual ~OvenCyclePhaseCommands();
+
+    virtual void Init();
+
+    OvenCyclePhaseIntfController* GetInterface() { return m_intfController; }
+    static void OnCmdGetCyclePhase(Commands* commands, std::string& cmd);
+
+    static void OnCmdGetSupportedCyclePhases(Commands* commands, std::string& cmd);
+
+    static void OnCmdGetCyclePhasesDescriptions(Commands* commands, std::string& cmd);
+  private:
+    OvenCyclePhaseIntfController* m_intfController;
+    OvenCyclePhaseListener m_listener;
+};
+
+
+#endif /* OVENCYCLEPHASECOMMANDS_H_ */
diff --git a/cpp/samples/BaseSample/Controller/RapidModeCommands.cc b/cpp/samples/BaseSample/Controller/RapidModeCommands.cc
new file mode 100644
index 0000000..9d12cc6
--- /dev/null
+++ b/cpp/samples/BaseSample/Controller/RapidModeCommands.cc
@@ -0,0 +1,107 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#include "RapidModeCommands.h"
+#include "ControllerSample.h"
+
+RapidModeListener::RapidModeListener()
+{
+}
+
+RapidModeListener::~RapidModeListener()
+{
+}
+
+
+void RapidModeListener::RapidModePropertyChanged(const qcc::String& objectPath, const bool rapidMode)
+{
+    cout << __func__ << endl;
+    cout << "# path: " << objectPath << endl;
+    cout << "# rapidMode: " << rapidMode << endl;
+}
+
+
+void RapidModeListener::OnGetRapidModePropertyCallback(QStatus status, const qcc::String& objectPath, const bool rapidMode, void* context)
+{
+    cout << __func__ << endl;
+    cout << "# status: " << QCC_StatusText(status) << endl;
+    cout << "# path: " << objectPath << endl;
+    cout << "# rapidMode: " << rapidMode << endl;
+}
+
+void RapidModeListener::OnSetRapidModePropertyCallback(QStatus status, const qcc::String& objectPath, void* context)
+{
+    cout << __func__ << endl;
+    cout << "# status: " << QCC_StatusText(status) << endl;
+    cout << "# path: " << objectPath << endl;
+}
+
+RapidModeCommands::RapidModeCommands(ControllerSample* sample, DeviceInfoPtr& info, const char* objectPath)
+: InterfaceCommands(sample, info, objectPath),
+  m_intfController(NULL)
+{
+}
+
+RapidModeCommands::~RapidModeCommands()
+{
+
+}
+
+void RapidModeCommands::Init()
+{
+    if (!m_intfController) {
+        HaeInterface* haeInterface = m_sample->CreateInterface(RAPID_MODE_INTERFACE, m_deviceInfo->GetBusName(), m_objectPath, m_deviceInfo->GetSessionId(), m_listener);
+        if (!haeInterface) {
+            cout << "Interface creation failed." << endl;
+            return;
+        }
+
+        m_intfController = static_cast<RapidModeIntfController*>(haeInterface);
+    }
+    RegisterCommand(&RapidModeCommands::OnCmdGetRapidMode, "grm", "get rapidMode");
+    RegisterCommand(&RapidModeCommands::OnCmdSetRapidMode, "srm", "set rapidMode (use 'scs <0/1>'");
+    PrintCommands();
+}
+
+
+void RapidModeCommands::OnCmdGetRapidMode(Commands* commands, std::string& cmd)
+{
+    RapidModeIntfController* intfController = static_cast<RapidModeCommands*>(commands)->GetInterface();
+
+    if (!intfController) {
+        cout << "Interface is not exist." << endl;
+        return;
+    }
+    intfController->GetRapidMode();
+}
+
+void RapidModeCommands::OnCmdSetRapidMode(Commands* commands, std::string& cmd)
+{
+    RapidModeIntfController* intfController = static_cast<RapidModeCommands*>(commands)->GetInterface();
+
+    if (!intfController) {
+        cout << "Interface is not exist." << endl;
+        return;
+    }
+
+    int rapidMode = strtol(cmd.c_str(), NULL,10);
+    cout << "set rapid mode: mode : " << rapidMode <<endl;
+    if(rapidMode != 1 && rapidMode != 0) {
+        cout << "invalid argument " << endl;
+        return;
+    }
+    intfController->SetRapidMode(rapidMode);
+}
diff --git a/cpp/samples/BaseSample/Controller/RapidModeCommands.h b/cpp/samples/BaseSample/Controller/RapidModeCommands.h
new file mode 100644
index 0000000..7c18b0c
--- /dev/null
+++ b/cpp/samples/BaseSample/Controller/RapidModeCommands.h
@@ -0,0 +1,57 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#ifndef RAPIDMODECOMMANDS_H_
+#define RAPIDMODECOMMANDS_H_
+
+#include "InterfaceCommands.h"
+#include <alljoyn/hae/interfaces/operation/RapidModeIntfController.h>
+#include <alljoyn/hae/interfaces/operation/RapidModeIntfControllerListener.h>
+
+class ControllerSample;
+
+using namespace ajn;
+using namespace services;
+
+class RapidModeListener : public RapidModeIntfControllerListener{
+  public:
+    RapidModeListener();
+    virtual ~RapidModeListener();
+    virtual void RapidModePropertyChanged(const qcc::String& objectPath, const bool rapidMode);
+    virtual void OnGetRapidModePropertyCallback(QStatus status, const qcc::String& objectPath, const bool rapidMode, void* context);
+    virtual void OnSetRapidModePropertyCallback(QStatus status, const qcc::String& objectPath, void* context);
+
+};
+
+class RapidModeCommands : public InterfaceCommands
+{
+  public:
+    RapidModeCommands(ControllerSample* sample, DeviceInfoPtr& info, const char* objectPath);
+    virtual ~RapidModeCommands();
+
+    virtual void Init();
+
+    RapidModeIntfController* GetInterface() { return m_intfController; }
+    static void OnCmdGetRapidMode(Commands* commands, std::string& cmd);
+    static void OnCmdSetRapidMode(Commands* commands, std::string& cmd);
+
+  private:
+    RapidModeIntfController* m_intfController;
+    RapidModeListener m_listener;
+};
+
+
+#endif /* RAPIDMODECOMMANDS_H_ */
diff --git a/cpp/samples/BaseSample/Controller/RemoteControllabilityCommands.cc b/cpp/samples/BaseSample/Controller/RemoteControllabilityCommands.cc
new file mode 100644
index 0000000..bdb66ec
--- /dev/null
+++ b/cpp/samples/BaseSample/Controller/RemoteControllabilityCommands.cc
@@ -0,0 +1,85 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#include "RemoteControllabilityCommands.h"
+#include "ControllerSample.h"
+
+RemoteControllabilityListener::RemoteControllabilityListener()
+{
+}
+
+RemoteControllabilityListener::~RemoteControllabilityListener()
+{
+}
+
+
+void RemoteControllabilityListener::IsControllablePropertyChanged(const qcc::String& objectPath, const bool isControllable)
+{
+    cout << __func__ << endl;
+    cout << "# path: " << objectPath << endl;
+    cout << "# isControllable: " << isControllable << endl;
+}
+
+
+void RemoteControllabilityListener::GetIsControllablePropertyCallback(QStatus status, const qcc::String& objectPath, const bool isControllable, void* context)
+{
+    cout << __func__ << endl;
+    cout << "# status: " << QCC_StatusText(status) << endl;
+    cout << "# path: " << objectPath << endl;
+    cout << "# isControllable: " << isControllable<< endl;
+}
+
+
+RemoteControllabilityCommands::RemoteControllabilityCommands(ControllerSample* sample, DeviceInfoPtr& info, const char* objectPath)
+: InterfaceCommands(sample, info, objectPath),
+  m_intfController(NULL)
+{
+}
+
+RemoteControllabilityCommands::~RemoteControllabilityCommands()
+{
+
+}
+
+void RemoteControllabilityCommands::Init()
+{
+    if (!m_intfController) {
+        HaeInterface* haeInterface = m_sample->CreateInterface(REMOTE_CONTROLLABILITY_INTERFACE, m_deviceInfo->GetBusName(), m_objectPath, m_deviceInfo->GetSessionId(), m_listener);
+        if (!haeInterface) {
+            cout << "Interface creation failed." << endl;
+            return;
+        }
+
+        m_intfController = static_cast<RemoteControllabilityIntfController*>(haeInterface);
+    }
+
+    RegisterCommand(&RemoteControllabilityCommands::OnCmdGetIsControllable, "grc", "get isControllable");
+    PrintCommands();
+}
+
+
+void RemoteControllabilityCommands::OnCmdGetIsControllable(Commands* commands, std::string& cmd)
+{
+    RemoteControllabilityIntfController* intfController = static_cast<RemoteControllabilityCommands*>(commands)->GetInterface();
+
+    if (!intfController) {
+        cout << "Interface is not exist." << endl;
+        return;
+    }
+
+    intfController->GetIsControllable();
+}
+
diff --git a/cpp/samples/BaseSample/Controller/RemoteControllabilityCommands.h b/cpp/samples/BaseSample/Controller/RemoteControllabilityCommands.h
new file mode 100644
index 0000000..17f575f
--- /dev/null
+++ b/cpp/samples/BaseSample/Controller/RemoteControllabilityCommands.h
@@ -0,0 +1,55 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#ifndef REMOTECONTROLLABILITYCOMMANDS_H_
+#define REMOTECONTROLLABILITYCOMMANDS_H_
+
+#include "InterfaceCommands.h"
+#include <alljoyn/hae/interfaces/operation/RemoteControllabilityIntfController.h>
+#include <alljoyn/hae/interfaces/operation/RemoteControllabilityIntfControllerListener.h>
+
+class ControllerSample;
+
+using namespace ajn;
+using namespace services;
+
+class RemoteControllabilityListener : public RemoteControllabilityIntfControllerListener{
+  public:
+    RemoteControllabilityListener();
+    virtual ~RemoteControllabilityListener();
+    virtual void IsControllablePropertyChanged(const qcc::String& objectPath, const bool isControllable);
+    virtual void GetIsControllablePropertyCallback(QStatus status, const qcc::String& objectPath, const bool isControllable, void* context);
+};
+
+class RemoteControllabilityCommands : public InterfaceCommands
+{
+  public:
+    RemoteControllabilityCommands(ControllerSample* sample, DeviceInfoPtr& info, const char* objectPath);
+    virtual ~RemoteControllabilityCommands();
+
+    virtual void Init();
+
+    RemoteControllabilityIntfController* GetInterface() { return m_intfController; }
+    static void OnCmdGetIsControllable(Commands* commands, std::string& cmd);
+    //static void OnCmdSetIsClosed(Commands* commands, std::string& cmd);
+
+  private:
+    RemoteControllabilityIntfController* m_intfController;
+    RemoteControllabilityListener m_listener;
+};
+
+
+#endif /* REMOTECONTROLLABILITYCOMMANDS_H_ */
diff --git a/cpp/samples/BaseSample/Controller/SoilLevelCommands.cc b/cpp/samples/BaseSample/Controller/SoilLevelCommands.cc
new file mode 100644
index 0000000..c05d3ab
--- /dev/null
+++ b/cpp/samples/BaseSample/Controller/SoilLevelCommands.cc
@@ -0,0 +1,169 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#include "SoilLevelCommands.h"
+#include "ControllerSample.h"
+
+SoilLevelListener::SoilLevelListener()
+{
+}
+
+SoilLevelListener::~SoilLevelListener()
+{
+}
+
+
+void SoilLevelListener::MaxLevelPropertyChanged(const qcc::String& objectPath, const uint8_t maxLevel)
+{
+    cout << __func__ << endl;
+    cout << "# path: " << objectPath << endl;
+    cout << "# maxLevel: " << (int)maxLevel << endl;
+}
+
+
+void SoilLevelListener::GetMaxLevelPropertyCallback(QStatus status, const qcc::String& objectPath, const uint8_t maxLevel, void* context)
+{
+    cout << "# "<< __func__ << endl;
+    cout << "# status: " << QCC_StatusText(status) << endl;
+    cout << "# objectPath: " << objectPath << endl;
+    cout << "# maxLevel: " << (int)maxLevel << endl;
+}
+
+void SoilLevelListener::GetTargetLevelPropertyCallback(QStatus status, const qcc::String& objectPath, const uint8_t targetLevel, void* context)
+{
+    cout << "# "<< __func__ << endl;
+    cout << "# status: " << QCC_StatusText(status) << endl;
+    cout << "# objectPath: " << objectPath << endl;
+    cout << "# targetLevel: " << (int)targetLevel << endl;
+}
+
+void SoilLevelListener::SetTargetLevelPropertyCallback(QStatus status, const qcc::String& objectPath, void* context)
+{
+    cout << "# "<< __func__ << endl;
+    cout << "# status: " << QCC_StatusText(status) << endl;
+    cout << "# objectPath: " << objectPath << endl;
+}
+
+void SoilLevelListener::GetSelectableLevelsPropertyCallback(QStatus status, const qcc::String& objectPath, const std::vector<uint8_t> selectableLevels, void* context)
+{
+    cout << "# "<< __func__ << endl;
+    cout << "# status: " << QCC_StatusText(status) << endl;
+    cout << "# objectPath: " << objectPath << endl;
+    cout << "# selectable levels: " << endl;
+    for (size_t i = 0; i < selectableLevels.size(); ++i) {
+        cout << (int)selectableLevels[i] << endl;
+    }
+}
+
+void SoilLevelListener::TargetLevelPropertyChanged(const qcc::String& objectPath, const uint8_t targetLevel)
+{
+    cout << "# "<< __func__ << endl;
+    cout << "# objectPath: " << objectPath << endl;
+    cout << "# targetLevel: " << (int)targetLevel << endl;
+}
+
+void SoilLevelListener::SelectableLevelsPropertyChanged(const qcc::String& objectPath, const std::vector<uint8_t> selectableLevels)
+{
+    cout << "# "<< __func__ << endl;
+    cout << "# objectPath: " << objectPath << endl;
+    for (size_t i = 0; i < selectableLevels.size(); ++i) {
+        cout << (int)selectableLevels[i] << endl;
+    }
+}
+
+
+
+SoilLevelCommands::SoilLevelCommands(ControllerSample* sample, DeviceInfoPtr& info, const char* objectPath)
+: InterfaceCommands(sample, info, objectPath),
+  m_intfController(NULL)
+{
+}
+
+SoilLevelCommands::~SoilLevelCommands()
+{
+
+}
+
+void SoilLevelCommands::Init()
+{
+    if (!m_intfController) {
+        HaeInterface* haeInterface = m_sample->CreateInterface(SOIL_LEVEL_INTERFACE, m_deviceInfo->GetBusName(), m_objectPath, m_deviceInfo->GetSessionId(), m_listener);
+        if (!haeInterface) {
+            cout << "Interface creation failed." << endl;
+            return;
+        }
+
+        m_intfController = static_cast<SoilLevelIntfController*>(haeInterface);
+    }
+
+    RegisterCommand(&SoilLevelCommands::OnCmdGetMaxLevel, "gml", "get max soil level");
+    RegisterCommand(&SoilLevelCommands::OnCmdGetTargetLevel, "gtl", "get target soil level");
+    RegisterCommand(&SoilLevelCommands::OnCmdSetTargetLevel, "stl", "set target soil level");
+    RegisterCommand(&SoilLevelCommands::OnCmdGetSelectableLevels, "gsl", "get selectable levels");
+    PrintCommands();
+}
+
+
+void SoilLevelCommands::OnCmdGetMaxLevel(Commands* commands, std::string& cmd)
+{
+    SoilLevelIntfController* intfController = static_cast<SoilLevelCommands*>(commands)->GetInterface();
+
+    if (!intfController) {
+        cout << "Interface is not exist." << endl;
+        return;
+    }
+    intfController->GetMaxLevel();
+}
+
+void SoilLevelCommands::OnCmdGetSelectableLevels(Commands* commands, std::string& cmd)
+{
+    SoilLevelIntfController* intfController = static_cast<SoilLevelCommands*>(commands)->GetInterface();
+
+    if (!intfController) {
+        cout << "Interface is not exist." << endl;
+        return;
+    }
+
+    intfController->GetSelectableLevels();
+}
+void SoilLevelCommands::OnCmdGetTargetLevel(Commands* commands, std::string& cmd)
+{
+    SoilLevelIntfController* intfController = static_cast<SoilLevelCommands*>(commands)->GetInterface();
+
+    if (!intfController) {
+        cout << "Interface is not exist." << endl;
+        return;
+    }
+
+    intfController->GetTargetLevel();
+}
+void SoilLevelCommands::OnCmdSetTargetLevel(Commands* commands, std::string& cmd)
+{
+    SoilLevelIntfController* intfController = static_cast<SoilLevelCommands*>(commands)->GetInterface();
+
+    if (!intfController) {
+        cout << "Interface is not exist." << endl;
+        return;
+    }
+    int level = strtol(cmd.c_str(), NULL, 10);
+    if (level < 0 || level >= 256) {
+        cout << "Input argument is wrong." << endl;
+        return;
+    }
+
+    intfController->SetTargetLevel(level);
+}
+
diff --git a/cpp/samples/BaseSample/Controller/SoilLevelCommands.h b/cpp/samples/BaseSample/Controller/SoilLevelCommands.h
new file mode 100644
index 0000000..60a19db
--- /dev/null
+++ b/cpp/samples/BaseSample/Controller/SoilLevelCommands.h
@@ -0,0 +1,69 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#ifndef SOILLEVELCOMMANDS_H_
+#define SOILLEVELCOMMANDS_H_
+
+#include "InterfaceCommands.h"
+#include <alljoyn/hae/interfaces/operation/SoilLevelIntfController.h>
+#include <alljoyn/hae/interfaces/operation/SoilLevelIntfControllerListener.h>
+
+class ControllerSample;
+
+using namespace ajn;
+using namespace services;
+
+class SoilLevelListener : public SoilLevelIntfControllerListener{
+  public:
+    SoilLevelListener();
+    virtual ~SoilLevelListener();
+    virtual void GetMaxLevelPropertyCallback(QStatus status, const qcc::String& objectPath, const uint8_t maxLevel, void* context);
+
+    virtual void GetTargetLevelPropertyCallback(QStatus status, const qcc::String& objectPath, const uint8_t targetLevel, void* context);
+
+    virtual void SetTargetLevelPropertyCallback(QStatus status, const qcc::String& objectPath, void* context);
+
+    virtual void GetSelectableLevelsPropertyCallback(QStatus status, const qcc::String& objectPath, const std::vector<uint8_t> selectableLevels, void* context);
+
+    virtual void MaxLevelPropertyChanged(const qcc::String& objectPath, const uint8_t maxLevel);
+
+    virtual void TargetLevelPropertyChanged(const qcc::String& objectPath, const uint8_t targetLevel);
+
+    virtual void SelectableLevelsPropertyChanged(const qcc::String& objectPath, const std::vector<uint8_t> selectableLevels);
+
+};
+
+class SoilLevelCommands : public InterfaceCommands
+{
+  public:
+    SoilLevelCommands(ControllerSample* sample, DeviceInfoPtr& info, const char* objectPath);
+    virtual ~SoilLevelCommands();
+
+    virtual void Init();
+
+    SoilLevelIntfController* GetInterface() { return m_intfController; }
+    static void OnCmdGetMaxLevel(Commands* commands, std::string& cmd);
+    static void OnCmdGetTargetLevel(Commands* commands, std::string& cmd);
+    static void OnCmdSetTargetLevel(Commands* commands, std::string& cmd);
+    static void OnCmdGetSelectableLevels(Commands* commands, std::string& cmd);
+
+  private:
+    SoilLevelIntfController* m_intfController;
+    SoilLevelListener m_listener;
+};
+
+
+#endif /* SOILLEVELCOMMANDS_H_ */
diff --git a/cpp/samples/BaseSample/Controller/SpinSpeedLevelCommands.cc b/cpp/samples/BaseSample/Controller/SpinSpeedLevelCommands.cc
new file mode 100644
index 0000000..a9d246d
--- /dev/null
+++ b/cpp/samples/BaseSample/Controller/SpinSpeedLevelCommands.cc
@@ -0,0 +1,169 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#include "SpinSpeedLevelCommands.h"
+#include "ControllerSample.h"
+
+SpinSpeedLevelListener::SpinSpeedLevelListener()
+{
+}
+
+SpinSpeedLevelListener::~SpinSpeedLevelListener()
+{
+}
+
+
+void SpinSpeedLevelListener::MaxLevelPropertyChanged(const qcc::String& objectPath, const uint8_t maxLevel)
+{
+    cout << __func__ << endl;
+    cout << "path: " << objectPath << endl;
+    cout << "maxLevel: " << (int)maxLevel << endl;
+}
+
+
+void SpinSpeedLevelListener::GetMaxLevelPropertyCallback(QStatus status, const qcc::String& objectPath, const uint8_t maxLevel, void* context)
+{
+    cout << "# "<< __func__ << endl;
+    cout << "# status: " << QCC_StatusText(status) << endl;
+    cout << "objectPath: " << objectPath << endl;
+    cout << "maxLevel: " << (int)maxLevel << endl;
+}
+
+void SpinSpeedLevelListener::GetTargetLevelPropertyCallback(QStatus status, const qcc::String& objectPath, const uint8_t targetLevel, void* context)
+{
+    cout << "# "<< __func__ << endl;
+    cout << "# status: " << QCC_StatusText(status) << endl;
+    cout << "objectPath: " << objectPath << endl;
+    cout << "targetLevel: " << (int)targetLevel << endl;
+}
+
+void SpinSpeedLevelListener::SetTargetLevelPropertyCallback(QStatus status, const qcc::String& objectPath, void* context)
+{
+    cout << "# "<< __func__ << endl;
+    cout << "# status: " << QCC_StatusText(status) << endl;
+    cout << "objectPath: " << objectPath << endl;
+}
+
+void SpinSpeedLevelListener::GetSelectableLevelsPropertyCallback(QStatus status, const qcc::String& objectPath, const std::vector<uint8_t> selectableLevels, void* context)
+{
+    cout << "# "<< __func__ << endl;
+    cout << "# status: " << QCC_StatusText(status) << endl;
+    cout << "objectPath: " << objectPath << endl;
+    cout << "selectable levels: " << endl;
+    for (size_t i = 0; i < selectableLevels.size(); ++i) {
+        cout << (int)selectableLevels[i] << endl;
+    }
+}
+
+void SpinSpeedLevelListener::TargetLevelPropertyChanged(const qcc::String& objectPath, const uint8_t targetLevel)
+{
+    cout << "# "<< __func__ << endl;
+    cout << "objectPath: " << objectPath << endl;
+    cout << "targetLevel: " << (int)targetLevel << endl;
+}
+
+void SpinSpeedLevelListener::SelectableLevelsPropertyChanged(const qcc::String& objectPath, const std::vector<uint8_t> selectableLevels)
+{
+    cout << "# "<< __func__ << endl;
+    cout << "objectPath: " << objectPath << endl;
+    for (size_t i = 0; i < selectableLevels.size(); ++i) {
+        cout << (int)selectableLevels[i] << endl;
+    }
+}
+
+
+
+SpinSpeedLevelCommands::SpinSpeedLevelCommands(ControllerSample* sample, DeviceInfoPtr& info, const char* objectPath)
+: InterfaceCommands(sample, info, objectPath),
+  m_intfController(NULL)
+{
+}
+
+SpinSpeedLevelCommands::~SpinSpeedLevelCommands()
+{
+
+}
+
+void SpinSpeedLevelCommands::Init()
+{
+    if (!m_intfController) {
+        HaeInterface* haeInterface = m_sample->CreateInterface(SPIN_SPEED_LEVEL_INTERFACE, m_deviceInfo->GetBusName(), m_objectPath, m_deviceInfo->GetSessionId(), m_listener);
+        if (!haeInterface) {
+            cout << "Interface creation failed." << endl;
+            return;
+        }
+
+        m_intfController = static_cast<SpinSpeedLevelIntfController*>(haeInterface);
+    }
+
+    RegisterCommand(&SpinSpeedLevelCommands::OnCmdGetMaxLevel, "gml", "get max spin speed level");
+    RegisterCommand(&SpinSpeedLevelCommands::OnCmdGetTargetLevel, "gtl", "get target spin speed level");
+    RegisterCommand(&SpinSpeedLevelCommands::OnCmdSetTargetLevel, "stl", "set target spin speed level");
+    RegisterCommand(&SpinSpeedLevelCommands::OnCmdGetSelectableLevels, "gsl", "get selectable levels");
+    PrintCommands();
+}
+
+
+void SpinSpeedLevelCommands::OnCmdGetMaxLevel(Commands* commands, std::string& cmd)
+{
+    SpinSpeedLevelIntfController* intfController = static_cast<SpinSpeedLevelCommands*>(commands)->GetInterface();
+
+    if (!intfController) {
+        cout << "Interface is not exist." << endl;
+        return;
+    }
+    intfController->GetMaxLevel();
+}
+
+void SpinSpeedLevelCommands::OnCmdGetSelectableLevels(Commands* commands, std::string& cmd)
+{
+    SpinSpeedLevelIntfController* intfController = static_cast<SpinSpeedLevelCommands*>(commands)->GetInterface();
+
+    if (!intfController) {
+        cout << "Interface is not exist." << endl;
+        return;
+    }
+
+    intfController->GetSelectableLevels();
+}
+void SpinSpeedLevelCommands::OnCmdGetTargetLevel(Commands* commands, std::string& cmd)
+{
+    SpinSpeedLevelIntfController* intfController = static_cast<SpinSpeedLevelCommands*>(commands)->GetInterface();
+
+    if (!intfController) {
+        cout << "Interface is not exist." << endl;
+        return;
+    }
+
+    intfController->GetTargetLevel();
+}
+void SpinSpeedLevelCommands::OnCmdSetTargetLevel(Commands* commands, std::string& cmd)
+{
+    SpinSpeedLevelIntfController* intfController = static_cast<SpinSpeedLevelCommands*>(commands)->GetInterface();
+
+    if (!intfController) {
+        cout << "Interface is not exist." << endl;
+        return;
+    }
+    int level = strtol(cmd.c_str(), NULL, 10);
+    if (level < 0 || level >= 256) {
+        cout << "Input argument is wrong." << endl;
+        return;
+    }
+
+    intfController->SetTargetLevel(level);
+}
+
diff --git a/cpp/samples/BaseSample/Controller/SpinSpeedLevelCommands.h b/cpp/samples/BaseSample/Controller/SpinSpeedLevelCommands.h
new file mode 100644
index 0000000..0357667
--- /dev/null
+++ b/cpp/samples/BaseSample/Controller/SpinSpeedLevelCommands.h
@@ -0,0 +1,69 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#ifndef SPINSPEEDLEVELCOMMANDS_H_
+#define SPINSPEEDLEVELCOMMANDS_H_
+
+#include "InterfaceCommands.h"
+#include <alljoyn/hae/interfaces/operation/SpinSpeedLevelIntfController.h>
+#include <alljoyn/hae/interfaces/operation/SpinSpeedLevelIntfControllerListener.h>
+
+class ControllerSample;
+
+using namespace ajn;
+using namespace services;
+
+class SpinSpeedLevelListener : public SpinSpeedLevelIntfControllerListener{
+  public:
+    SpinSpeedLevelListener();
+    virtual ~SpinSpeedLevelListener();
+    virtual void GetMaxLevelPropertyCallback(QStatus status, const qcc::String& objectPath, const uint8_t maxLevel, void* context);
+
+    virtual void GetTargetLevelPropertyCallback(QStatus status, const qcc::String& objectPath, const uint8_t targetLevel, void* context);
+
+    virtual void SetTargetLevelPropertyCallback(QStatus status, const qcc::String& objectPath, void* context);
+
+    virtual void GetSelectableLevelsPropertyCallback(QStatus status, const qcc::String& objectPath, const std::vector<uint8_t> selectableLevels, void* context);
+
+    virtual void MaxLevelPropertyChanged(const qcc::String& objectPath, const uint8_t maxLevel);
+
+    virtual void TargetLevelPropertyChanged(const qcc::String& objectPath, const uint8_t targetLevel);
+
+    virtual void SelectableLevelsPropertyChanged(const qcc::String& objectPath, const std::vector<uint8_t> selectableLevels);
+
+};
+
+class SpinSpeedLevelCommands : public InterfaceCommands
+{
+  public:
+    SpinSpeedLevelCommands(ControllerSample* sample, DeviceInfoPtr& info, const char* objectPath);
+    virtual ~SpinSpeedLevelCommands();
+
+    virtual void Init();
+
+    SpinSpeedLevelIntfController* GetInterface() { return m_intfController; }
+    static void OnCmdGetMaxLevel(Commands* commands, std::string& cmd);
+    static void OnCmdGetTargetLevel(Commands* commands, std::string& cmd);
+    static void OnCmdSetTargetLevel(Commands* commands, std::string& cmd);
+    static void OnCmdGetSelectableLevels(Commands* commands, std::string& cmd);
+
+  private:
+    SpinSpeedLevelIntfController* m_intfController;
+    SpinSpeedLevelListener m_listener;
+};
+
+
+#endif /* SPINSPEEDLEVELCOMMANDS_H_ */
diff --git a/cpp/samples/BaseSample/Controller/TimerCommands.cc b/cpp/samples/BaseSample/Controller/TimerCommands.cc
new file mode 100644
index 0000000..64a79ec
--- /dev/null
+++ b/cpp/samples/BaseSample/Controller/TimerCommands.cc
@@ -0,0 +1,242 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#include "TimerCommands.h"
+#include "ControllerSample.h"
+
+TimerListener::TimerListener()
+{
+}
+
+TimerListener::~TimerListener()
+{
+}
+void TimerListener::OnResponseGetReferenceTimer(QStatus status, const qcc::String& objectPath, int32_t& time, void* context)
+{
+    cout << "# TimerListener::OnResponseGetReferenceTimer" << endl;
+    cout << "# status: " << QCC_StatusText(status) << endl;
+    cout << "# time: " << (int)time << endl;
+}
+void TimerListener::OnResponseGetTargetTimeToStart(QStatus status, const qcc::String& objectPath, int32_t& time, void* context)
+{
+    cout << "# TimerListener::OnResponseGetTargetTimeToStart" << endl;
+    cout << "# status: " << QCC_StatusText(status) << endl;
+    cout << "# time: " << (int)time << endl;
+}
+void TimerListener::OnResponseGetTargetTimeToStop(QStatus status, const qcc::String& objectPath, int32_t& time, void* context)
+{
+    cout << "# TimerListener::OnResponseGetTargetTimeToStop" << endl;
+    cout << "# status: " << QCC_StatusText(status) << endl;
+    cout << "# time: " << (int)time << endl;
+}
+void TimerListener::OnResponseGetEstimatedTimeToEnd(QStatus status, const qcc::String& objectPath, int32_t& time, void* context)
+{
+    cout << "# TimerListener::OnResponseGetEstimatedTimeToEnd" << endl;
+    cout << "# status: " << QCC_StatusText(status) << endl;
+    cout << "# time: " << (int)time << endl;
+}
+void TimerListener::OnResponseGetRunningTime(QStatus status, const qcc::String& objectPath, int32_t& time, void* context)
+{
+    cout << "# TimerListener::OnResponseGetRunningTime" << endl;
+    cout << "# status: " << QCC_StatusText(status) << endl;
+    cout << "# time: " << (int)time << endl;
+}
+void TimerListener::OnResponseGetTargetDuration(QStatus status, const qcc::String& objectPath, int32_t& time, void* context)
+{
+    cout << "# TimerListener::OnResponseGetTargetDuration" << endl;
+    cout << "# status: " << QCC_StatusText(status) << endl;
+    cout << "# time: " << (int)time << endl;
+}
+void TimerListener::OnReferenceTimerPropertyChanged(const qcc::String& objectPath, int32_t time)
+{
+    cout << "# TimerListener::OnReferenceTimerPropertyChanged" << endl;
+    cout << "# time: " << (int)time << endl;
+}
+void TimerListener::OnTargetTimeToStartPropertyChanged(const qcc::String& objectPath, int32_t time)
+{
+    cout << "# TimerListener::OnTargetTimeToStartPropertyChanged" << endl;
+    cout << "# time: " << (int)time << endl;
+}
+void TimerListener::OnTargetTimeToStopPropertyChanged(const qcc::String& objectPath, int32_t time)
+{
+    cout << "# TimerListener::OnTargetTimeToStopPropertyChanged" << endl;
+    cout << "# time: " << (int)time << endl;
+}
+void TimerListener::OnEstimatedTimeToEndPropertyChanged(const qcc::String& objectPath, int32_t time)
+{
+    cout << "# TimerListener::OnEstimatedTimeToEndPropertyChanged" << endl;
+    cout << "# time: " << (int)time << endl;
+}
+void TimerListener::OnRunningTimePropertyChanged(const qcc::String& objectPath, int32_t time)
+{
+    cout << "TimerListener::OnRunningTimePropertyChanged" << endl;
+    cout << "time: " << (int)time << endl;
+}
+void TimerListener::OnTargetDurationPropertyChanged(const qcc::String& objectPath, int32_t time)
+{
+    cout << "# TimerListener::OnTargetDurationPropertyChanged" << endl;
+    cout << "# time: " << (int)time << endl;
+}
+
+void TimerListener::OnResponseSetTargetTimerToStart(QStatus status, const qcc::String& objectPath, void* context, const char* errorName, const char* errorMessage)
+{
+    cout << "# TimerListener::OnResponseSetTargetTimerToStart" << endl;
+    cout << "# Status: " << QCC_StatusText(status) << endl;
+    if(status != ER_OK)
+    {
+        cout << "# error name: " << errorName << endl;
+        cout << "# error mess: " << errorMessage << endl;
+    }
+}
+void TimerListener::OnResponseSetTargetTimerToStop(QStatus status, const qcc::String& objectPath, void* context, const char* errorName, const char* errorMessage)
+{
+    cout << "# TimerListener::OnResponseSetTargetTimerToStop" << endl;
+    cout << "# Status: " << QCC_StatusText(status) << endl;
+    if(status != ER_OK)
+    {
+        cout << "error name: " << errorName << endl;
+        cout << "error mess: " << errorMessage << endl;
+    }
+}
+
+
+
+
+
+TimerCommands::TimerCommands(ControllerSample* sample, DeviceInfoPtr& info, const char* objectPath)
+: InterfaceCommands(sample, info, objectPath),
+  m_intfController(NULL)
+{
+}
+
+TimerCommands::~TimerCommands()
+{
+
+}
+
+void TimerCommands::Init()
+{
+    if (!m_intfController) {
+        HaeInterface* haeInterface = m_sample->CreateInterface(TIMER_INTERFACE, m_deviceInfo->GetBusName(), m_objectPath, m_deviceInfo->GetSessionId(), m_listener);
+        if (!haeInterface) {
+            cout << "Interface creation failed." << endl;
+            return;
+        }
+
+        m_intfController = static_cast<TimerIntfController*>(haeInterface);
+    }
+
+    RegisterCommand(&TimerCommands::OnCmdGetReferenceTimer, "grt", "get reference timer");
+    RegisterCommand(&TimerCommands::OnCmdGetTargetTimeToStart, "gttsa", "get target time to start");
+    RegisterCommand(&TimerCommands::OnCmdGetTargetTimeToStop, "gttsp", "get target time to stop");
+    RegisterCommand(&TimerCommands::OnCmdGetEstimatedTimeToEnd, "gette", "get estimated time to end");
+    RegisterCommand(&TimerCommands::OnCmdGetRunningTime, "grunt", "get running time");
+    RegisterCommand(&TimerCommands::OnCmdGetTargetDuration, "gtd", "get target duration");
+    RegisterCommand(&TimerCommands::OnCmdSetTargetTimeToStart, "ststart", "Set target time to start");
+    RegisterCommand(&TimerCommands::OnCmdSetTargetTimeToStop, "ststop", "set target time to stop");
+    PrintCommands();
+}
+
+void TimerCommands::OnCmdGetReferenceTimer(Commands* commands, std::string& cmd)
+{
+    TimerIntfController* intfController = static_cast<TimerCommands*>(commands)->GetInterface();
+
+    if (!intfController) {
+        cout << "Interface is not exist." << endl;
+        return;
+    }
+
+    intfController->GetReferenceTimer();
+}
+void TimerCommands::OnCmdGetTargetTimeToStart(Commands* commands, std::string& cmd)
+{
+    TimerIntfController* intfController = static_cast<TimerCommands*>(commands)->GetInterface();
+
+    if (!intfController) {
+        cout << "Interface is not exist." << endl;
+        return;
+    }
+
+    intfController->GetTargetTimeToStart();
+}
+void TimerCommands::OnCmdGetTargetTimeToStop(Commands* commands, std::string& cmd)
+{
+    TimerIntfController* intfController = static_cast<TimerCommands*>(commands)->GetInterface();
+
+    if (!intfController) {
+        cout << "Interface is not exist." << endl;
+        return;
+    }
+
+    intfController->GetTargetTimeToStop();
+}
+void TimerCommands::OnCmdGetEstimatedTimeToEnd(Commands* commands, std::string& cmd)
+{
+    TimerIntfController* intfController = static_cast<TimerCommands*>(commands)->GetInterface();
+
+    if (!intfController) {
+        cout << "Interface is not exist." << endl;
+        return;
+    }
+
+    intfController->GetEstimatedTimeToEnd();
+}
+void TimerCommands::OnCmdGetRunningTime(Commands* commands, std::string& cmd)
+{
+    TimerIntfController* intfController = static_cast<TimerCommands*>(commands)->GetInterface();
+
+    if (!intfController) {
+        cout << "Interface is not exist." << endl;
+        return;
+    }
+
+    intfController->GetRunningTime();
+}
+void TimerCommands::OnCmdGetTargetDuration(Commands* commands, std::string& cmd)
+{
+    TimerIntfController* intfController = static_cast<TimerCommands*>(commands)->GetInterface();
+
+    if (!intfController) {
+        cout << "Interface is not exist." << endl;
+        return;
+    }
+
+    intfController->GetTargetDuration();
+}
+
+void TimerCommands::OnCmdSetTargetTimeToStart(Commands* commands, std::string& cmd)
+{
+    TimerIntfController* intfController = static_cast<TimerCommands*>(commands)->GetInterface();
+
+    if (!intfController) {
+        cout << "Interface is not exist." << endl;
+        return;
+    }
+    int time = strtol(cmd.c_str(), NULL, 10);
+    intfController->SetTargetTimeToStart(time);
+}
+
+void TimerCommands::OnCmdSetTargetTimeToStop(Commands* commands, std::string& cmd)
+{
+    TimerIntfController* intfController = static_cast<TimerCommands*>(commands)->GetInterface();
+
+    if (!intfController) {
+        cout << "Interface is not exist." << endl;
+        return;
+    }
+    int time = strtol(cmd.c_str(), NULL, 10);
+    intfController->SetTargetTimeToStop(time);
+}
diff --git a/cpp/samples/BaseSample/Controller/TimerCommands.h b/cpp/samples/BaseSample/Controller/TimerCommands.h
new file mode 100644
index 0000000..743f605
--- /dev/null
+++ b/cpp/samples/BaseSample/Controller/TimerCommands.h
@@ -0,0 +1,77 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#ifndef TIMERCOMMANDS_H_
+#define TIMERCOMMANDS_H_
+
+#include "InterfaceCommands.h"
+#include <alljoyn/hae/interfaces/operation/TimerIntfController.h>
+#include <alljoyn/hae/interfaces/operation/TimerIntfControllerListener.h>
+
+class ControllerSample;
+
+using namespace ajn;
+using namespace services;
+
+class TimerListener : public TimerIntfControllerListener{
+  public:
+    TimerListener();
+    virtual ~TimerListener();
+
+    virtual void OnResponseGetReferenceTimer(QStatus status, const qcc::String& objectPath, int32_t& time, void* context);
+    virtual void OnResponseGetTargetTimeToStart(QStatus status, const qcc::String& objectPath, int32_t& time, void* context);
+    virtual void OnResponseGetTargetTimeToStop(QStatus status, const qcc::String& objectPath, int32_t& time, void* context);
+    virtual void OnResponseGetEstimatedTimeToEnd(QStatus status, const qcc::String& objectPath, int32_t& time, void* context);
+    virtual void OnResponseGetRunningTime(QStatus status, const qcc::String& objectPath, int32_t& time, void* context);
+    virtual void OnResponseGetTargetDuration(QStatus status, const qcc::String& objectPath, int32_t& time, void* context);
+
+    virtual void OnReferenceTimerPropertyChanged(const qcc::String& objectPath, int32_t time);
+    virtual void OnTargetTimeToStartPropertyChanged(const qcc::String& objectPath, int32_t time);
+    virtual void OnTargetTimeToStopPropertyChanged(const qcc::String& objectPath, int32_t time);
+    virtual void OnEstimatedTimeToEndPropertyChanged(const qcc::String& objectPath, int32_t time);
+    virtual void OnRunningTimePropertyChanged(const qcc::String& objectPath, int32_t time);
+    virtual void OnTargetDurationPropertyChanged(const qcc::String& objectPath, int32_t time);
+
+    virtual void OnResponseSetTargetTimerToStart(QStatus status, const qcc::String& objectPath, void* context, const char* errorName, const char* errorMessage);
+    virtual void OnResponseSetTargetTimerToStop(QStatus status, const qcc::String& objectPath, void* context, const char* errorName, const char* errorMessage);
+};
+
+class TimerCommands : public InterfaceCommands
+{
+  public:
+    TimerCommands(ControllerSample* sample, DeviceInfoPtr& info, const char* objectPath);
+    virtual ~TimerCommands();
+
+    virtual void Init();
+
+    TimerIntfController* GetInterface() { return m_intfController; }
+
+    static void OnCmdGetReferenceTimer(Commands* commands, std::string& cmd);
+    static void OnCmdGetTargetTimeToStart(Commands* commands, std::string& cmd);
+    static void OnCmdGetTargetTimeToStop(Commands* commands, std::string& cmd);
+    static void OnCmdGetEstimatedTimeToEnd(Commands* commands, std::string& cmd);
+    static void OnCmdGetRunningTime(Commands* commands, std::string& cmd);
+    static void OnCmdGetTargetDuration(Commands* commands, std::string& cmd);
+    static void OnCmdSetTargetTimeToStart(Commands* commands, std::string& cmd);
+    static void OnCmdSetTargetTimeToStop(Commands* commands, std::string& cmd);
+
+  private:
+    TimerIntfController* m_intfController;
+    TimerListener m_listener;
+};
+
+
+#endif /* TIMERCOMMANDS_H_ */
diff --git a/cpp/samples/BaseSample/Controller/WaterLevelCommands.cc b/cpp/samples/BaseSample/Controller/WaterLevelCommands.cc
new file mode 100644
index 0000000..52aa649
--- /dev/null
+++ b/cpp/samples/BaseSample/Controller/WaterLevelCommands.cc
@@ -0,0 +1,131 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#include "WaterLevelCommands.h"
+#include "ControllerSample.h"
+
+WaterLevelListener::WaterLevelListener()
+{
+}
+
+WaterLevelListener::~WaterLevelListener()
+{
+}
+void WaterLevelListener::OnGetMaxLevelPropertyCallback(QStatus status, const qcc::String& objectPath, const uint8_t value, void* context)
+{
+    cout << "# WaterLevelListener::OnGetMaxLevelPropertyCallback()" << endl;
+    cout << "# status: " << QCC_StatusText(status) << endl;
+    cout << "# Object: " << objectPath << endl;
+    cout << "# Max level: " << (int)value << endl;
+}
+void WaterLevelListener::OnGetSupplySourcePropertyCallback (QStatus status, const qcc::String& objectPath, const WaterLevelInterface::WaterLevelSupplySource value, void* context)
+{
+    cout << "# WaterLevelListener::OnGetSupplySourceLevelPropertyCallback()" << endl;
+    cout << "# status: " << QCC_StatusText(status) << endl;
+    cout << "# Object: " << objectPath << endl;
+    cout << "# Supply Source: " << (int)value << endl;
+}
+void WaterLevelListener::OnGetCurrentLevelPropertyCallback (QStatus status, const qcc::String& objectPath, const uint8_t value, void* context)
+{
+    cout << "# WaterLevelListener::OnGetCurrentLevelPropertyCallback()" << endl;
+    cout << "# status: " << QCC_StatusText(status) << endl;
+    cout << "# Object: " << objectPath << endl;
+    cout << "# Current level: " << (int)value << endl;
+}
+
+void WaterLevelListener::MaxLevelProprtyChanged(const qcc::String& objectPath, const uint8_t value)
+{
+    cout << "# WaterLevelListener.MaxLevelProprtyChanged()" << endl;
+    cout << "# Object: " << objectPath << endl;
+    cout << "# MaxLevel: " << (int)value << endl;
+}
+void WaterLevelListener::CurrentLevelProprtyChanged(const qcc::String& objectPath, const uint8_t value)
+{
+    cout << "# WaterLevelListener.CurrentLevelProprtyChanged()" << endl;
+    cout << "# Object: " << objectPath << endl;
+    cout << "# CurrentLevel: " << (int)value << endl;
+}
+void WaterLevelListener::SupplySourceProprtyChanged(const qcc::String& objectPath, const WaterLevelInterface::WaterLevelSupplySource value)
+{
+    cout << "# WaterLevelListener.SupplySourceProprtyChanged()" << endl;
+    cout << "# Object: " << objectPath << endl;
+    cout << "# SupplySource: " << (int)value << endl;
+}
+
+
+
+WaterLevelCommands::WaterLevelCommands(ControllerSample* sample, DeviceInfoPtr& info, const char* objectPath)
+: InterfaceCommands(sample, info, objectPath),
+  m_intfController(NULL)
+{
+}
+
+WaterLevelCommands::~WaterLevelCommands()
+{
+
+}
+
+void WaterLevelCommands::Init()
+{
+    if (!m_intfController) {
+        HaeInterface* haeInterface = m_sample->CreateInterface(WATER_LEVEL_INTERFACE, m_deviceInfo->GetBusName(), m_objectPath, m_deviceInfo->GetSessionId(), m_listener);
+        if (!haeInterface) {
+            cout << "Interface creation failed." << endl;
+            return;
+        }
+
+        m_intfController = static_cast<WaterLevelIntfController*>(haeInterface);
+    }
+
+    RegisterCommand(&WaterLevelCommands::OnCmdGetMaxLevel, "gml", "get max water level");
+    RegisterCommand(&WaterLevelCommands::OnCmdGetCurrentLevel, "gcl", "get current water level");
+    RegisterCommand(&WaterLevelCommands::OnCmdSetSupplySource, "gsc", "get supply source");
+    PrintCommands();
+}
+
+void WaterLevelCommands::OnCmdGetMaxLevel(Commands* commands, std::string& cmd)
+{
+    WaterLevelIntfController* intfController = static_cast<WaterLevelCommands*>(commands)->GetInterface();
+
+    if (!intfController) {
+        cout << "Interface is not exist." << endl;
+        return;
+    }
+    intfController->GetMaxLevel();
+}
+
+void WaterLevelCommands::OnCmdGetCurrentLevel(Commands* commands, std::string& cmd)
+{
+    WaterLevelIntfController* intfController = static_cast<WaterLevelCommands*>(commands)->GetInterface();
+
+    if (!intfController) {
+        cout << "Interface is not exist." << endl;
+        return;
+    }
+
+    intfController->GetCurrentLevel();
+}
+void WaterLevelCommands::OnCmdSetSupplySource(Commands* commands, std::string& cmd)
+{
+    WaterLevelIntfController* intfController = static_cast<WaterLevelCommands*>(commands)->GetInterface();
+
+    if (!intfController) {
+        cout << "Interface is not exist." << endl;
+        return;
+    }
+
+    intfController->GetSupplySource();
+}
diff --git a/cpp/samples/BaseSample/Controller/WaterLevelCommands.h b/cpp/samples/BaseSample/Controller/WaterLevelCommands.h
new file mode 100644
index 0000000..9272b96
--- /dev/null
+++ b/cpp/samples/BaseSample/Controller/WaterLevelCommands.h
@@ -0,0 +1,61 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#ifndef WATERLEVELCOMMANDS_H_
+#define WATERLEVELCOMMANDS_H_
+
+#include "InterfaceCommands.h"
+#include <alljoyn/hae/interfaces/environment/WaterLevelIntfController.h>
+#include <alljoyn/hae/interfaces/environment/WaterLevelIntfControllerListener.h>
+
+class ControllerSample;
+
+using namespace ajn;
+using namespace services;
+
+class WaterLevelListener : public WaterLevelIntfControllerListener{
+  public:
+    WaterLevelListener();
+    virtual ~WaterLevelListener();
+    virtual void OnGetMaxLevelPropertyCallback(QStatus status, const qcc::String& objectPath, const uint8_t value, void* context);
+    virtual void OnGetSupplySourcePropertyCallback (QStatus status, const qcc::String& objectPath, const WaterLevelInterface::WaterLevelSupplySource value, void* context);
+    virtual void OnGetCurrentLevelPropertyCallback (QStatus status, const qcc::String& objectPath, const uint8_t value, void* context);
+
+    virtual void MaxLevelProprtyChanged(const qcc::String& objectPath, const uint8_t value);
+    virtual void CurrentLevelProprtyChanged(const qcc::String& objectPath, const uint8_t value);
+    virtual void SupplySourceProprtyChanged(const qcc::String& objectPath, const WaterLevelInterface::WaterLevelSupplySource value);
+};
+
+class WaterLevelCommands : public InterfaceCommands
+{
+  public:
+    WaterLevelCommands(ControllerSample* sample, DeviceInfoPtr& info, const char* objectPath);
+    virtual ~WaterLevelCommands();
+
+    virtual void Init();
+
+    WaterLevelIntfController* GetInterface() { return m_intfController; }
+    static void OnCmdGetMaxLevel(Commands* commands, std::string& cmd);
+    static void OnCmdGetCurrentLevel(Commands* commands, std::string& cmd);
+    static void OnCmdSetSupplySource(Commands* commands, std::string& cmd);
+
+  private:
+    WaterLevelIntfController* m_intfController;
+    WaterLevelListener m_listener;
+};
+
+
+#endif /* WATERLEVELCOMMANDS_H_ */
diff --git a/cpp/samples/CookTopControllee/CookTopControllee.cc b/cpp/samples/CookTopControllee/CookTopControllee.cc
new file mode 100644
index 0000000..1bb56bb
--- /dev/null
+++ b/cpp/samples/CookTopControllee/CookTopControllee.cc
@@ -0,0 +1,243 @@
+#include <iostream>
+#include <map>
+
+#include <qcc/Log.h>
+#include <qcc/String.h>
+#include <alljoyn/Init.h>
+#include <alljoyn/version.h>
+#include <alljoyn/hae/DeviceTypeDescription.h>
+#include "ControlleeSample.h"
+#include "HeatingZoneListener.h"
+#include "OvenCyclePhaseListener.h"
+#include "RapidModeListener.h"
+#include <alljoyn/hae/interfaces/operation/HeatingZoneIntfControllee.h>
+#include <alljoyn/hae/interfaces/operation/OvenCyclePhaseIntfControllee.h>
+#include <alljoyn/hae/interfaces/operation/RapidModeIntfControllee.h>
+
+using namespace std;
+using namespace qcc;
+
+class CookTopControllee : public ControlleeSample
+{
+  private:
+    HeatingZoneListener *m_heatingZoneListener;
+    OvenCyclePhaseListener *m_ovenCyclePhaseListener;
+    RapidModeListener *m_rapidModeListener;
+
+    HeatingZoneIntfControllee* m_heatingZoneIntfControllee;
+    OvenCyclePhaseIntfControllee* m_ovenCyclePhaseIntfControllee;
+    RapidModeIntfControllee* m_rapidModeIntfControllee;
+
+  public:
+    CookTopControllee(BusAttachment* bus, HaeAboutData* aboutData);
+    virtual ~CookTopControllee();
+    void CreateInterfaces();
+    void SetInitialProperty();
+};
+
+CookTopControllee::CookTopControllee(BusAttachment* bus, HaeAboutData* aboutData)
+  : ControlleeSample(bus, aboutData), m_heatingZoneIntfControllee(NULL), m_ovenCyclePhaseIntfControllee(NULL), m_rapidModeIntfControllee(NULL)
+{
+    m_heatingZoneListener = new HeatingZoneListener();
+    m_ovenCyclePhaseListener = new OvenCyclePhaseListener();
+    m_rapidModeListener = new RapidModeListener();
+}
+
+CookTopControllee::~CookTopControllee()
+{
+    if(m_heatingZoneListener) {
+        delete m_heatingZoneListener;
+    }
+    if(m_ovenCyclePhaseListener) {
+        delete m_ovenCyclePhaseListener;
+    }
+    if(m_rapidModeListener) {
+        delete m_rapidModeListener;
+    }
+}
+
+void CookTopControllee::CreateInterfaces()
+{
+    HaeInterface* intf = NULL;
+    HaeControllee* haeControllee = GetControllee();
+    if (!haeControllee) {
+        return;
+    }
+
+    intf = haeControllee->CreateInterface(HEATING_ZONE_INTERFACE, "/Hae/Cooktop", *m_heatingZoneListener);
+    m_heatingZoneIntfControllee = static_cast<HeatingZoneIntfControllee*>(intf);
+
+    intf = haeControllee->CreateInterface(OVEN_CYCLE_PHASE_INTERFACE, "/Hae/Cooktop", *m_ovenCyclePhaseListener);
+    m_ovenCyclePhaseIntfControllee = static_cast<OvenCyclePhaseIntfControllee*>(intf);
+
+    intf = haeControllee->CreateInterface(RAPID_MODE_INTERFACE, "/Hae/Cooktop", *m_rapidModeListener);
+    m_rapidModeIntfControllee = static_cast<RapidModeIntfControllee*>(intf);
+}
+
+void CookTopControllee::SetInitialProperty()
+{
+    m_heatingZoneIntfControllee->SetNumberOfHeatingZones(4);
+    uint8_t numZones = m_heatingZoneIntfControllee->GetNumberOfHeatingZones();
+    std::vector<uint8_t> maxHeatingLevels;
+    for(uint8_t i = 0; i < numZones; i++)
+        maxHeatingLevels.push_back(4);
+    m_heatingZoneIntfControllee->SetMaxHeatingLevels(maxHeatingLevels);
+
+    std::vector<uint8_t> heatingLevels;
+    for(uint8_t i = 0; i < numZones; i++)
+        heatingLevels.push_back(i);
+    m_heatingZoneIntfControllee->SetHeatingLevels(heatingLevels);
+
+    m_ovenCyclePhaseIntfControllee->SetCyclePhase(OvenCyclePhaseInterface::OvenCyclePhase::OVEN_PHASE_PREHEATING);
+
+    OvenCyclePhaseInterface::SupportedCyclePhases phases;
+    phases.push_back(OvenCyclePhaseInterface::OvenCyclePhase::OVEN_PHASE_COOKING);
+    phases.push_back(OvenCyclePhaseInterface::OvenCyclePhase::OVEN_PHASE_PREHEATING);
+    phases.push_back(OvenCyclePhaseInterface::OvenCyclePhase::OVEN_PHASE_CLEANING);
+    phases.push_back(OvenCyclePhaseInterface::OvenCyclePhase::OVEN_PHASE_UNAVAILABLE);
+
+    m_ovenCyclePhaseIntfControllee->SetSupportedCyclePhases(phases);
+}
+
+QStatus FillAboutData(HaeAboutData* aboutData)
+{
+    String const& defaultLanguage = "en";
+    String device_id = "deviceID";
+    String app_id = "4a354777-5649-4518-8a48-777c158bc02d";
+    String app_name = "CookControllee";
+    map<String, String> deviceNames;
+    deviceNames.insert(pair<String, String>("en", "CookTop"));
+
+    if (!app_id.empty()) {
+        aboutData->SetAppId(app_id.c_str());
+    }
+
+    if (device_id != "") {
+        aboutData->SetDeviceId(device_id.c_str());
+    }
+
+    vector<String> languages(1);
+    languages[0] = "en";
+
+    for (size_t i = 0; i < languages.size(); i++) {
+        aboutData->SetSupportedLanguage(languages[i].c_str());
+    }
+
+    if (defaultLanguage != "") {
+        aboutData->SetDefaultLanguage(defaultLanguage.c_str());
+    }
+
+    if (app_name != "") {
+        aboutData->SetAppName(app_name.c_str(), languages[0].c_str());
+    }
+
+    aboutData->SetModelNumber("md1");
+    aboutData->SetDateOfManufacture("22/12/1986");
+    aboutData->SetSoftwareVersion("77.77.77 build 777");
+    aboutData->SetHardwareVersion("777.777. b");
+
+    map<String, String>::const_iterator iter = deviceNames.find(languages[0]);
+    if (iter != deviceNames.end()) {
+        aboutData->SetDeviceName(iter->second.c_str(), languages[0].c_str());
+    } else {
+        aboutData->SetDeviceName("Cooking device", "en");
+    }
+
+    aboutData->SetDescription("This is an Cooktop Controllee Application", "en");
+    aboutData->SetManufacturer("Nik", "en");
+    aboutData->SetSupportUrl("http://www.alljoyn.org");
+
+    // HAE custom metadata fields
+    aboutData->SetCountryOfProduction("SP", "en");
+    aboutData->SetCorporateBrand("CookEr", "en");
+    aboutData->SetProductBrand("Model 3", "en");
+    aboutData->SetLocation("Kitchen", "en");
+
+    DeviceTypeDescription description;
+    description.AddDeviceType(COOKTOP, "/Hae/Cooktop");
+    aboutData->SetDeviceTypeDescription(&description);
+
+    if (!aboutData->IsValid()) {
+
+        return ER_FAIL;
+    }
+
+    return ER_OK;
+}
+
+int main()
+{
+
+
+    if (AllJoynInit() != ER_OK) {
+        printf("FAILED to init alljoyn\n");
+        exit(1);
+    }
+#ifdef ROUTER
+    if (AllJoynRouterInit() != ER_OK) {
+        AllJoynShutdown();
+        printf("FAILED to init router\n");
+        exit(1);
+    }
+#endif
+    printf("AllJoyn Library version: %s\n", ajn::GetVersion());
+    printf("AllJoyn Library build info: %s\n", ajn::GetBuildInfo());
+    QCC_SetLogLevels("HAE_MODULE_LOG_NAME=15;");
+    //CookTopControllee
+    BusAttachment* bus = new BusAttachment("CookTopControllee", true);
+    if (!bus) {
+        printf("BusAttachment creation failed.\n");
+        exit(1);
+    }
+
+    HaeAboutData* aboutData = new HaeAboutData();
+    if (!aboutData) {
+        printf("AboutData creation failed.\n");
+        delete bus;
+        exit(1);
+    }
+    FillAboutData(aboutData);
+
+    QStatus status = bus->Start();
+    if (ER_OK != status) {
+        printf("BusAttachment::Start failed (%s)\n", QCC_StatusText(status));
+        delete bus;
+        delete aboutData;
+        exit(1);
+    }
+
+    status = bus->Connect();
+    if (ER_OK != status) {
+        printf("BusAttachment::Connect failed (%s)\n", QCC_StatusText(status));
+        bus->Stop();
+        bus->Join();
+        delete bus;
+        delete aboutData;
+        exit(1);
+    }
+
+    CookTopControllee controllee(bus, aboutData);
+
+    controllee.Startup();
+
+    controllee.Shutdown();
+
+    if (bus) {
+        bus->Disconnect();
+        bus->Stop();
+        bus->Join();
+
+        delete bus;
+    }
+
+    if (aboutData) {
+        delete aboutData;
+    }
+
+#ifdef ROUTER
+    AllJoynRouterShutdown();
+#endif
+    AllJoynShutdown();
+
+    return 0;
+}
diff --git a/cpp/samples/CookTopControllee/SConscript b/cpp/samples/CookTopControllee/SConscript
new file mode 100644
index 0000000..a24d070
--- /dev/null
+++ b/cpp/samples/CookTopControllee/SConscript
@@ -0,0 +1,28 @@
+# Copyright AllSeen Alliance. All rights reserved.
+#
+#    Permission to use, copy, modify, and/or distribute this software for any
+#    purpose with or without fee is hereby granted, provided that the above
+#    copyright notice and this permission notice appear in all copies.
+#
+#    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+#    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+#    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+#    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+#    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+#    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+#    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+Import('env')
+
+env.Append(CPPPATH = '../BaseSample');
+env.Append(CPPPATH = '../BaseSample/Controllee');
+
+srcs = env.Glob('*.cc')
+srcs += env.Glob('../BaseSample/*.cc')
+srcs += env.Glob('../BaseSample/Controllee/*.cc')
+
+objs = env.Object(srcs)
+
+prog = env.Program('CookTopControllee', objs)
+
+Return('prog')
diff --git a/cpp/samples/LaundryControllee/LaundryControllee.cc b/cpp/samples/LaundryControllee/LaundryControllee.cc
new file mode 100644
index 0000000..846ea61
--- /dev/null
+++ b/cpp/samples/LaundryControllee/LaundryControllee.cc
@@ -0,0 +1,373 @@
+#include <iostream>
+#include <map>
+#include <algorithm>
+#include <qcc/Log.h>
+#include <qcc/String.h>
+#include <alljoyn/Init.h>
+#include <alljoyn/version.h>
+#include <alljoyn/hae/DeviceTypeDescription.h>
+#include "ControlleeCommands.h"
+#include "ControlleeSample.h"
+#include "OnOffStatusListener.h"
+#include "CycleControlListener.h"
+#include "SoilLevelListener.h"
+#include "SpinSpeedLevelListener.h"
+#include "WaterLevelListener.h"
+#include "DishWashingCyclePhaseListener.h"
+#include "LaundryCyclePhaseListener.h"
+#include "TimerListener.h"
+#include <alljoyn/hae/interfaces/operation/OnOffStatusIntfControllee.h>
+#include <alljoyn/hae/interfaces/operation/CycleControlIntfControllee.h>
+#include <alljoyn/hae/interfaces/operation/SoilLevelIntfControllee.h>
+#include <alljoyn/hae/interfaces/operation/SpinSpeedLevelIntfControllee.h>
+#include <alljoyn/hae/interfaces/environment/WaterLevelIntfControllee.h>
+#include <alljoyn/hae/interfaces/operation/DishWashingCyclePhaseIntfControllee.h>
+#include <alljoyn/hae/interfaces/operation/LaundryCyclePhaseIntfControllee.h>
+#include <alljoyn/hae/interfaces/operation/TimerIntfControllee.h>
+
+using namespace std;
+using namespace qcc;
+
+class LaundryControllee : public ControlleeSample
+{
+  private:
+    OnOffStatusListener *m_onOffStatusListener;
+    CycleControlListener *m_cycleControlListener;
+    SoilLevelListener *m_soilLevelListener;
+    SpinSpeedLevelListener *m_spinSpeedLevelListener;
+    WaterLevelListener *m_waterLevelListener;
+    DishWashingCyclePhaseListener* m_dishWashingCyclePhaseListener;
+    LaundryCyclePhaseListener* m_laundryCyclePhaseListener;
+    TimerListener * m_timerListener;
+
+    OnOffStatusIntfControllee* m_onOffStatusIntfControllee;
+    CycleControlIntfControllee* m_cycleControlIntfControllee;
+    SoilLevelIntfControllee* m_soilLevelIntfControllee;
+    SpinSpeedLevelIntfControllee* m_spinSpeedLevelIntfControllee;
+    WaterLevelIntfControllee* m_waterLevelIntfControllee;
+    DishWashingCyclePhaseIntfControllee* m_dishWashingCyclePhaseIntfControllee;
+    LaundryCyclePhaseIntfControllee* m_laundryCyclePhaseIntfControllee;
+    TimerIntfControllee* m_timerIntfControllee;
+
+  public:
+    LaundryControllee(BusAttachment* bus, HaeAboutData* aboutData);
+    virtual ~LaundryControllee();
+    void CreateInterfaces();
+    void SetInitialProperty();
+    void InitSample();
+
+    static void OnCmdSetState(Commands* commands, std::string& cmd);
+    static void OnCmdSetCurWaterLvl(Commands* commands, std::string& cmd);
+
+};
+
+LaundryControllee::LaundryControllee(BusAttachment* bus, HaeAboutData* aboutData)
+  : ControlleeSample(bus, aboutData),m_onOffStatusIntfControllee(NULL), m_cycleControlIntfControllee(NULL),m_soilLevelIntfControllee(NULL),m_spinSpeedLevelIntfControllee(NULL),
+    m_waterLevelIntfControllee(NULL), m_dishWashingCyclePhaseIntfControllee(NULL), m_laundryCyclePhaseIntfControllee(NULL), m_timerIntfControllee(NULL)
+
+{
+    m_onOffStatusListener = new OnOffStatusListener();
+    m_cycleControlListener = new CycleControlListener();
+    m_soilLevelListener = new SoilLevelListener();
+    m_spinSpeedLevelListener = new SpinSpeedLevelListener();
+    m_waterLevelListener = new WaterLevelListener();
+    m_dishWashingCyclePhaseListener = new DishWashingCyclePhaseListener();
+    m_laundryCyclePhaseListener = new LaundryCyclePhaseListener();
+    m_timerListener = new TimerListener();
+}
+
+LaundryControllee::~LaundryControllee()
+{
+    if(m_onOffStatusListener){
+        delete m_onOffStatusListener;
+    }
+    if(m_cycleControlListener){
+        delete m_cycleControlListener;
+    }
+    if(m_soilLevelListener){
+        delete m_soilLevelListener;
+    }
+    if(m_spinSpeedLevelListener){
+        delete m_spinSpeedLevelListener;
+    }
+    if(m_waterLevelListener) {
+        delete m_waterLevelListener;
+    }
+    if(m_dishWashingCyclePhaseListener) {
+        delete m_dishWashingCyclePhaseListener;
+    }
+    if(m_laundryCyclePhaseListener) {
+        delete m_laundryCyclePhaseListener;
+    }
+    if(m_timerListener) {
+        delete m_timerListener;
+    }
+}
+void LaundryControllee::InitSample()
+{
+    HaeControllee* haeControllee = GetControllee();
+    if (!haeControllee) {
+        return;
+    }
+    m_rootCommands->RegisterCommand(&LaundryControllee::OnCmdSetState, "ss", "set state");
+    m_rootCommands->RegisterCommand(&LaundryControllee::OnCmdSetCurWaterLvl, "scw", "set cur water lvl");
+}
+void LaundryControllee::OnCmdSetState(Commands* commands, std::string& cmd)
+{
+    ControlleeSample* sample = static_cast<ControlleeCommands*>(commands)->GetControlleeSample();
+
+    int state = strtol(cmd.c_str(), NULL, 10);
+
+    if (static_cast<LaundryControllee*>(sample)->m_cycleControlIntfControllee) {
+        static_cast<LaundryControllee*>(sample)->m_cycleControlIntfControllee->SetOperationalState((CycleControlInterface::CycleControlOperationalState)state);
+    }
+}
+void LaundryControllee::OnCmdSetCurWaterLvl(Commands* commands, std::string& cmd)
+{
+    ControlleeSample* sample = static_cast<ControlleeCommands*>(commands)->GetControlleeSample();
+
+    int lvl = strtol(cmd.c_str(), NULL, 10);
+
+    if (static_cast<LaundryControllee*>(sample)->m_waterLevelIntfControllee) {
+        static_cast<LaundryControllee*>(sample)->m_waterLevelIntfControllee->SetCurrentLevel(lvl);
+    }
+}
+void LaundryControllee::CreateInterfaces()
+{
+    HaeInterface* intf = NULL;
+    HaeControllee* haeControllee = GetControllee();
+    if (!haeControllee) {
+        return;
+    }
+
+    intf = haeControllee->CreateInterface(ON_OFF_STATUS_INTERFACE, "/Hae/Laundry", *m_onOffStatusListener);
+    m_onOffStatusIntfControllee = static_cast<OnOffStatusIntfControllee*>(intf);
+
+    intf = haeControllee->CreateInterface(CYCLE_CONTROL_INTERFACE, "/Hae/Laundry", *m_cycleControlListener);
+    m_cycleControlIntfControllee = static_cast<CycleControlIntfControllee*>(intf);
+
+    intf = haeControllee->CreateInterface(SOIL_LEVEL_INTERFACE, "/Hae/Laundry", *m_soilLevelListener);
+    m_soilLevelIntfControllee = static_cast<SoilLevelIntfControllee*>(intf);
+
+    intf = haeControllee->CreateInterface(SPIN_SPEED_LEVEL_INTERFACE, "/Hae/Laundry", *m_spinSpeedLevelListener);
+    m_spinSpeedLevelIntfControllee = static_cast<SpinSpeedLevelIntfControllee*>(intf);
+
+    intf = haeControllee->CreateInterface(WATER_LEVEL_INTERFACE, "/Hae/Laundry", *m_waterLevelListener);
+    m_waterLevelIntfControllee = static_cast<WaterLevelIntfControllee*>(intf);
+
+    intf = haeControllee->CreateInterface(DISH_WASHING_CYCLE_PHASE_INTERFACE, "/Hae/Laundry", *m_dishWashingCyclePhaseListener);
+    m_dishWashingCyclePhaseIntfControllee = static_cast<DishWashingCyclePhaseIntfControllee*>(intf);
+
+    intf = haeControllee->CreateInterface(LAUNDRY_CYCLE_PHASE_INTERFACE, "/Hae/Laundry", *m_laundryCyclePhaseListener);
+    m_laundryCyclePhaseIntfControllee = static_cast<LaundryCyclePhaseIntfControllee*>(intf);
+
+    intf = haeControllee->CreateInterface(TIMER_INTERFACE, "/Hae/Laundry", *m_timerListener);
+    m_timerIntfControllee = static_cast<TimerIntfControllee*>(intf);
+}
+
+void LaundryControllee::SetInitialProperty()
+{
+    cout << "LaundryControllee::SetInitialProperty()" << endl;
+
+    //CycleCControlInterface
+    CycleControlInterface::SupportedOperationalCommands comm;
+    comm.push_back(CycleControlInterface::CycleControlOperationalCommand::OPERATIONAL_COMMAND_STOP);
+    comm.push_back(CycleControlInterface::CycleControlOperationalCommand::OPERATIONAL_COMMAND_PAUSE);
+    comm.push_back(CycleControlInterface::CycleControlOperationalCommand::OPERATIONAL_COMMAND_RESUME);
+    m_cycleControlIntfControllee->SetSupportedCommands(comm);
+
+    CycleControlInterface::SupportedOperationalStates states;
+    states.push_back(CycleControlInterface::CycleControlOperationalState::OPERATIONAL_STATE_IDLE);
+    states.push_back(CycleControlInterface::CycleControlOperationalState::OPERATIONAL_STATE_PAUSED);
+    states.push_back(CycleControlInterface::CycleControlOperationalState::OPERATIONAL_STATE_READY_TO_START);
+    states.push_back(CycleControlInterface::CycleControlOperationalState::OPERATIONAL_STATE_END_OF_CYCLE);
+    states.push_back(CycleControlInterface::CycleControlOperationalState::OPERATIONAL_STATE_DELAYED_START);
+    states.push_back(CycleControlInterface::CycleControlOperationalState::OPERATIONAL_STATE_WORKING);
+
+    m_cycleControlIntfControllee->SetSupportedStates(states);
+
+    //SoilLevelInterface
+    uint8_t maxLvl = m_soilLevelIntfControllee->GetMaxLevel();
+    std::vector<uint8_t> selectableLevelsSoil;
+    for(uint8_t i = 0; i < maxLvl; i++)
+        selectableLevelsSoil.push_back((uint8_t)i);
+    QStatus status = m_soilLevelIntfControllee->SetSelectableLevels(selectableLevelsSoil);
+
+    //SpinSpeedLevel Interface
+    maxLvl = m_spinSpeedLevelIntfControllee->GetMaxLevel();
+    std::vector<uint8_t> selectableLevelsSpin;
+    for(int i = 0; i < maxLvl; i++)
+        selectableLevelsSpin.push_back((uint8_t)i);
+    m_spinSpeedLevelIntfControllee->SetSelectableLevels(selectableLevelsSpin);
+
+    //DishWashingCyclePhase Interface
+    m_dishWashingCyclePhaseIntfControllee->SetCyclePhase(DishWashingCyclePhaseInterface::DishWashingCyclePhase::DISH_WASHING_PHASE_DRY);
+
+    DishWashingCyclePhaseInterface::SupportedCyclePhases phases;
+    phases.push_back(DishWashingCyclePhaseInterface::DishWashingCyclePhase::DISH_WASHING_PHASE_DRY);
+    phases.push_back(DishWashingCyclePhaseInterface::DishWashingCyclePhase::DISH_WASHING_PHASE_PRE_WASH);
+    phases.push_back(DishWashingCyclePhaseInterface::DishWashingCyclePhase::DISH_WASHING_PHASE_RINSE);
+    phases.push_back(DishWashingCyclePhaseInterface::DishWashingCyclePhase::DISH_WASHING_PHASE_UNAVAILABLE);
+    phases.push_back(DishWashingCyclePhaseInterface::DishWashingCyclePhase::DISH_WASHING_PHASE_WASH);
+
+    m_dishWashingCyclePhaseIntfControllee->SetSupportedCyclePhases(phases);
+
+    //LaundryCyclePhase Interface
+    m_laundryCyclePhaseIntfControllee->SetCyclePhase(LaundryCyclePhaseInterface::LaundryCyclePhase::LAUNDRY_PHASE_STEAM);
+
+    LaundryCyclePhaseInterface::SupportedCyclePhases aphases;
+    aphases.push_back(LaundryCyclePhaseInterface::LaundryCyclePhase::LAUNDRY_PHASE_UNAVAILABLE);
+    aphases.push_back(LaundryCyclePhaseInterface::LaundryCyclePhase::LAUNDRY_PHASE_STEAM);
+    aphases.push_back(LaundryCyclePhaseInterface::LaundryCyclePhase::LAUNDRY_PHASE_ANTICREASING);
+    aphases.push_back(LaundryCyclePhaseInterface::LaundryCyclePhase::LAUNDRY_PHASE_COOLING);
+    aphases.push_back(LaundryCyclePhaseInterface::LaundryCyclePhase::LAUNDRY_PHASE_DRYING);
+    aphases.push_back(LaundryCyclePhaseInterface::LaundryCyclePhase::LAUNDRY_PHASE_PRE_WASHING);
+    aphases.push_back(LaundryCyclePhaseInterface::LaundryCyclePhase::LAUNDRY_PHASE_RINSING);
+    aphases.push_back(LaundryCyclePhaseInterface::LaundryCyclePhase::LAUNDRY_PHASE_RINSING);
+    aphases.push_back(LaundryCyclePhaseInterface::LaundryCyclePhase::LAUNDRY_PHASE_SPINNING);
+
+    m_laundryCyclePhaseIntfControllee->SetSupportedCyclePhases(aphases);
+}
+
+QStatus FillAboutData(HaeAboutData* aboutData)
+{
+    String const& defaultLanguage = "en";
+    String device_id = "deviceID";
+    String app_id = "4a354637-5649-4518-8a48-323c158bc02d";
+    String app_name = "LaundryControllee";
+    map<String, String> deviceNames;
+    deviceNames.insert(pair<String, String>("en", "ClothesWasher"));
+
+    if (!app_id.empty()) {
+        aboutData->SetAppId(app_id.c_str());
+    }
+
+    if (device_id != "") {
+        aboutData->SetDeviceId(device_id.c_str());
+    }
+
+    vector<String> languages(1);
+    languages[0] = "en";
+
+    for (size_t i = 0; i < languages.size(); i++) {
+        aboutData->SetSupportedLanguage(languages[i].c_str());
+    }
+
+    if (defaultLanguage != "") {
+        aboutData->SetDefaultLanguage(defaultLanguage.c_str());
+    }
+
+    if (app_name != "") {
+        aboutData->SetAppName(app_name.c_str(), languages[0].c_str());
+    }
+
+    aboutData->SetModelNumber("ModelNumber");
+    aboutData->SetDateOfManufacture("15/1/2199");
+    aboutData->SetSoftwareVersion("55.55.55 build 555");
+    aboutData->SetHardwareVersion("555.555. b");
+
+    map<String, String>::const_iterator iter = deviceNames.find(languages[0]);
+    if (iter != deviceNames.end()) {
+        aboutData->SetDeviceName(iter->second.c_str(), languages[0].c_str());
+    } else {
+        aboutData->SetDeviceName("Laundry device", "en");
+    }
+
+    aboutData->SetDescription("This is an Laundry Controllee Application", "en");
+    aboutData->SetManufacturer("Nik", "en");
+    aboutData->SetSupportUrl("http://www.alljoyn.org");
+
+    // HAE custom metadata fields
+    aboutData->SetCountryOfProduction("SP", "en");
+    aboutData->SetCorporateBrand("Laundry", "en");
+    aboutData->SetProductBrand("Model 1", "en");
+    aboutData->SetLocation("Basement", "en");
+
+    DeviceTypeDescription description;
+    description.AddDeviceType(CLOTHES_WASHER, "/Hae/Laundry");
+    aboutData->SetDeviceTypeDescription(&description);
+
+    if (!aboutData->IsValid()) {
+
+        return ER_FAIL;
+    }
+
+    return ER_OK;
+}
+
+int main()
+{
+
+
+    if (AllJoynInit() != ER_OK) {
+        printf("FAILED to init alljoyn\n");
+        exit(1);
+    }
+#ifdef ROUTER
+    if (AllJoynRouterInit() != ER_OK) {
+        AllJoynShutdown();
+        printf("FAILED to init router\n");
+        exit(1);
+    }
+#endif
+    printf("AllJoyn Library version: %s\n", ajn::GetVersion());
+    printf("AllJoyn Library build info: %s\n", ajn::GetBuildInfo());
+    QCC_SetLogLevels("HAE_MODULE_LOG_NAME=15;");
+
+    BusAttachment* bus = new BusAttachment("TVControllee", true);
+    if (!bus) {
+        printf("BusAttachment creation failed.\n");
+        exit(1);
+    }
+
+    HaeAboutData* aboutData = new HaeAboutData();
+    if (!aboutData) {
+        printf("AboutData creation failed.\n");
+        delete bus;
+        exit(1);
+    }
+    FillAboutData(aboutData);
+
+    QStatus status = bus->Start();
+    if (ER_OK != status) {
+        printf("BusAttachment::Start failed (%s)\n", QCC_StatusText(status));
+        delete bus;
+        delete aboutData;
+        exit(1);
+    }
+
+    status = bus->Connect();
+    if (ER_OK != status) {
+        printf("BusAttachment::Connect failed (%s)\n", QCC_StatusText(status));
+        bus->Stop();
+        bus->Join();
+        delete bus;
+        delete aboutData;
+        exit(1);
+    }
+
+    LaundryControllee controllee(bus, aboutData);
+
+    controllee.Startup();
+
+    controllee.Shutdown();
+
+    if (bus) {
+        bus->Disconnect();
+        bus->Stop();
+        bus->Join();
+
+        delete bus;
+    }
+
+    if (aboutData) {
+        delete aboutData;
+    }
+
+#ifdef ROUTER
+    AllJoynRouterShutdown();
+#endif
+    AllJoynShutdown();
+
+    return 0;
+}
diff --git a/cpp/samples/LaundryControllee/SConscript b/cpp/samples/LaundryControllee/SConscript
new file mode 100644
index 0000000..e324eb9
--- /dev/null
+++ b/cpp/samples/LaundryControllee/SConscript
@@ -0,0 +1,28 @@
+# Copyright AllSeen Alliance. All rights reserved.
+#
+#    Permission to use, copy, modify, and/or distribute this software for any
+#    purpose with or without fee is hereby granted, provided that the above
+#    copyright notice and this permission notice appear in all copies.
+#
+#    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+#    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+#    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+#    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+#    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+#    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+#    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+Import('env')
+
+env.Append(CPPPATH = '../BaseSample');
+env.Append(CPPPATH = '../BaseSample/Controllee');
+
+srcs = env.Glob('*.cc')
+srcs += env.Glob('../BaseSample/*.cc')
+srcs += env.Glob('../BaseSample/Controllee/*.cc')
+
+objs = env.Object(srcs)
+
+prog = env.Program('LaundryControllee', objs)
+
+Return('prog')
diff --git a/cpp/samples/SConscript b/cpp/samples/SConscript
index 9322fe7..4e17dd8 100755
--- a/cpp/samples/SConscript
+++ b/cpp/samples/SConscript
@@ -29,7 +29,9 @@ sample_dirs = [
     'TvControllee',
     'VDIControllee',
     'ACControllee',
-    'RobotCleanerControllee'
+    'RobotCleanerControllee',
+    'CookTopControllee',
+    'LaundryControllee'
     ]
 
 exports = { 'env': local_env }
diff --git a/cpp/samples/TvControllee/TvControllee.cc b/cpp/samples/TvControllee/TvControllee.cc
index c112620..749cb6b 100644
--- a/cpp/samples/TvControllee/TvControllee.cc
+++ b/cpp/samples/TvControllee/TvControllee.cc
@@ -68,7 +68,7 @@ TvControllee::~TvControllee()
         delete m_hidListener;
     }
     if(m_closedStatusListener){
-    	delete m_closedStatusListener;
+        delete m_closedStatusListener;
     }
 }
 
diff --git a/cpp/src/InterfaceFactory.cc b/cpp/src/InterfaceFactory.cc
index befe5b0..aafd447 100644
--- a/cpp/src/InterfaceFactory.cc
+++ b/cpp/src/InterfaceFactory.cc
@@ -41,6 +41,17 @@
 #include "interfaces/environment/WindDirectionIntfControlleeImpl.h"
 #include "interfaces/operation/AirRecirculationModeIntfControlleeImpl.h"
 #include "interfaces/operation/RepeatModeIntfControlleeImpl.h"
+#include "interfaces/operation/CycleControlIntfControlleeImpl.h"
+#include "interfaces/operation/RemoteControllabilityIntfControlleeImpl.h"
+#include "interfaces/operation/RapidModeIntfControlleeImpl.h"
+#include "interfaces/operation/SoilLevelIntfControlleeImpl.h"
+#include "interfaces/operation/SpinSpeedLevelIntfControlleeImpl.h"
+#include "interfaces/environment/WaterLevelIntfControlleeImpl.h"
+#include "interfaces/operation/HeatingZoneIntfControlleeImpl.h"
+#include "interfaces/operation/DishWashingCyclePhaseIntfControlleeImpl.h"
+#include "interfaces/operation/LaundryCyclePhaseIntfControlleeImpl.h"
+#include "interfaces/operation/OvenCyclePhaseIntfControlleeImpl.h"
+#include "interfaces/operation/TimerIntfControlleeImpl.h"
 
 // Controller
 #include "interfaces/operation/AudioVolumeIntfControllerImpl.h"
@@ -60,6 +71,17 @@
 #include "interfaces/environment/WindDirectionIntfControllerImpl.h"
 #include "interfaces/operation/AirRecirculationModeIntfControllerImpl.h"
 #include "interfaces/operation/RepeatModeIntfControllerImpl.h"
+#include "interfaces/operation/CycleControlIntfControllerImpl.h"
+#include "interfaces/operation/RemoteControllabilityIntfControllerImpl.h"
+#include "interfaces/operation/RapidModeIntfControllerImpl.h"
+#include "interfaces/operation/SoilLevelIntfControllerImpl.h"
+#include "interfaces/operation/SpinSpeedLevelIntfControllerImpl.h"
+#include "interfaces/environment/WaterLevelIntfControllerImpl.h"
+#include "interfaces/operation/HeatingZoneIntfControllerImpl.h"
+#include "interfaces/operation/DishWashingCyclePhaseIntfControllerImpl.h"
+#include "interfaces/operation/LaundryCyclePhaseIntfControllerImpl.h"
+#include "interfaces/operation/OvenCyclePhaseIntfControllerImpl.h"
+#include "interfaces/operation/TimerIntfControllerImpl.h"
 
 using namespace std;
 using namespace qcc;
@@ -98,6 +120,17 @@ InterfaceFactory::InterfaceFactory() :
     m_controllerCreators[AIR_RECIRCULATION_MODE_INTERFACE] = static_cast<CreateIntfControllerFptr>(&AirRecirculationModeIntfControllerImpl::CreateInterface);
     m_controllerCreators[REPEAT_MODE_INTERFACE] = static_cast<CreateIntfControllerFptr>(&RepeatModeIntfControllerImpl::CreateInterface);
     m_controllerCreators[CLOSED_STATUS_INTERFACE] = static_cast<CreateIntfControllerFptr>(&ClosedStatusIntfControllerImpl::CreateInterface);
+    m_controllerCreators[CYCLE_CONTROL_INTERFACE] = static_cast<CreateIntfControllerFptr>(&CycleControlIntfControllerImpl::CreateInterface);
+    m_controllerCreators[REMOTE_CONTROLLABILITY_INTERFACE] = static_cast<CreateIntfControllerFptr>(&RemoteControllabilityIntfControllerImpl::CreateInterface);
+    m_controllerCreators[RAPID_MODE_INTERFACE] = static_cast<CreateIntfControllerFptr>(&RapidModeIntfControllerImpl::CreateInterface);
+    m_controllerCreators[SOIL_LEVEL_INTERFACE] = static_cast<CreateIntfControllerFptr>(&SoilLevelIntfControllerImpl::CreateInterface);
+    m_controllerCreators[SPIN_SPEED_LEVEL_INTERFACE] = static_cast<CreateIntfControllerFptr>(&SpinSpeedLevelIntfControllerImpl::CreateInterface);
+    m_controllerCreators[WATER_LEVEL_INTERFACE] = static_cast<CreateIntfControllerFptr>(&WaterLevelIntfControllerImpl::CreateInterface);
+    m_controllerCreators[HEATING_ZONE_INTERFACE] = static_cast<CreateIntfControllerFptr>(&HeatingZoneIntfControllerImpl::CreateInterface);
+    m_controllerCreators[DISH_WASHING_CYCLE_PHASE_INTERFACE] = static_cast<CreateIntfControllerFptr>(&DishWashingCyclePhaseIntfControllerImpl::CreateInterface);
+    m_controllerCreators[LAUNDRY_CYCLE_PHASE_INTERFACE] = static_cast<CreateIntfControllerFptr>(&LaundryCyclePhaseIntfControllerImpl::CreateInterface);
+    m_controllerCreators[OVEN_CYCLE_PHASE_INTERFACE] = static_cast<CreateIntfControllerFptr>(&OvenCyclePhaseIntfControllerImpl::CreateInterface);
+    m_controllerCreators[TIMER_INTERFACE] = static_cast<CreateIntfControllerFptr>(&TimerIntfControllerImpl::CreateInterface);
 
     // Controllee
     m_controlleeCreators[CHANNEL_INTERFACE] = static_cast<CreateIntfControlleeFptr>(&ChannelIntfControlleeImpl::CreateInterface);
@@ -117,6 +150,17 @@ InterfaceFactory::InterfaceFactory() :
     m_controlleeCreators[AIR_RECIRCULATION_MODE_INTERFACE] = static_cast<CreateIntfControlleeFptr>(&AirRecirculationModeIntfControlleeImpl::CreateInterface);
     m_controlleeCreators[REPEAT_MODE_INTERFACE] = static_cast<CreateIntfControlleeFptr>(&RepeatModeIntfControlleeImpl::CreateInterface);
     m_controlleeCreators[CLOSED_STATUS_INTERFACE] = static_cast<CreateIntfControlleeFptr>(&ClosedStatusIntfControlleeImpl::CreateInterface);
+    m_controlleeCreators[CYCLE_CONTROL_INTERFACE] = static_cast<CreateIntfControlleeFptr>(&CycleControlIntfControlleeImpl::CreateInterface);
+    m_controlleeCreators[REMOTE_CONTROLLABILITY_INTERFACE] = static_cast<CreateIntfControlleeFptr>(&RemoteControllabilityIntfControlleeImpl::CreateInterface);
+    m_controlleeCreators[RAPID_MODE_INTERFACE] = static_cast<CreateIntfControlleeFptr>(&RapidModeIntfControlleeImpl::CreateInterface);
+    m_controlleeCreators[SOIL_LEVEL_INTERFACE] = static_cast<CreateIntfControlleeFptr>(&SoilLevelIntfControlleeImpl::CreateInterface);
+    m_controlleeCreators[SPIN_SPEED_LEVEL_INTERFACE] = static_cast<CreateIntfControlleeFptr>(&SpinSpeedLevelIntfControlleeImpl::CreateInterface);
+    m_controlleeCreators[WATER_LEVEL_INTERFACE] = static_cast<CreateIntfControlleeFptr>(&WaterLevelIntfControlleeImpl::CreateInterface);
+    m_controlleeCreators[HEATING_ZONE_INTERFACE] = static_cast<CreateIntfControlleeFptr>(&HeatingZoneIntfControlleeImpl::CreateInterface);
+    m_controlleeCreators[DISH_WASHING_CYCLE_PHASE_INTERFACE] = static_cast<CreateIntfControlleeFptr>(&DishWashingCyclePhaseIntfControlleeImpl::CreateInterface);
+    m_controlleeCreators[LAUNDRY_CYCLE_PHASE_INTERFACE] = static_cast<CreateIntfControlleeFptr>(&LaundryCyclePhaseIntfControlleeImpl::CreateInterface);
+    m_controlleeCreators[OVEN_CYCLE_PHASE_INTERFACE] = static_cast<CreateIntfControlleeFptr>(&OvenCyclePhaseIntfControlleeImpl::CreateInterface);
+    m_controlleeCreators[TIMER_INTERFACE] = static_cast<CreateIntfControlleeFptr>(&TimerIntfControlleeImpl::CreateInterface);
 }
 
 InterfaceFactory::InterfaceFactory(const InterfaceFactory& src)
diff --git a/cpp/src/interfaces/environment/WaterLevelInterface.cc b/cpp/src/interfaces/environment/WaterLevelInterface.cc
new file mode 100644
index 0000000..2d8fce6
--- /dev/null
+++ b/cpp/src/interfaces/environment/WaterLevelInterface.cc
@@ -0,0 +1,57 @@
+/******************************************************************************
+ * Copyright (c) 2013-2014, AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#include <alljoyn/hae/LogModule.h>
+#include <alljoyn/hae/interfaces/environment/WaterLevelInterface.h>
+
+namespace ajn {
+namespace services {
+
+const uint16_t WaterLevelInterface::s_interfaceVersion = 1;
+
+// Below none secure xml is only for test
+const qcc::String WaterLevelInterface::s_xml =
+"<node xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance' xsi:noNamespaceSchemaLocation='http://www.allseenalliance.org/schemas/introspect.xsd'>"
+"    <interface name='org.alljoyn.SmartSpaces.Environment.WaterLevel'>"
+"        <description language='en'>This information provides level and supply source of water for an appliance.</description>"
+"        <annotation name='org.alljoyn.Bus.Secure' value='true'/>"
+"        <property name='Version' type='q' access='read'>"
+"            <description language='en'>The interface version.</description>"
+"            <annotation name='org.freedesktop.DBus.Property.EmitsChangedSignal' value='true'/>"
+"        </property>"
+"        <property name='SupplySource' type='y' access='read'>"
+"            <description language='en'>The supply source of water.</description>"
+"            <annotation name='org.freedesktop.DBus.Property.EmitsChangedSignal' value='true'/>"
+"        </property>"
+"        <property name='CurrentLevel' type='y' access='read'>"
+"            <description language='en'>The current level of water in the tank.</description>"
+"            <annotation name='org.freedesktop.DBus.Property.EmitsChangedSignal' value='true'/>"
+"        </property>"
+"        <property name='MaxLevel' type='y' access='read'>"
+"            <description language='en'>Maximum level allowed for water level.</description>"
+"            <annotation name='org.freedesktop.DBus.Property.EmitsChangedSignal' value='true'/>"
+"        </property>"
+"    </interface>"
+"</node>"
+;
+
+const qcc::String WaterLevelInterface::s_prop_Version = "Version";
+const qcc::String WaterLevelInterface::s_prop_SupplySource = "SupplySource";
+const qcc::String WaterLevelInterface::s_prop_CurrentLevel = "CurrentLevel";
+const qcc::String WaterLevelInterface::s_prop_MaxLevel = "MaxLevel";
+
+} //namespace services
+} //namespace ajn
diff --git a/cpp/src/interfaces/environment/WaterLevelIntfControlleeImpl.cc b/cpp/src/interfaces/environment/WaterLevelIntfControlleeImpl.cc
new file mode 100644
index 0000000..a92f938
--- /dev/null
+++ b/cpp/src/interfaces/environment/WaterLevelIntfControlleeImpl.cc
@@ -0,0 +1,214 @@
+/******************************************************************************
+ * Copyright (c) 2013-2014, AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#include <qcc/Util.h>
+
+#include <alljoyn/hae/LogModule.h>
+#include <alljoyn/hae/HaeBusObject.h>
+#include <alljoyn/hae/interfaces/environment/WaterLevelIntfControlleeListener.h>
+
+#include "WaterLevelIntfControlleeImpl.h"
+
+using namespace qcc;
+using namespace std;
+
+namespace ajn {
+namespace services {
+
+HaeInterface* WaterLevelIntfControlleeImpl::CreateInterface(BusAttachment& busAttachment, InterfaceControlleeListener& listener, HaeBusObject& haeBusObject)
+{
+    return new WaterLevelIntfControlleeImpl(busAttachment, dynamic_cast<WaterLevelIntfControlleeListener&>(listener), haeBusObject);
+}
+
+WaterLevelIntfControlleeImpl::WaterLevelIntfControlleeImpl(BusAttachment& busAttachment, WaterLevelIntfControlleeListener& listener, HaeBusObject& haeBusObject) :
+    InterfaceControllee(haeBusObject),
+    m_busAttachment(busAttachment),
+    m_interfaceListener(listener),
+    m_currentLevel(2),
+    m_supplySource(SUPPLY_SOURCE_PIPE),
+    m_maxLevel(5)
+{
+}
+
+WaterLevelIntfControlleeImpl::~WaterLevelIntfControlleeImpl()
+{
+}
+
+QStatus WaterLevelIntfControlleeImpl::Init()
+{
+    QStatus status = HaeInterface::Init();
+    return status;
+}
+
+QStatus WaterLevelIntfControlleeImpl::OnGetProperty(const String propName, MsgArg& val)
+{
+    QStatus status = ER_OK;
+
+    if (!(s_prop_Version.compare(propName))) {
+        val.typeId = ALLJOYN_UINT16;
+        val.v_uint16 = GetInterfaceVersion();
+    } else {
+        if (s_retrievingActualPropertyValue) {
+            if(!s_prop_CurrentLevel.compare(propName)) {
+                uint8_t currLevel;
+                status = m_interfaceListener.OnGetCurrentLevel(currLevel);
+                if(status !=  ER_OK) {
+                    QCC_LogError(status, ("%s: failed to get property.", __func__));
+                    currLevel = GetCurrentLevel();
+                } else {
+                    SetCurrentLevel(currLevel);
+                }
+                val.typeId = ALLJOYN_BYTE;
+                val.v_byte = currLevel;
+            } else if (!s_prop_MaxLevel.compare(propName)) {
+                uint8_t maxLevel;
+                status = m_interfaceListener.OnGetCurrentLevel(maxLevel);
+                if(status !=  ER_OK) {
+                    QCC_LogError(status, ("%s: failed to get property.", __func__));
+                    maxLevel = GetMaxLevel();
+                } else {
+                    SetMaxLevel(maxLevel);
+                }
+                val.typeId = ALLJOYN_BYTE;
+                val.v_byte = maxLevel;
+            } else if (!s_prop_SupplySource.compare(propName)) {
+                WaterLevelSupplySource suppSrc;
+                status = m_interfaceListener.OnGetSupplySource(suppSrc);
+                if(status !=  ER_OK) {
+                    QCC_LogError(status, ("%s: failed to get property.", __func__));
+                    suppSrc = GetSupplySource();
+                } else {
+                    SetSupplySource(suppSrc);
+                }
+                val.typeId = ALLJOYN_BYTE;
+                val.v_byte = (uint8_t)suppSrc;
+            } else {
+                status = ER_BUS_NO_SUCH_PROPERTY;
+            }
+        } else {
+            if(!s_prop_CurrentLevel.compare(propName)) {
+                uint8_t currLevel;
+                currLevel = GetCurrentLevel();
+                val.typeId = ALLJOYN_BYTE;
+                val.v_byte = currLevel;
+            } else if (!s_prop_MaxLevel.compare(propName)) {
+                uint8_t maxLevel;
+                maxLevel = GetMaxLevel();
+                val.typeId = ALLJOYN_BYTE;
+                val.v_byte = maxLevel;
+            } else if (!s_prop_SupplySource.compare(propName)) {
+                WaterLevelSupplySource suppSrc;
+                suppSrc = GetSupplySource();
+                val.typeId = ALLJOYN_BYTE;
+                val.v_byte = (uint8_t)suppSrc;
+            } else {
+                status = ER_BUS_NO_SUCH_PROPERTY;
+            }
+       }
+    }
+
+    return status;
+}
+
+QStatus WaterLevelIntfControlleeImpl::OnSetProperty(const String propName, MsgArg& val)
+{
+    QStatus status = ER_OK;
+
+    return status;
+}
+
+void WaterLevelIntfControlleeImpl::OnMethodHandler(const InterfaceDescription::Member* member, Message& msg)
+{
+    QStatus status = ER_OK;
+    bool isFound = false;
+    MethodHandlers::const_iterator it;
+    for (it = m_methodHandlers.begin(); it != m_methodHandlers.end(); ++it) {
+        if (it->first == member) {
+            MessageReceiver::MethodHandler handler = it->second;
+            (this->*handler)(member, msg);
+            isFound = true;
+            break;
+        }
+    }
+
+    if (!isFound) {
+        status = ER_BUS_METHOD_CALL_ABORTED;
+        QCC_LogError(status, ("%s: could not found method handler.", __func__));
+        m_busObject.ReplyMethodCall(msg, status);
+    }
+}
+QStatus WaterLevelIntfControlleeImpl::SetCurrentLevel(const uint8_t currentLevel)
+{
+    WaterLevelSupplySource src = GetSupplySource();
+
+    if((src == WaterLevelSupplySource::SUPPLY_SOURCE_NOT_SUPPORTED || src == WaterLevelSupplySource::SUPPLY_SOURCE_PIPE) && currentLevel !=0 )
+        return ER_FAIL;
+
+    if(currentLevel > m_maxLevel)
+    {
+        QCC_LogError(ER_FAIL, ("%s: CurrentLevel is more than MaxLevel. ", __func__));
+        return ER_FAIL;
+    }
+
+    if(currentLevel != m_currentLevel)
+    {
+        MsgArg arg;
+        arg.typeId = ALLJOYN_BYTE;
+        arg.v_byte = currentLevel;
+        m_busObject.EmitPropChanged(GetInterfaceName().c_str(), s_prop_CurrentLevel.c_str(), arg, 0 ,ALLJOYN_FLAG_GLOBAL_BROADCAST);
+        m_currentLevel = currentLevel;
+    }
+    return ER_OK;
+}
+
+QStatus WaterLevelIntfControlleeImpl::SetMaxLevel(const uint8_t maxLevel)
+{
+    WaterLevelSupplySource src = GetSupplySource();
+    if((src == WaterLevelSupplySource::SUPPLY_SOURCE_NOT_SUPPORTED || src == WaterLevelSupplySource::SUPPLY_SOURCE_PIPE) && maxLevel !=0 )
+        return ER_FAIL;
+
+    if(maxLevel != m_maxLevel)
+    {
+        MsgArg arg;
+        arg.typeId = ALLJOYN_BYTE;
+        arg.v_byte = maxLevel;
+        m_busObject.EmitPropChanged(GetInterfaceName().c_str(), s_prop_MaxLevel.c_str(), arg, 0 ,ALLJOYN_FLAG_GLOBAL_BROADCAST);
+        m_maxLevel = maxLevel;
+    }
+    return ER_OK;
+}
+
+QStatus WaterLevelIntfControlleeImpl::SetSupplySource(const WaterLevelSupplySource supplySource)
+{
+    if(supplySource!= m_supplySource)
+    {
+        MsgArg arg;
+        arg.typeId = ALLJOYN_BYTE;
+        arg.v_byte = (uint8_t)supplySource;
+        m_busObject.EmitPropChanged(GetInterfaceName().c_str(), s_prop_SupplySource.c_str(), arg, 0 ,ALLJOYN_FLAG_GLOBAL_BROADCAST);
+        m_supplySource = supplySource;
+    }
+    if(m_supplySource == WaterLevelSupplySource::SUPPLY_SOURCE_NOT_SUPPORTED || m_supplySource == WaterLevelSupplySource::SUPPLY_SOURCE_PIPE)
+    {
+        SetMaxLevel(0);
+        SetCurrentLevel(0);
+    }
+
+    return ER_OK;
+}
+
+} //namespace services
+} //namespace ajn
diff --git a/cpp/src/interfaces/environment/WaterLevelIntfControlleeImpl.h b/cpp/src/interfaces/environment/WaterLevelIntfControlleeImpl.h
new file mode 100644
index 0000000..88f65c0
--- /dev/null
+++ b/cpp/src/interfaces/environment/WaterLevelIntfControlleeImpl.h
@@ -0,0 +1,147 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#ifndef WATERLEVELINTFCONTROLLEEIMPL_H_
+#define WATERLEVELINTFCONTROLLEEIMPL_H_
+
+#include <alljoyn/Status.h>
+#include <alljoyn/BusAttachment.h>
+#include <alljoyn/InterfaceDescription.h>
+#include <alljoyn/hae/interfaces/InterfaceControllee.h>
+#include <alljoyn/hae/interfaces/InterfaceControlleeListener.h>
+#include <alljoyn/hae/interfaces/environment/WaterLevelIntfControllee.h>
+
+namespace ajn {
+namespace services {
+
+class WaterLevelIntfControlleeListener;
+class HaeBusObject;
+
+/**
+ * WaterLevel Interface Controllee implementation class
+ */
+class WaterLevelIntfControlleeImpl : public InterfaceControllee, public WaterLevelIntfControllee {
+  public:
+    /**
+     * Create interface
+     */
+    static HaeInterface* CreateInterface(BusAttachment& busAttachment, InterfaceControlleeListener& listener, HaeBusObject& haeBusObject);
+
+    /**
+     * Constructor of WaterLevelIntfControlleeImpl
+     */
+    WaterLevelIntfControlleeImpl(BusAttachment& busAttachment, WaterLevelIntfControlleeListener& listener, HaeBusObject& haeBusObject);
+
+    /**
+     * Destructor of WaterLevelIntfControlleeImpl
+     */
+    virtual ~WaterLevelIntfControlleeImpl();
+
+    /**
+     * Initialize interface
+     * @return status
+     */
+     virtual QStatus Init();
+
+    /**
+     * a callback function for getting property.
+     * @param propName   Identifies the property to get
+     * @param[out] val   Returns the property value. The type of this value is the actual value type.
+     * @return status
+     */
+    virtual QStatus OnGetProperty(const qcc::String propName, MsgArg& val);
+
+    /**
+     * a callback function for setting property.
+     * @param propName  Identifies the property to set
+     * @param val       The property value to set. The type of this value is the actual value type.
+     */
+    virtual QStatus OnSetProperty(const qcc::String propName, MsgArg& val);
+
+    /**
+     * method handler
+     * @param member    Method interface member entry.
+     * @param message   The received method call message.
+     */
+    virtual void OnMethodHandler(const InterfaceDescription::Member* member, Message& msg);
+
+    /**
+     * Get method handlers
+     * @return MethodHandlers
+     */
+    virtual const MethodHandlers& GetMethodHanders() const { return m_methodHandlers; }
+
+    /**
+     * Get bus attachment
+     * @return bus attachment
+     */
+    virtual BusAttachment& GetBusAttachment() const { return m_busAttachment; }
+
+    /**
+     * Get CurrentLevel
+     * @return current level
+     */
+    virtual const uint8_t GetCurrentLevel() const {return m_currentLevel; }
+
+    /**
+     * Set CurrentLevel
+     * @param[in] currentLevel currentLevel
+     * @return ER_OK on success
+     */
+    virtual QStatus SetCurrentLevel (const uint8_t currentLevel);
+
+    /**
+     * Get MaxLevel
+     * @return max level
+     */
+    virtual const uint8_t GetMaxLevel() const { return m_maxLevel; }
+
+    /**
+     * Set MaxLevel
+     * @param[in] maxLevel maxLevel
+     * @return ER_OK on success
+     */
+    virtual QStatus SetMaxLevel(const uint8_t maxLevel);
+
+    /**
+     * Get SupplySource
+     * @return supply source
+     */
+    virtual const WaterLevelSupplySource GetSupplySource() const { return m_supplySource; }
+
+
+    /**
+     * Set SupplySource
+     * @param[in] supplySource supply source
+     * @return ER_OK on success
+     */
+    virtual QStatus SetSupplySource(const WaterLevelSupplySource supplySource);
+
+  private:
+    WaterLevelIntfControlleeImpl();
+
+    BusAttachment& m_busAttachment;
+    WaterLevelIntfControlleeListener& m_interfaceListener;
+    MethodHandlers m_methodHandlers;
+    uint8_t m_currentLevel;
+    WaterLevelSupplySource m_supplySource;
+    uint8_t m_maxLevel;
+};
+
+} //namespace services
+} //namespace ajn
+
+#endif /* WATERLEVELINTFCONTROLLEEIMPL_H_ */
diff --git a/cpp/src/interfaces/environment/WaterLevelIntfControllerImpl.cc b/cpp/src/interfaces/environment/WaterLevelIntfControllerImpl.cc
new file mode 100644
index 0000000..757c72c
--- /dev/null
+++ b/cpp/src/interfaces/environment/WaterLevelIntfControllerImpl.cc
@@ -0,0 +1,157 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#include <qcc/Util.h>
+
+#include <alljoyn/hae/LogModule.h>
+#include <alljoyn/hae/HaeProxyBusObject.h>
+#include <alljoyn/hae/interfaces/environment/WaterLevelIntfControllerListener.h>
+
+#include "WaterLevelIntfControllerImpl.h"
+
+using namespace qcc;
+using namespace std;
+
+namespace ajn {
+namespace services {
+
+HaeInterface* WaterLevelIntfControllerImpl::CreateInterface(BusAttachment& busAttachment, InterfaceControllerListener& listener, HaeProxyBusObject& haeProxyObject)
+{
+    return new WaterLevelIntfControllerImpl(busAttachment, dynamic_cast<WaterLevelIntfControllerListener&>(listener), haeProxyObject);
+}
+
+WaterLevelIntfControllerImpl::WaterLevelIntfControllerImpl(BusAttachment& busAttachment, WaterLevelIntfControllerListener& listener, HaeProxyBusObject& haeProxyObject) :
+    InterfaceController(haeProxyObject),
+    m_busAttachment(busAttachment),
+    m_interfaceListener(listener)
+{
+}
+
+WaterLevelIntfControllerImpl::~WaterLevelIntfControllerImpl()
+{
+}
+
+QStatus WaterLevelIntfControllerImpl::Init()
+{
+    QStatus status = HaeInterface::Init();
+    if (ER_OK != status) {
+        QCC_LogError(status, ("%s: Interface init failed.", __func__));
+        return status;
+    }
+
+    status = m_proxyObject.RegisterPropertiesChangedListener(GetInterfaceName().c_str(), NULL, 0, *this, NULL);
+    if (ER_OK != status) {
+        QCC_LogError(status, ("%s: RegisterPropertiesChangedListener failed.", __func__));
+    }
+    return status;
+}
+
+void WaterLevelIntfControllerImpl::PropertiesChanged(ProxyBusObject& obj, const char* ifaceName, const MsgArg& changed, const MsgArg& invalidated, void* context)
+{
+    MsgArg* entries;
+    size_t numEntries;
+
+    changed.Get("a{sv}", &numEntries, &entries);
+    for (size_t i = 0; i < numEntries; ++i)
+    {
+        const char* propName;
+        MsgArg* propValue;
+        entries[i].Get("{sv}", &propName, &propValue);
+        String propNameStr(propName);
+
+        if (!s_prop_CurrentLevel.compare(propNameStr))
+        {
+            if (propValue->typeId == ALLJOYN_BYTE)
+            {
+                uint8_t volume = propValue->v_byte;
+                m_interfaceListener.CurrentLevelProprtyChanged(obj.GetPath(), volume);
+            }
+        }
+        else if (!s_prop_MaxLevel.compare(propNameStr))
+        {
+            if (propValue->typeId == ALLJOYN_BYTE)
+            {
+                uint8_t volume = propValue->v_byte;
+                m_interfaceListener.MaxLevelProprtyChanged(obj.GetPath(), volume);
+            }
+        }
+        else if (!s_prop_SupplySource.compare(propNameStr))
+        {
+            if (propValue->typeId == ALLJOYN_BYTE)
+            {
+                uint8_t volume = propValue->v_byte;
+                m_interfaceListener.SupplySourceProprtyChanged(obj.GetPath(), (WaterLevelSupplySource)volume);
+            }
+        }
+    }
+}
+QStatus WaterLevelIntfControllerImpl::GetCurrentLevel(void* context)
+{
+    QStatus status = ER_OK;
+
+    status = m_proxyObject.GetPropertyAsync(GetInterfaceName().c_str(), s_prop_CurrentLevel.c_str(), this, (ProxyBusObject::Listener::GetPropertyCB)&WaterLevelIntfControllerImpl::OnGetCurrentLevelPropertyCB, context);
+
+    return status;
+}
+
+QStatus WaterLevelIntfControllerImpl::GetSupplySource(void* context)
+{
+    QStatus status = ER_OK;
+
+    status = m_proxyObject.GetPropertyAsync(GetInterfaceName().c_str(), s_prop_SupplySource.c_str(), this, (ProxyBusObject::Listener::GetPropertyCB)&WaterLevelIntfControllerImpl::OnGetSupplySourcePropertyCB, context);
+
+    return status;
+}
+
+QStatus WaterLevelIntfControllerImpl::GetMaxLevel(void* context)
+{
+    QStatus status = ER_OK;
+
+    status = m_proxyObject.GetPropertyAsync(GetInterfaceName().c_str(), s_prop_MaxLevel.c_str(), this, (ProxyBusObject::Listener::GetPropertyCB)&WaterLevelIntfControllerImpl::OnGetMaxLevelPropertyCB, context);
+
+    return status;
+}
+
+void WaterLevelIntfControllerImpl::OnGetMaxLevelPropertyCB(QStatus status, ProxyBusObject* obj, const MsgArg& value, void* context)
+{
+    if(!obj) {
+        return;
+    }
+    uint8_t maxLevel;
+    value.Get("y", & maxLevel);
+    m_interfaceListener.OnGetMaxLevelPropertyCallback(status, obj->GetPath(),maxLevel, context);
+}
+void WaterLevelIntfControllerImpl::OnGetCurrentLevelPropertyCB(QStatus status, ProxyBusObject* obj, const MsgArg& value, void* context)
+{
+    if(!obj) {
+        return;
+    }
+    uint8_t currLevel;
+    value.Get("y", & currLevel);
+    m_interfaceListener.OnGetCurrentLevelPropertyCallback(status, obj->GetPath(),currLevel, context);
+}
+void WaterLevelIntfControllerImpl::OnGetSupplySourcePropertyCB(QStatus status, ProxyBusObject* obj, const MsgArg& value, void* context)
+{
+    if(!obj) {
+        return;
+    }
+    uint8_t suppSrc;
+    value.Get("y", & suppSrc);
+    m_interfaceListener.OnGetSupplySourcePropertyCallback(status, obj->GetPath(),(WaterLevelSupplySource)suppSrc, context);
+}
+
+} //namespace services
+} //namespace ajn
diff --git a/cpp/src/interfaces/environment/WaterLevelIntfControllerImpl.h b/cpp/src/interfaces/environment/WaterLevelIntfControllerImpl.h
new file mode 100644
index 0000000..b8c020e
--- /dev/null
+++ b/cpp/src/interfaces/environment/WaterLevelIntfControllerImpl.h
@@ -0,0 +1,86 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#ifndef WATERLEVELINTFCONTROLLERIMPL_H_
+#define WATERLEVELINTFCONTROLLERIMPL_H_
+
+#include <alljoyn/Status.h>
+#include <alljoyn/BusAttachment.h>
+#include <alljoyn/hae/interfaces/InterfaceController.h>
+#include <alljoyn/hae/interfaces/environment/WaterLevelIntfController.h>
+
+namespace ajn {
+namespace services {
+
+class WaterLevelIntfControllerListener;
+class HaeProxyBusObject;
+
+/**
+ * WaterLevel Interface Controller implementation class
+ */
+class WaterLevelIntfControllerImpl : public InterfaceController, public WaterLevelIntfController {
+  public:
+    /**
+     * Create interface
+     */
+    static HaeInterface* CreateInterface(BusAttachment& busAttachment, InterfaceControllerListener& listener, HaeProxyBusObject& haeProxyObject);
+
+    /**
+     * Constructor of WaterLevelIntfControllerImpl
+     */
+    WaterLevelIntfControllerImpl(BusAttachment& busAttachment, WaterLevelIntfControllerListener& listener, HaeProxyBusObject& haeProxyObject);
+
+    /**
+     * Destructor of WaterLevelIntfControllerImpl
+     */
+    virtual ~WaterLevelIntfControllerImpl();
+
+    /**
+     * Initialize interface
+     * @return status
+     */
+    virtual QStatus Init();
+
+    /**
+     * Get bus attachment
+     * @return bus attachment
+     */
+    virtual BusAttachment& GetBusAttachment() const { return m_busAttachment; }
+
+    virtual QStatus GetCurrentLevel(void* context = NULL);
+
+    virtual QStatus GetSupplySource(void* context = NULL);
+
+    virtual QStatus GetMaxLevel(void* context = NULL);
+
+  private:
+    WaterLevelIntfControllerImpl();
+
+    void PropertiesChanged(ProxyBusObject& obj, const char* ifaceName, const MsgArg& changed, const MsgArg& invalidated, void* context);
+
+    void OnGetMaxLevelPropertyCB(QStatus status, ProxyBusObject* obj, const MsgArg& value, void* context);
+    void OnGetCurrentLevelPropertyCB(QStatus status, ProxyBusObject* obj, const MsgArg& value, void* context);
+    void OnGetSupplySourcePropertyCB(QStatus status, ProxyBusObject* obj, const MsgArg& value, void* context);
+
+
+    BusAttachment& m_busAttachment;
+    WaterLevelIntfControllerListener& m_interfaceListener;
+};
+
+} //namespace services
+} //namespace ajn
+
+#endif /* WATERLEVELINTFCONTROLLERIMPL_H_ */
diff --git a/cpp/src/interfaces/operation/CycleControlInterface.cc b/cpp/src/interfaces/operation/CycleControlInterface.cc
new file mode 100644
index 0000000..d0cd228
--- /dev/null
+++ b/cpp/src/interfaces/operation/CycleControlInterface.cc
@@ -0,0 +1,83 @@
+/******************************************************************************
+ * Copyright (c) 2013-2014, AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#include <alljoyn/hae/LogModule.h>
+#include <alljoyn/hae/interfaces/operation/CycleControlInterface.h>
+
+namespace ajn {
+namespace services {
+
+const uint16_t CycleControlInterface::s_interfaceVersion = 1;
+
+// Below none secure xml is only for test
+const qcc::String CycleControlInterface::s_xml =
+"<node xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance' xsi:noNamespaceSchemaLocation='http://www.allseenalliance.org/schemas/introspect.xsd'>"
+"    <interface name='org.alljoyn.SmartSpaces.Operation.CycleControl'>"
+"        <description language='en'>This interface provides capability to monitor the operational state of an appliance and to control it using relate commands</description>"
+"        <annotation name='org.alljoyn.Bus.Secure' value='true'/>"
+"        <property name='Version' type='q' access='read'>"
+"            <description language='en'>Interface version</description>"
+"            <annotation name='org.freedesktop.DBus.Property.EmitsChangedSignal' value='true'/>"
+"        </property>"
+"        <property name='OperationalState' type='y' access='read'>"
+"            <description language='en'>Current operational state of the appliance</description>"
+"            <annotation name='org.freedesktop.DBus.Property.EmitsChangedSignal' value='true'/>"
+"        </property>"
+"        <property name='SupportedOperationalStates' type='ay' access='read'>"
+"            <description language='en'>Operational states which are supported by the appliance</description>"
+"            <annotation name='org.freedesktop.DBus.Property.EmitsChangedSignal' value='false'/>"
+"        </property>"
+"        <property name='SupportedOperationalCommands' type='ay' access='read'>"
+"            <description language='en'>Operational commands which are supported by the appliance</description>"
+"            <annotation name='org.freedesktop.DBus.Property.EmitsChangedSignal' value='false'/>"
+"        </property>"
+"        <method name='ExecuteOperationalCommand'>"
+"            <description language='en'>Execute an operational command</description>"
+"            <arg name='command' type='y' direction='in'>"
+"                <description language='en'>Operational command to be executed</description>"
+"            </arg>"
+"        </method>"
+"        <signal name='EndOfCycle' sessionless='true'>"
+"            <description language='en'>This signal is emitted if the cycle is completed</description>"
+"        </signal>"
+"    </interface>"
+"</node>"
+""
+;
+
+const qcc::String CycleControlInterface::s_prop_Version = "Version";
+const qcc::String CycleControlInterface::s_prop_OperationalState = "OperationalState";
+const qcc::String CycleControlInterface::s_prop_SupportedOperationalCommands = "SupportedOperationalCommands";
+const qcc::String CycleControlInterface::s_prop_SupportedOperationalStates = "SupportedOperationalStates";
+const qcc::String CycleControlInterface::s_method_ExecuteCommand = "ExecuteOperationalCommand";
+const qcc::String CycleControlInterface::s_signal_EndOfCycle = "EndOfCycle";
+const qcc::String CycleControlInterface::OPERATIONAL_STATE_STRINGS[6] = {
+        "Idle",
+        "Working",
+        "Ready to start",
+        "Delayed start",
+        "Paused",
+        "End of cycle"
+    };
+const qcc::String CycleControlInterface::OPERATIONAL_COMMAND_STRINGS[4] = {
+        "Start",
+        "Stop",
+        "Pause",
+        "Resume"
+    };
+
+} //namespace services
+} //namespace ajn
diff --git a/cpp/src/interfaces/operation/CycleControlIntfControlleeImpl.cc b/cpp/src/interfaces/operation/CycleControlIntfControlleeImpl.cc
new file mode 100644
index 0000000..6eb28ca
--- /dev/null
+++ b/cpp/src/interfaces/operation/CycleControlIntfControlleeImpl.cc
@@ -0,0 +1,332 @@
+/******************************************************************************
+ * Copyright (c) 2013-2014, AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#include <qcc/Util.h>
+#include <algorithm>
+#include <alljoyn/hae/LogModule.h>
+#include <alljoyn/hae/interfaces/operation/CycleControlIntfControlleeListener.h>
+
+
+#include "CycleControlIntfControlleeImpl.h"
+#include <alljoyn/hae/HaeBusObject.h>
+
+using namespace qcc;
+using namespace std;
+
+namespace ajn {
+namespace services {
+
+HaeInterface* CycleControlIntfControlleeImpl::CreateInterface(BusAttachment& busAttachment, InterfaceControlleeListener& listener, HaeBusObject& haeBusObject)
+{
+    return new CycleControlIntfControlleeImpl(busAttachment, dynamic_cast<CycleControlIntfControlleeListener&>(listener), haeBusObject);
+}
+
+CycleControlIntfControlleeImpl::CycleControlIntfControlleeImpl(BusAttachment& busAttachment, CycleControlIntfControlleeListener& listener, HaeBusObject& haeBusObject) :
+    InterfaceControllee(haeBusObject),
+    m_busAttachment(busAttachment),
+    m_interfaceListener(listener),
+    m_currentState(OPERATIONAL_STATE_READY_TO_START)
+{
+}
+
+CycleControlIntfControlleeImpl::~CycleControlIntfControlleeImpl()
+{
+}
+
+QStatus CycleControlIntfControlleeImpl::Init()
+{
+    QStatus status = HaeInterface::Init();
+
+    const InterfaceDescription::Member* member = m_interfaceDescription->GetMember(s_method_ExecuteCommand.c_str());
+    MessageReceiver::MethodHandler methodHandler = static_cast<MessageReceiver::MethodHandler>(&CycleControlIntfControlleeImpl::OnExecuteCommand);
+
+    m_methodHandlers.push_back(make_pair(member, methodHandler));
+
+    return status;
+}
+
+QStatus CycleControlIntfControlleeImpl::OnGetProperty(const String propName, MsgArg& val)
+{
+    QStatus status = ER_OK;
+
+    cout << "OnGet property. propname = " << propName << endl;
+    if (!(s_prop_Version.compare(propName)))
+    {
+        val.typeId = ALLJOYN_UINT16;
+        val.v_uint16 = GetInterfaceVersion();
+    }
+    else if(!s_prop_SupportedOperationalCommands.compare(propName))
+    {
+        SupportedOperationalCommands commands = GetSupportedCommands();
+        uint8_t vals[commands.size()];
+        size_t i = 0;
+
+        for(i = 0; i < commands.size(); i++)
+        {
+            vals[i] = (uint8_t)commands[i];
+        }
+        val.Set("ay", sizeof(vals)/sizeof(uint8_t), vals);
+        val.Stabilize();
+    }
+    else if(!s_prop_SupportedOperationalStates.compare(propName))
+    {
+        SupportedOperationalStates states = GetSupportedStates();
+        uint8_t vals[states.size()];
+        size_t i = 0;
+
+        for(i = 0; i < states.size(); i++)
+        {
+            vals[i] = (uint8_t)states[i];
+        }
+        val.Set("ay", sizeof(vals)/ sizeof(uint8_t), vals);
+        val.Stabilize();
+    }
+    else
+    {
+        if (s_retrievingActualPropertyValue)
+        {
+            if(!s_prop_OperationalState.compare(propName))
+            {
+                CycleControlOperationalState state;
+                status = m_interfaceListener.OnGetOperationalState(state);
+                if (status != ER_OK)
+                {
+                    state = GetOperationalState();
+                    QCC_LogError(status, ("%s: failed to get actual property value from application. use previous value.", __func__));
+                    status = ER_OK;
+                }
+                else
+                {
+                    SetOperationalState(state);
+                }
+                val.typeId = ALLJOYN_BYTE;
+                val.v_byte = (uint8_t)state;
+            }
+            else
+            {
+                status = ER_BUS_NO_SUCH_PROPERTY;
+            }
+        }
+        else
+        {
+            if (!(s_prop_OperationalState.compare(propName)))
+            {
+                const CycleControlOperationalState state = GetOperationalState();
+                val.typeId = ALLJOYN_BYTE;
+                val.v_byte = (uint8_t)state;
+            }
+            else
+            {
+                status = ER_BUS_NO_SUCH_PROPERTY;
+            }
+        }
+    }
+    return status;
+}
+
+QStatus CycleControlIntfControlleeImpl::OnSetProperty(const String propName, MsgArg& val)
+{
+    QStatus status = ER_OK;
+
+    return status;
+}
+
+void CycleControlIntfControlleeImpl::OnMethodHandler(const InterfaceDescription::Member* member, Message& msg)
+{
+    QStatus status = ER_OK;
+    bool isFound = false;
+    MethodHandlers::const_iterator it;
+    for (it = m_methodHandlers.begin(); it != m_methodHandlers.end(); ++it) {
+        if (it->first == member) {
+            MessageReceiver::MethodHandler handler = it->second;
+            (this->*handler)(member, msg);
+            isFound = true;
+            break;
+        }
+    }
+
+    if (!isFound) {
+        status = ER_BUS_METHOD_CALL_ABORTED;
+        QCC_LogError(status, ("%s: could not found method handler.", __func__));
+        m_busObject.ReplyMethodCall(msg, status);
+    }
+}
+
+void CycleControlIntfControlleeImpl::OnExecuteCommand(const InterfaceDescription::Member* member, Message& msg)
+{
+    QStatus status = ER_OK;
+    const MsgArg* args = NULL;
+    size_t numArgs = 0;
+    msg->GetArgs(numArgs, args);
+    ErrorCode  error = ErrorCode::NOT_ERROR;
+    CycleControlOperationalState newState;
+
+    if (numArgs == 1)
+    {
+        CycleControlOperationalCommand command = (CycleControlOperationalCommand)args[0].v_byte;
+
+        cout << "command: " << (int)command << "; command string: " << OPERATIONAL_COMMAND_STRINGS[command] << endl;
+
+        SupportedOperationalCommands::iterator it;
+        it = std::find(m_supportedCommands.begin(),m_supportedCommands.end(),command);
+        if(it == m_supportedCommands.end())
+        {
+            m_busObject.ReplyMethodCall(msg, HaeInterface::GetInterfaceErrorName(ErrorCode::INVALID_VALUE).c_str(), HaeInterface::GetInterfaceErrorMessage(ErrorCode::INVALID_VALUE).c_str());
+            return;
+        }
+
+
+        status = m_interfaceListener.OnExecuteCommand(command, newState, error);
+        if (status!= ER_OK)
+        {
+            QCC_LogError(status,("%s: failed to execute command.", __func__));
+            m_busObject.ReplyMethodCall(msg, status);
+            return;
+        }
+        else //status was not set (status is ER_OK)
+        {
+            if(error != ErrorCode::NOT_ERROR)
+                m_busObject.ReplyMethodCall(msg, HaeInterface::GetInterfaceErrorName(error).c_str(), HaeInterface::GetInterfaceErrorMessage(error).c_str());
+            else
+                m_busObject.ReplyMethodCall(msg, status);
+        }
+    }
+    else
+    {
+        m_busObject.ReplyMethodCall(msg, ER_INVALID_DATA);
+    }
+
+    if(newState == OPERATIONAL_STATE_END_OF_CYCLE)
+    {
+        status = EmitEndOfCycle();
+        if(status != ER_OK)
+            QCC_LogError(status, ("%s: failed to emit EndOfCycle signal.", __func__));
+    }
+}
+
+QStatus CycleControlIntfControlleeImpl::SetOperationalState(CycleControlOperationalState state)
+{
+    SupportedOperationalStates::iterator it;
+    it = std::find(m_supportedStates.begin(),m_supportedStates.end(),state);
+    if(it == m_supportedStates.end())
+        return ER_FAIL;
+
+    QStatus status = ER_OK;
+    cout << "Set operational state to '" << OPERATIONAL_STATE_STRINGS[state] << "'" <<endl;
+
+    if (m_currentState != state)
+    {
+        MsgArg val;
+        val.typeId = ALLJOYN_BYTE;
+        val.v_byte = (uint8_t)state;
+        m_currentState = state;
+        cout << "emitting propchanged" << endl;
+        m_busObject.EmitPropChanged(GetInterfaceName().c_str(), s_prop_OperationalState.c_str(), val, 0, ALLJOYN_FLAG_GLOBAL_BROADCAST);
+    }
+    return status;
+}
+
+QStatus CycleControlIntfControlleeImpl::SetSupportedCommands(SupportedOperationalCommands commands)
+{
+    QStatus status = ER_OK;
+
+    bool listChanged = false;
+    if(m_supportedCommands.size() != commands.size())
+        listChanged = true;
+    else
+    {
+        for (size_t i = 0; i < commands.size(); i ++)
+        {
+            SupportedOperationalCommands::iterator it;
+            it = std::find(m_supportedCommands.begin(), m_supportedCommands.end(), commands[i]);
+            if(it == m_supportedCommands.end())
+            {
+                listChanged = true;
+                break;
+            }
+        }
+    }
+
+    if(listChanged)
+    {
+        m_supportedCommands.clear();
+        for(unsigned int i =0;i<commands.size();i++)
+            m_supportedCommands.push_back(commands[i]);
+        uint8_t vals[m_supportedCommands.size()];
+        MsgArg val;
+        size_t i = 0;
+
+        for(i = 0; i < m_supportedCommands.size(); i++)
+        {
+            vals[i] = (uint8_t)m_supportedCommands[i];
+        }
+        val.Set("ay", sizeof(vals)/ sizeof(uint8_t), vals);
+        val.Stabilize();
+        m_busObject.EmitPropChanged(GetInterfaceName().c_str(),s_prop_SupportedOperationalCommands.c_str(), val, 0, ALLJOYN_FLAG_GLOBAL_BROADCAST);
+    }
+    return status;
+}
+QStatus CycleControlIntfControlleeImpl::SetSupportedStates(SupportedOperationalStates states)
+{
+    QStatus status = ER_OK;
+
+    bool listChanged = false;
+    if(m_supportedStates.size() != states.size())
+        listChanged  = true;
+    else
+    {
+        for (size_t i = 0; i < states.size(); i ++)
+        {
+            SupportedOperationalStates::iterator it;
+            it = std::find(m_supportedStates.begin(), m_supportedStates.end(), states[i]);
+            if(it == m_supportedStates.end())
+            {
+                listChanged = true;
+                break;
+            }
+        }
+    }
+
+    if(listChanged)
+    {
+        m_supportedStates.clear();
+        for(unsigned int i =0;i<states.size();i++)
+            m_supportedStates.push_back(states[i]);
+        uint8_t vals[m_supportedStates.size()];
+
+        MsgArg val;
+        size_t i = 0;
+
+        for(i = 0; i < m_supportedStates.size(); i++)
+        {
+            vals[i] = (uint8_t)m_supportedStates[i];
+        }
+        val.Set("ay", sizeof(vals)/ sizeof(uint8_t), vals);
+        val.Stabilize();
+        m_busObject.EmitPropChanged(GetInterfaceName().c_str(),s_prop_SupportedOperationalStates.c_str(), val, 0, ALLJOYN_FLAG_GLOBAL_BROADCAST);
+    }
+    return status;
+}
+
+QStatus CycleControlIntfControlleeImpl::EmitEndOfCycle()
+{
+    const InterfaceDescription::Member* member = GetInterfaceDescription()->GetMember(s_signal_EndOfCycle.c_str());
+    assert(member);
+    return m_busObject.Signal(NULL, 0, *member, NULL, 0, 0,ALLJOYN_FLAG_SESSIONLESS);
+}
+
+} //namespace services
+} //namespace ajn
diff --git a/cpp/src/interfaces/operation/CycleControlIntfControlleeImpl.h b/cpp/src/interfaces/operation/CycleControlIntfControlleeImpl.h
new file mode 100644
index 0000000..d4cf129
--- /dev/null
+++ b/cpp/src/interfaces/operation/CycleControlIntfControlleeImpl.h
@@ -0,0 +1,159 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#ifndef CYCLECONTROLINTFCONTROLLEEIMPL_H_
+#define CYCLECONTROLINTFCONTROLLEEIMPL_H_
+
+#include <alljoyn/Status.h>
+#include <alljoyn/BusAttachment.h>
+#include <alljoyn/InterfaceDescription.h>
+#include <alljoyn/hae/interfaces/InterfaceControllee.h>
+#include <alljoyn/hae/interfaces/InterfaceControlleeListener.h>
+#include <alljoyn/hae/interfaces/operation/CycleControlIntfControllee.h>
+
+namespace ajn {
+namespace services {
+
+class CycleControlIntfControlleeListener;
+class HaeBusObject;
+
+/**
+ * CycleControl Interface Controllee implementation class
+ */
+class CycleControlIntfControlleeImpl : public InterfaceControllee, public CycleControlIntfControllee {
+  public:
+    /**
+     * Create interface
+     */
+    static HaeInterface* CreateInterface(BusAttachment& busAttachment, InterfaceControlleeListener& listener, HaeBusObject& haeBusObject);
+
+    /**
+     * Constructor of CycleControlIntfControlleeImpl
+     */
+    CycleControlIntfControlleeImpl(BusAttachment& busAttachment, CycleControlIntfControlleeListener& listener, HaeBusObject& haeBusObject);
+
+    /**
+     * Destructor of CycleControlIntfControlleeImpl
+     */
+    virtual ~CycleControlIntfControlleeImpl();
+
+    /**
+     * Initialize interface
+     * @return status
+     */
+     virtual QStatus Init();
+
+    /**
+     * a callback function for getting property.
+     * @param propName   Identifies the property to get
+     * @param[out] val   Returns the property value. The type of this value is the actual value type.
+     * @return status
+     */
+    virtual QStatus OnGetProperty(const qcc::String propName, MsgArg& val);
+
+    /**
+     * a callback function for setting property.
+     * @param propName  Identifies the property to set
+     * @param val       The property value to set. The type of this value is the actual value type.
+     */
+    virtual QStatus OnSetProperty(const qcc::String propName, MsgArg& val);
+
+    /**
+     * method handler
+     * @param member    Method interface member entry.
+     * @param message   The received method call message.
+     */
+    virtual void OnMethodHandler(const InterfaceDescription::Member* member, Message& msg);
+
+    /**
+     * Get method handlers
+     * @return MethodHandlers
+     */
+    virtual const MethodHandlers& GetMethodHanders() const { return m_methodHandlers; }
+
+    /**
+     * Get bus attachment
+     * @return bus attachment
+     */
+    virtual BusAttachment& GetBusAttachment() const { return m_busAttachment; }
+
+    /**
+     * Get OperationalState
+     * @return operationalState
+     */
+    virtual const CycleControlOperationalState GetOperationalState() const { return m_currentState; }
+
+    /**
+     * Set OperationalState
+     * @param[in] state operationalState
+     * @return ER_OK on successful
+     */
+    virtual QStatus SetOperationalState(CycleControlOperationalState state);
+
+    /**
+     * Get SupportedOperationalCommands
+     * @return the list of supported commands
+     */
+    virtual const SupportedOperationalCommands& GetSupportedCommands() const {return m_supportedCommands; }
+
+    /**
+     * Get SupportedOperationalStates
+     * @return the list of supported states
+     */
+    virtual const SupportedOperationalStates& GetSupportedStates() const {return m_supportedStates; }
+
+    /**
+     * Set SupportedOperationalCommands
+     * @param[in] commands the list of supported commands
+     * @return ER_OK on successful
+     */
+    virtual QStatus SetSupportedCommands(SupportedOperationalCommands commands);
+
+    /**
+     * Set SupportedOperationalStates
+     * @param[in] states the list of supported states
+     * @return ER_OK on successful
+     */
+    virtual QStatus SetSupportedStates(SupportedOperationalStates states);
+
+    /**
+     * EndOfCycle emitter
+     * @return ER_OK on successful
+     */
+    virtual QStatus EmitEndOfCycle();
+
+    /**
+     * Handler of ExecuteCommand method
+     * @param member
+     * @param msg reference of alljoyn Message
+     */
+    void OnExecuteCommand(const InterfaceDescription::Member* member, Message& msg);
+
+  private:
+    CycleControlIntfControlleeImpl();
+
+    BusAttachment& m_busAttachment;
+    CycleControlIntfControlleeListener& m_interfaceListener;
+    MethodHandlers m_methodHandlers;
+    CycleControlOperationalState m_currentState;
+    SupportedOperationalCommands m_supportedCommands;
+    SupportedOperationalStates m_supportedStates;
+};
+
+} //namespace services
+} //namespace ajn
+
+#endif /* CYCLECONTROLINTFCONTROLLEEIMPL_H_ */
diff --git a/cpp/src/interfaces/operation/CycleControlIntfControllerImpl.cc b/cpp/src/interfaces/operation/CycleControlIntfControllerImpl.cc
new file mode 100644
index 0000000..aba1fcb
--- /dev/null
+++ b/cpp/src/interfaces/operation/CycleControlIntfControllerImpl.cc
@@ -0,0 +1,235 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#include <qcc/Util.h>
+
+#include <alljoyn/hae/LogModule.h>
+#include <alljoyn/hae/HaeProxyBusObject.h>
+#include <alljoyn/hae/interfaces/operation/CycleControlIntfControllerListener.h>
+
+#include "CycleControlIntfControllerImpl.h"
+
+
+using namespace qcc;
+using namespace std;
+
+namespace ajn {
+namespace services {
+
+HaeInterface* CycleControlIntfControllerImpl::CreateInterface(BusAttachment& busAttachment, InterfaceControllerListener& listener, HaeProxyBusObject& haeProxyObject)
+{
+    return new CycleControlIntfControllerImpl(busAttachment, dynamic_cast<CycleControlIntfControllerListener&>(listener), haeProxyObject);
+}
+
+CycleControlIntfControllerImpl::CycleControlIntfControllerImpl(BusAttachment& busAttachment, CycleControlIntfControllerListener& listener, HaeProxyBusObject& haeProxyObject) :
+    InterfaceController(haeProxyObject),
+    m_busAttachment(busAttachment),
+    m_interfaceListener(listener)
+{
+}
+
+CycleControlIntfControllerImpl::~CycleControlIntfControllerImpl()
+{
+}
+
+QStatus CycleControlIntfControllerImpl::Init()
+{
+    QStatus status = HaeInterface::Init();
+    if (ER_OK != status) {
+        QCC_LogError(status, ("%s: Interface init failed.", __func__));
+        return status;
+    }
+
+    status = m_proxyObject.RegisterPropertiesChangedListener(GetInterfaceName().c_str(), NULL, 0, *this, NULL);
+    if (ER_OK != status) {
+        QCC_LogError(status, ("%s: RegisterPropertiesChangedListener failed.", __func__));
+    }
+
+    const InterfaceDescription* intf = GetInterfaceDescription();
+    if (intf) {
+        const InterfaceDescription::Member* endOfCycleEmitted = intf->GetMember(s_signal_EndOfCycle.c_str());
+        if (endOfCycleEmitted)
+        {
+            status = m_busAttachment.RegisterSignalHandler(this, static_cast<MessageReceiver::SignalHandler>(&CycleControlIntfControllerImpl::EndOfCycleEmitted), endOfCycleEmitted, NULL);
+            if (ER_OK != status)
+            {
+                QCC_LogError(status, ("%s: Register EndOfCycle failed.", __func__));
+            }
+            m_busAttachment.AddMatch("type='signal',member='EndOfCycle',interface='org.alljoyn.SmartSpaces.Operation.CycleControl',sessionless='t'");
+        }
+        else
+        {
+            status = ER_FAIL;
+            QCC_LogError(status, ("%s: EndOfCycle signal is not exist.", __func__));
+        }
+    }
+    else
+    {
+        status = ER_FAIL;
+        QCC_LogError(status, ("%s: The interface description is not exist.", __func__));
+    }
+    return status;
+}
+
+void CycleControlIntfControllerImpl::PropertiesChanged(ProxyBusObject& obj, const char* ifaceName, const MsgArg& changed, const MsgArg& invalidated, void* context)
+{
+    MsgArg* entries;
+    size_t numEntries;
+
+    changed.Get("a{sv}", &numEntries, &entries);
+    for (size_t i = 0; i < numEntries; ++i) {
+        const char* propName;
+        MsgArg* propValue;
+        entries[i].Get("{sv}", &propName, &propValue);
+        String propNameStr(propName);
+
+        if (!s_prop_OperationalState.compare(propNameStr)) {
+            if (propValue->typeId == ALLJOYN_BYTE) {
+                uint8_t state = propValue->v_byte;
+                m_interfaceListener.OperationalStatePropertyChanged(obj.GetPath(), (CycleControlOperationalState)state);
+            }
+        }
+        else if(!s_prop_SupportedOperationalCommands.compare(propNameStr)) {
+            if(propValue->typeId == ALLJOYN_BYTE_ARRAY) {
+                uint8_t *vals;
+                size_t numVals;
+                propValue->Get("ay", &numVals, &vals);
+
+                SupportedOperationalCommands commands;
+                for (size_t i = 0; i < numVals; ++i)
+                    commands.push_back((CycleControlOperationalCommand)vals[i]);
+                m_interfaceListener.SupportedOperationalCommandsProperyChanged(obj.GetPath(), commands);
+            }
+        }
+        else if (!s_prop_SupportedOperationalStates.compare(propNameStr)) {
+            if(propValue->typeId == ALLJOYN_BYTE_ARRAY) {
+                uint8_t *vals;
+                size_t numVals;
+                propValue->Get("ay", &numVals, &vals);
+
+                SupportedOperationalStates states;
+                for (size_t i = 0; i < numVals; ++i)
+                    states.push_back((CycleControlOperationalState)vals[i]);
+                m_interfaceListener.SupportedOperationalStatesProperyChanged(obj.GetPath(), states);
+            }
+        }
+    }
+}
+
+QStatus CycleControlIntfControllerImpl::GetOperationalState(void* context)
+{
+    QStatus status = ER_OK;
+
+    status = m_proxyObject.GetPropertyAsync(GetInterfaceName().c_str(), s_prop_OperationalState.c_str(), this, (ProxyBusObject::Listener::GetPropertyCB)&CycleControlIntfControllerImpl::GetOperationalStatePropertyCB, context);
+
+    return status;
+}
+
+QStatus CycleControlIntfControllerImpl::GetSupportedOperationalCommands(void* context)
+{
+    QStatus status = ER_OK;
+
+    status = m_proxyObject.GetPropertyAsync(GetInterfaceName().c_str(), s_prop_SupportedOperationalCommands.c_str(), this, (ProxyBusObject::Listener::GetPropertyCB)&CycleControlIntfControllerImpl::GetSupportedOperationalCommandsPropertyCB, context);
+
+    cout << "Get SUpported operational commands. Status = " << status<<endl;
+    return status;
+}
+
+QStatus CycleControlIntfControllerImpl::GetSupportedOperationalStates(void* context)
+{
+    QStatus status = ER_OK;
+
+    status = m_proxyObject.GetPropertyAsync(GetInterfaceName().c_str(), s_prop_SupportedOperationalStates.c_str(), this, (ProxyBusObject::Listener::GetPropertyCB)&CycleControlIntfControllerImpl::GetSupportedOperationalStatesPropertyCB, context);
+
+    cout << "Get SUpported operational states. Status = " << status<<endl;
+    return status;
+}
+
+QStatus CycleControlIntfControllerImpl::ExecuteCommand(const CycleControlOperationalCommand command, void* context)
+{
+    MsgArg args[1];
+    args[0].Set("y", (uint8_t)command);
+
+    QStatus status = ER_OK;
+    status = m_proxyObject.MethodCallAsync(GetInterfaceName().c_str(), s_method_ExecuteCommand.c_str(), this, (MessageReceiver::ReplyHandler)&CycleControlIntfControllerImpl::ExecuteCommandReplyHandler, args, 1, context);
+    return status;
+}
+
+void CycleControlIntfControllerImpl::GetOperationalStatePropertyCB(QStatus status, ProxyBusObject* obj, const MsgArg& value, void* context)
+{
+    if (!obj) {
+        return;
+    }
+
+    uint8_t state;
+    value.Get("y", &state);
+
+    m_interfaceListener.GetOperationalStatePropertyCallback(status, obj->GetPath(), (CycleControlOperationalState)state, context);
+}
+
+void CycleControlIntfControllerImpl::GetSupportedOperationalCommandsPropertyCB(QStatus status, ProxyBusObject* obj, const MsgArg& value, void* context)
+{
+    if (!obj) {
+        return;
+    }
+    uint8_t *vals;
+    size_t numVals;
+    value.Get("ay", &numVals, &vals);
+
+    SupportedOperationalCommands commands;
+    for (size_t i = 0; i < numVals; ++i)
+        commands.push_back((CycleControlOperationalCommand)vals[i]);
+
+    m_interfaceListener.GetSupportedCommandsPropertyCallbalck(status, obj->GetPath(), commands,context);
+}
+
+void CycleControlIntfControllerImpl::GetSupportedOperationalStatesPropertyCB(QStatus status, ProxyBusObject* obj, const MsgArg& value, void* context)
+{
+    if (!obj) {
+        return;
+    }
+    uint8_t *vals;
+    size_t numVals;
+    value.Get("ay", &numVals, &vals);
+
+    SupportedOperationalStates states;
+    for (size_t i = 0; i < numVals; ++i) {
+        states.push_back((CycleControlOperationalState)vals[i]);
+    }
+    m_interfaceListener.GetSupportedStatesPropertyCallbalck(status, obj->GetPath(), states, context);
+}
+
+void CycleControlIntfControllerImpl::ExecuteCommandReplyHandler(Message& message, void* context)
+{
+    qcc::String errorMessage;
+    const char* errorName = message->GetErrorName(&errorMessage);
+    QStatus status = ER_OK;
+    if (message->GetType() != MESSAGE_METHOD_RET) {
+        status = ER_FAIL;
+    }
+    m_interfaceListener.OnExecuteCommandRespose(status, m_proxyObject.GetPath(), context,
+                                                errorName, errorMessage.c_str());
+}
+
+void CycleControlIntfControllerImpl::EndOfCycleEmitted(const InterfaceDescription::Member* member, const char* srcPath, Message& message)
+{
+    cout << "# CycleControlIntfControllerImpl::EndOfCycleEmitted" <<endl;
+    qcc::String path = String(srcPath);
+    m_interfaceListener.OnEndOfCycle(path);
+}
+
+} //namespace services
+} //namespace ajn
diff --git a/cpp/src/interfaces/operation/CycleControlIntfControllerImpl.h b/cpp/src/interfaces/operation/CycleControlIntfControllerImpl.h
new file mode 100644
index 0000000..3cf2c1f
--- /dev/null
+++ b/cpp/src/interfaces/operation/CycleControlIntfControllerImpl.h
@@ -0,0 +1,114 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#ifndef CYCLECONTROLINTFCONTROLLERIMPL_H_
+#define CYCLECONTROLINTFCONTROLLERIMPL_H_
+
+#include <alljoyn/Status.h>
+#include <alljoyn/BusAttachment.h>
+#include <alljoyn/hae/interfaces/InterfaceController.h>
+#include <alljoyn/hae/interfaces/operation/CycleControlIntfController.h>
+
+namespace ajn {
+namespace services {
+
+class CycleControlIntfControllerListener;
+class HaeProxyBusObject;
+
+/**
+ * CycleControl Interface Controller implementation class
+ */
+class CycleControlIntfControllerImpl : public InterfaceController, public CycleControlIntfController {
+  public:
+    /**
+     * Create interface
+     */
+    static HaeInterface* CreateInterface(BusAttachment& busAttachment, InterfaceControllerListener& listener, HaeProxyBusObject& haeProxyObject);
+
+    /**
+     * Constructor of CycleControlIntfControllerImpl
+     */
+    CycleControlIntfControllerImpl(BusAttachment& busAttachment, CycleControlIntfControllerListener& listener, HaeProxyBusObject& haeProxyObject);
+
+    /**
+     * Destructor of CycleControlIntfControllerImpl
+     */
+    virtual ~CycleControlIntfControllerImpl();
+
+    /**
+     * Initialize interface
+     * @return status
+     */
+    virtual QStatus Init();
+
+    /**
+     * Get bus attachment
+     * @return bus attachment
+     */
+    virtual BusAttachment& GetBusAttachment() const { return m_busAttachment; }
+
+    /**
+     * Get operational state
+     * @param[in] context
+     * @return status
+     */
+    virtual QStatus GetOperationalState(void* context);
+
+    /**
+     * Get supported operational commands
+     * @param[in] context
+     * @return status
+     */
+    virtual QStatus GetSupportedOperationalCommands(void* context);
+
+    /**
+     * Get supported operational states
+     * @param[in] context
+     * @return status
+     */
+    virtual QStatus GetSupportedOperationalStates(void* context);
+
+    /**
+     * Execute command
+     * @param[in] command to execute
+     * @param[in] context
+     * @return status
+     */
+    virtual QStatus ExecuteCommand(const CycleControlOperationalCommand command, void* context);
+
+  private:
+    CycleControlIntfControllerImpl();
+
+    void PropertiesChanged(ProxyBusObject& obj, const char* ifaceName, const MsgArg& changed, const MsgArg& invalidated, void* context);
+
+    void GetOperationalStatePropertyCB(QStatus status, ProxyBusObject* obj, const MsgArg& value, void* context);
+
+    void GetSupportedOperationalCommandsPropertyCB(QStatus status, ProxyBusObject* obj, const MsgArg& value, void* context);
+
+    void GetSupportedOperationalStatesPropertyCB(QStatus status, ProxyBusObject* obj, const MsgArg& value, void* context);
+
+    void EndOfCycleEmitted(const InterfaceDescription::Member* member, const char* srcPath, Message& message);
+
+    void ExecuteCommandReplyHandler(Message& message, void* context);
+
+    BusAttachment& m_busAttachment;
+    CycleControlIntfControllerListener& m_interfaceListener;
+};
+
+} //namespace services
+} //namespace ajn
+
+#endif /* CYCLECONTROLINTFCONTROLLERIMPL_H_ */
diff --git a/cpp/src/interfaces/operation/DishWashingCyclePhaseInterface.cc b/cpp/src/interfaces/operation/DishWashingCyclePhaseInterface.cc
new file mode 100644
index 0000000..d5dde86
--- /dev/null
+++ b/cpp/src/interfaces/operation/DishWashingCyclePhaseInterface.cc
@@ -0,0 +1,67 @@
+/******************************************************************************
+ * Copyright (c) 2013-2014, AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#include <alljoyn/hae/LogModule.h>
+#include <alljoyn/hae/interfaces/operation/DishWashingCyclePhaseInterface.h>
+
+namespace ajn {
+namespace services {
+
+const uint16_t DishWashingCyclePhaseInterface::s_interfaceVersion = 1;
+
+// Below none secure xml is only for test
+const qcc::String DishWashingCyclePhaseInterface::s_xml =
+"<node xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance' xsi:noNamespaceSchemaLocation='http://www.allseenalliance.org/schemas/introspect.xsd'>"
+"    <interface name='org.alljoyn.SmartSpaces.Operation.DishWashingCyclePhase'>"
+"        <description language='en'>This interface provides a capability to monitor the cycle phase of the dishwasher.</description>"
+"        <annotation name='org.alljoyn.Bus.Secure' value='true'/>"
+//"        <struct name='CyclePhaseDescriptor'>"
+//"            <field name='phase' type='y'/>"
+//"            <field name='name' type='s'/>"
+//"            <field name='description' type='s'/>"
+//"        </struct>"
+"        <property name='Version' type='q' access='read'>"
+"            <description language='en'>Interface version</description>"
+"            <annotation name='org.freedesktop.DBus.Property.EmitsChangedSignal' value='true'/>"
+"        </property>"
+"        <property name='CyclePhase' type='y' access='read'>"
+"            <description language='en'>Current cycle phase</description>"
+"            <annotation name='org.freedesktop.DBus.Property.EmitsChangedSignal' value='true'/>"
+"        </property>"
+"        <property name='SupportedCyclePhases' type='ay' access='read'>"
+"            <description language='en'>List of supported cycle phases</description>"
+"            <annotation name='org.freedesktop.DBus.Property.EmitsChangedSignal' value='true'/>"
+"        </property>"
+"        <method name='GetVendorPhasesDescription'>"
+"            <description language='en'>Get cycle phases description</description>"
+"            <arg name='languageTag' type='s' direction='in'>"
+"                <description language='en'>Preferred language to use in selecting output strings</description>"
+"            </arg>"
+"            <arg name='phasesDescription' type='a(yss)' direction='out'>"
+"                <description language='en'>Cycle phases description</description>"
+"            </arg>"
+"        </method>"
+"   </interface>"
+"</node>"
+;
+
+const qcc::String DishWashingCyclePhaseInterface::s_prop_Version = "Version";
+const qcc::String DishWashingCyclePhaseInterface::s_prop_CyclePhase = "CyclePhase";
+const qcc::String DishWashingCyclePhaseInterface::s_prop_SupportedCyclePhases = "SupportedCyclePhases";
+const qcc::String DishWashingCyclePhaseInterface::s_method_GetVendorPhasesDescription = "GetVendorPhasesDescription";
+const DishWashingCyclePhaseInterface::StandardCyclePhases DishWashingCyclePhaseInterface::m_standardCyclePhases = {DISH_WASHING_PHASE_UNAVAILABLE, DISH_WASHING_PHASE_PRE_WASH, DISH_WASHING_PHASE_WASH, DISH_WASHING_PHASE_RINSE, DISH_WASHING_PHASE_DRY};
+} //namespace services
+} //namespace ajn
diff --git a/cpp/src/interfaces/operation/DishWashingCyclePhaseIntfControlleeImpl.cc b/cpp/src/interfaces/operation/DishWashingCyclePhaseIntfControlleeImpl.cc
new file mode 100644
index 0000000..674015f
--- /dev/null
+++ b/cpp/src/interfaces/operation/DishWashingCyclePhaseIntfControlleeImpl.cc
@@ -0,0 +1,347 @@
+/******************************************************************************
+ * Copyright (c) 2013-2014, AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#include <qcc/Util.h>
+#include <vector>
+#include <algorithm>
+#include <alljoyn/hae/LogModule.h>
+#include <alljoyn/hae/HaeBusObject.h>
+#include <alljoyn/hae/interfaces/operation/DishWashingCyclePhaseIntfControlleeListener.h>
+
+#include "DishWashingCyclePhaseIntfControlleeImpl.h"
+
+using namespace qcc;
+using namespace std;
+
+namespace ajn {
+namespace services {
+
+HaeInterface* DishWashingCyclePhaseIntfControlleeImpl::CreateInterface(BusAttachment& busAttachment, InterfaceControlleeListener& listener, HaeBusObject& haeBusObject)
+{
+    return new DishWashingCyclePhaseIntfControlleeImpl(busAttachment, dynamic_cast<DishWashingCyclePhaseIntfControlleeListener&>(listener), haeBusObject);
+}
+
+DishWashingCyclePhaseIntfControlleeImpl::DishWashingCyclePhaseIntfControlleeImpl(BusAttachment& busAttachment, DishWashingCyclePhaseIntfControlleeListener& listener, HaeBusObject& haeBusObject) :
+    InterfaceControllee(haeBusObject),
+    m_busAttachment(busAttachment),
+    m_interfaceListener(listener),
+    m_cyclePhase(DishWashingCyclePhase::DISH_WASHING_PHASE_UNAVAILABLE)
+{
+}
+
+DishWashingCyclePhaseIntfControlleeImpl::~DishWashingCyclePhaseIntfControlleeImpl()
+{
+}
+
+QStatus DishWashingCyclePhaseIntfControlleeImpl::Init()
+{
+    QStatus status = HaeInterface::Init();
+
+    const InterfaceDescription::Member* member = m_interfaceDescription->GetMember(s_method_GetVendorPhasesDescription.c_str());
+    MessageReceiver::MethodHandler methodHandler = static_cast<MessageReceiver::MethodHandler>(&DishWashingCyclePhaseIntfControlleeImpl::OnGetCyclePhasesDescription);
+
+    m_methodHandlers.push_back(make_pair(member, methodHandler));
+
+    return status;
+}
+
+QStatus DishWashingCyclePhaseIntfControlleeImpl::OnGetProperty(const String propName, MsgArg& val)
+{
+    QStatus status = ER_OK;
+
+    if (!(s_prop_Version.compare(propName))) {
+        val.typeId = ALLJOYN_UINT16;
+        val.v_uint16 = GetInterfaceVersion();
+    }
+    else
+    {
+        if (s_retrievingActualPropertyValue)
+        {
+            if(!s_prop_CyclePhase.compare(propName))
+            {
+                uint8_t cyclePhase;
+                status = m_interfaceListener.OnGetCyclePhase(cyclePhase);
+                if (status != ER_OK) {
+                    cyclePhase = GetCyclePhase();
+                    QCC_LogError(status, ("%s: failed to get actual property value from application. use previous value.", __func__));
+                    status = ER_OK;
+                } else {
+                    SetCyclePhase(cyclePhase); // update the value in ChannelIntfControllee.
+                }
+
+                val.typeId = ALLJOYN_BYTE;
+                val.v_byte = (uint8_t)cyclePhase;
+
+            }
+            else if (!s_prop_SupportedCyclePhases.compare(propName))
+            {
+                SupportedCyclePhases supportedCyclePhases;
+                status = m_interfaceListener.OnGetSupportedCyclePhases(supportedCyclePhases);
+                if(status != ER_OK)
+                {
+                    supportedCyclePhases = GetSupportedCyclePhases();
+                    QCC_LogError(status, ("%s: failed to get actual property value from application. use previous value.", __func__));
+                }
+                else
+                {
+                    //update internal value
+                    SetSupportedCyclePhases(supportedCyclePhases);
+                }
+                uint8_t vals[supportedCyclePhases.size()];
+                size_t i = 0;
+
+                for(i = 0; i < supportedCyclePhases.size(); i++)
+                {
+                    vals[i] = (uint8_t)supportedCyclePhases[i];
+                }
+                val.Set("ay", sizeof(vals)/ sizeof(uint8_t), vals);
+                val.Stabilize();
+            }
+            else
+            {
+                status = ER_BUS_NO_SUCH_PROPERTY;
+            }
+        }
+        else
+        {
+            if(!s_prop_CyclePhase.compare(propName))
+            {
+                uint8_t cyclePhase;
+                cyclePhase = GetCyclePhase();
+
+                val.typeId = ALLJOYN_BYTE;
+                val.v_byte = (uint8_t)cyclePhase;
+            }
+            else if (!s_prop_SupportedCyclePhases.compare(propName))
+            {
+                SupportedCyclePhases supportedCyclePhases;
+                supportedCyclePhases = GetSupportedCyclePhases();
+                uint8_t vals[supportedCyclePhases.size()];
+                size_t i = 0;
+
+                for(i = 0; i < supportedCyclePhases.size(); i++)
+                {
+                    vals[i] = (uint8_t)supportedCyclePhases[i];
+                }
+                val.Set("ay", sizeof(vals)/ sizeof(uint8_t), vals);
+                val.Stabilize();
+            }
+            else
+            {
+                status = ER_BUS_NO_SUCH_PROPERTY;
+            }
+        }
+    }
+
+    return status;
+}
+
+QStatus DishWashingCyclePhaseIntfControlleeImpl::OnSetProperty(const String propName, MsgArg& val)
+{
+    QStatus status = ER_OK;
+
+    return status;
+}
+
+void DishWashingCyclePhaseIntfControlleeImpl::OnMethodHandler(const InterfaceDescription::Member* member, Message& msg)
+{
+    QStatus status = ER_OK;
+    bool isFound = false;
+    MethodHandlers::const_iterator it;
+    for (it = m_methodHandlers.begin(); it != m_methodHandlers.end(); ++it) {
+        if (it->first == member) {
+            MessageReceiver::MethodHandler handler = it->second;
+            (this->*handler)(member, msg);
+            isFound = true;
+            break;
+        }
+    }
+
+    if (!isFound) {
+        status = ER_BUS_METHOD_CALL_ABORTED;
+        QCC_LogError(status, ("%s: could not found method handler.", __func__));
+        m_busObject.ReplyMethodCall(msg, status);
+    }
+}
+QStatus DishWashingCyclePhaseIntfControlleeImpl::SetCyclePhase(const uint8_t cyclePhase)
+{
+    StandardCyclePhases::const_iterator stand_it;
+    std::vector<uint8_t>::iterator vend_it;
+
+    stand_it = std::find(m_standardCyclePhases.begin(), m_standardCyclePhases.end(), cyclePhase);
+    vend_it = std::find(m_vendorDefinedCyclePhases.begin(),m_vendorDefinedCyclePhases.end(),cyclePhase);
+
+    if(vend_it == m_vendorDefinedCyclePhases.end() && stand_it == m_standardCyclePhases.end())
+        return ER_FAIL;
+
+    SupportedCyclePhases::iterator supp_it;
+    supp_it = std::find(m_supportedCyclePhases.begin(),m_supportedCyclePhases.end(),cyclePhase);
+    if(supp_it == m_supportedCyclePhases.end())
+        return ER_FAIL;
+
+    if(m_cyclePhase != cyclePhase)
+    {
+        MsgArg arg;
+        arg.typeId = ALLJOYN_BYTE;
+        arg.v_byte = cyclePhase;
+        m_busObject.EmitPropChanged(GetInterfaceName().c_str(), s_prop_CyclePhase.c_str(), arg, 0, ALLJOYN_FLAG_GLOBAL_BROADCAST);
+        m_cyclePhase = cyclePhase;
+    }
+    return ER_OK;
+}
+
+QStatus DishWashingCyclePhaseIntfControlleeImpl::SetSupportedCyclePhases(const SupportedCyclePhases& supportedPhases)
+{
+    uint8_t vals[supportedPhases.size()];
+
+    bool listChanged = false;
+    if(m_supportedCyclePhases.size() != supportedPhases.size())
+        listChanged = true;
+    else
+    {
+        for(size_t i = 0 ; i < supportedPhases.size(); i++)
+        {
+            StandardCyclePhases::const_iterator stand_it;
+            std::vector<uint8_t>::iterator vend_it;
+
+            stand_it = std::find(m_standardCyclePhases.begin(), m_standardCyclePhases.end(), supportedPhases[i]);
+            vend_it = std::find(m_vendorDefinedCyclePhases.begin(),m_vendorDefinedCyclePhases.end(),supportedPhases[i]);
+
+            if(vend_it == m_vendorDefinedCyclePhases.end() && stand_it == m_standardCyclePhases.end())
+                return ER_FAIL;
+
+            SupportedCyclePhases::iterator it;
+            it = std::find(m_supportedCyclePhases.begin(),m_supportedCyclePhases.end(), supportedPhases[i]);
+            if(it == m_supportedCyclePhases.end())
+            {
+                listChanged = true;
+                break;
+            }
+        }
+    }
+
+    if(listChanged)
+    {
+        m_supportedCyclePhases.clear();
+
+        for(size_t i = 0 ; i < supportedPhases.size(); i ++)
+        {
+            m_supportedCyclePhases.push_back(supportedPhases[i]);
+            vals[i] = (uint8_t)supportedPhases[i];
+        }
+
+        MsgArg arg;
+        arg.Set("ay", sizeof(vals)/ sizeof(uint8_t), vals);
+        arg.Stabilize();
+
+        m_busObject.EmitPropChanged(GetInterfaceName().c_str(), s_prop_SupportedCyclePhases.c_str(), arg, 0 , ALLJOYN_FLAG_GLOBAL_BROADCAST);
+    }
+    return ER_OK;
+}
+
+void DishWashingCyclePhaseIntfControlleeImpl::OnGetCyclePhasesDescription(const InterfaceDescription::Member* member, Message& msg)
+{
+    cout << "DishWashingCyclePhaseIntfControlleeImpl::OnGetCyclePhasesDescription" << endl;
+    QStatus status = ER_OK;
+
+    const MsgArg* args = NULL;
+    size_t numArgs = 0;
+
+    msg->GetArgs(numArgs, args);
+
+    if (numArgs == 1)
+    {
+        qcc::String lang(args[0].v_string.str);
+        if(lang.compare("en"))
+        {
+            status = ER_LANGUAGE_NOT_SUPPORTED;
+            QCC_LogError(status, ("%s: language not suppoerted", __func__));
+            m_busObject.ReplyMethodCall(msg, status);
+        }
+        else
+        {
+            CyclePhaseDescriptions listOfDescriptions;
+            ErrorCode errorCode = NOT_ERROR;
+            status = m_interfaceListener.OnGetCyclePhasesDescriptions(lang, listOfDescriptions, errorCode);
+            if(status == ER_OK)
+            {
+                int numReturned = listOfDescriptions.size();
+                DishWashingCyclePhaseInterface::CyclePhaseDescriptions::const_iterator citer;
+                MsgArg args[numReturned];
+                MsgArg retArgs[1];
+                int i=0;
+
+                for(citer = listOfDescriptions.begin(); citer != listOfDescriptions.end(); citer++, i++) {
+                    status = args[i].Set("(yss)", (uint8_t)citer->phase, citer->name.c_str(), citer->description.c_str());
+                    args[i].Stabilize();
+                }
+                status = retArgs[0].Set("a(yss)", i, args);
+                retArgs[0].Stabilize();
+                status = m_busObject.ReplyMethodCall(msg, retArgs, ArraySize(retArgs));
+            }
+            else
+            {
+                if (errorCode == NOT_ERROR)
+                {
+                    QCC_LogError(status, ("%s: status is not ER_OK, but errorCode was not set.", __func__));
+                    m_busObject.ReplyMethodCall(msg, status);
+                }
+                else
+                {
+                    m_busObject.ReplyMethodCall(msg, HaeInterface::GetInterfaceErrorName(errorCode).c_str(),HaeInterface::GetInterfaceErrorMessage(errorCode).c_str());
+                }
+            }
+        }
+    }
+    else
+    {
+        m_busObject.ReplyMethodCall(msg, ER_INVALID_DATA);
+    }
+}
+QStatus DishWashingCyclePhaseIntfControlleeImpl::SetVendorDefinedCyclePhases(const std::vector<uint8_t>& vendorPhases)
+{
+    for(size_t i = 0 ; i < vendorPhases.size(); i++)
+    {
+        if(vendorPhases[i] < 0x80 )
+            return ER_FAIL;
+    }
+    bool listChanged = false;
+    if(m_vendorDefinedCyclePhases.size() != vendorPhases.size())
+            listChanged = true;
+    else
+    {
+        for(size_t i = 0 ; i < vendorPhases.size(); i++)
+        {
+            std::vector<uint8_t>::iterator it;
+            it = std::find(m_vendorDefinedCyclePhases.begin(),m_vendorDefinedCyclePhases.end(), vendorPhases[i]);
+            if(it == m_vendorDefinedCyclePhases.end())
+            {
+                listChanged = true;
+                break;
+            }
+        }
+    }
+    if(listChanged)
+    {
+        m_vendorDefinedCyclePhases.clear();
+        for (size_t i =0;i<vendorPhases.size();i++)
+            m_vendorDefinedCyclePhases.push_back(vendorPhases[i]);
+    }
+    return ER_OK;
+}
+
+} //namespace services
+} //namespace ajn
diff --git a/cpp/src/interfaces/operation/DishWashingCyclePhaseIntfControlleeImpl.h b/cpp/src/interfaces/operation/DishWashingCyclePhaseIntfControlleeImpl.h
new file mode 100644
index 0000000..9d22abe
--- /dev/null
+++ b/cpp/src/interfaces/operation/DishWashingCyclePhaseIntfControlleeImpl.h
@@ -0,0 +1,119 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#ifndef DISHWASHINGCYCLEPHASEINTFCONTROLLEEIMPL_H_
+#define DISHWASHINGCYCLEPHASEINTFCONTROLLEEIMPL_H_
+
+#include <alljoyn/Status.h>
+#include <alljoyn/BusAttachment.h>
+#include <alljoyn/InterfaceDescription.h>
+#include <alljoyn/hae/interfaces/InterfaceControllee.h>
+#include <alljoyn/hae/interfaces/InterfaceControlleeListener.h>
+#include <alljoyn/hae/interfaces/operation/DishWashingCyclePhaseIntfControllee.h>
+
+namespace ajn {
+namespace services {
+
+class DishWashingCyclePhaseIntfControlleeListener;
+class HaeBusObject;
+
+/**
+ * DishWashingCyclePhase Interface Controllee implementation class
+ */
+class DishWashingCyclePhaseIntfControlleeImpl : public InterfaceControllee, public DishWashingCyclePhaseIntfControllee {
+  public:
+    /**
+     * Create interface
+     */
+    static HaeInterface* CreateInterface(BusAttachment& busAttachment, InterfaceControlleeListener& listener, HaeBusObject& haeBusObject);
+
+    /**
+     * Constructor of DishWashingCyclePhaseIntfControlleeImpl
+     */
+    DishWashingCyclePhaseIntfControlleeImpl(BusAttachment& busAttachment, DishWashingCyclePhaseIntfControlleeListener& listener, HaeBusObject& haeBusObject);
+
+    /**
+     * Destructor of DishWashingCyclePhaseIntfControlleeImpl
+     */
+    virtual ~DishWashingCyclePhaseIntfControlleeImpl();
+
+    /**
+     * Initialize interface
+     * @return status
+     */
+     virtual QStatus Init();
+
+    /**
+     * a callback function for getting property.
+     * @param propName   Identifies the property to get
+     * @param[out] val   Returns the property value. The type of this value is the actual value type.
+     * @return status
+     */
+    virtual QStatus OnGetProperty(const qcc::String propName, MsgArg& val);
+
+    /**
+     * a callback function for setting property.
+     * @param propName  Identifies the property to set
+     * @param val       The property value to set. The type of this value is the actual value type.
+     */
+    virtual QStatus OnSetProperty(const qcc::String propName, MsgArg& val);
+
+    /**
+     * method handler
+     * @param member    Method interface member entry.
+     * @param message   The received method call message.
+     */
+    virtual void OnMethodHandler(const InterfaceDescription::Member* member, Message& msg);
+
+    /**
+     * Get method handlers
+     * @return MethodHandlers
+     */
+    virtual const MethodHandlers& GetMethodHanders() const { return m_methodHandlers; }
+
+    /**
+     * Get bus attachment
+     * @return bus attachment
+     */
+    virtual BusAttachment& GetBusAttachment() const { return m_busAttachment; }
+
+
+    virtual const uint8_t GetCyclePhase() const { return m_cyclePhase; }
+
+    virtual QStatus SetCyclePhase(const uint8_t cyclePhase);
+
+    virtual const SupportedCyclePhases& GetSupportedCyclePhases() const { return m_supportedCyclePhases; }
+
+    virtual QStatus SetSupportedCyclePhases(const SupportedCyclePhases& descriptions);
+
+    void OnGetCyclePhasesDescription(const InterfaceDescription::Member* member, Message& msg);
+
+    virtual QStatus SetVendorDefinedCyclePhases(const std::vector<uint8_t>& vendorPhases);
+  private:
+    DishWashingCyclePhaseIntfControlleeImpl();
+
+    BusAttachment& m_busAttachment;
+    DishWashingCyclePhaseIntfControlleeListener& m_interfaceListener;
+    MethodHandlers m_methodHandlers;
+    uint8_t m_cyclePhase;
+    SupportedCyclePhases m_supportedCyclePhases;
+    std::vector<uint8_t> m_vendorDefinedCyclePhases;
+};
+
+} //namespace services
+} //namespace ajn
+
+#endif /* DISHWASHINGCYCLEPHASEINTFCONTROLLEEIMPL_H_ */
diff --git a/cpp/src/interfaces/operation/DishWashingCyclePhaseIntfControllerImpl.cc b/cpp/src/interfaces/operation/DishWashingCyclePhaseIntfControllerImpl.cc
new file mode 100644
index 0000000..cd8145f
--- /dev/null
+++ b/cpp/src/interfaces/operation/DishWashingCyclePhaseIntfControllerImpl.cc
@@ -0,0 +1,197 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#include <qcc/Util.h>
+
+#include <alljoyn/hae/LogModule.h>
+#include <alljoyn/hae/HaeProxyBusObject.h>
+#include <alljoyn/hae/interfaces/operation/DishWashingCyclePhaseIntfControllerListener.h>
+
+#include "DishWashingCyclePhaseIntfControllerImpl.h"
+
+using namespace qcc;
+using namespace std;
+
+namespace ajn {
+namespace services {
+
+HaeInterface* DishWashingCyclePhaseIntfControllerImpl::CreateInterface(BusAttachment& busAttachment, InterfaceControllerListener& listener, HaeProxyBusObject& haeProxyObject)
+{
+    return new DishWashingCyclePhaseIntfControllerImpl(busAttachment, dynamic_cast<DishWashingCyclePhaseIntfControllerListener&>(listener), haeProxyObject);
+}
+
+DishWashingCyclePhaseIntfControllerImpl::DishWashingCyclePhaseIntfControllerImpl(BusAttachment& busAttachment, DishWashingCyclePhaseIntfControllerListener& listener, HaeProxyBusObject& haeProxyObject) :
+    InterfaceController(haeProxyObject),
+    m_busAttachment(busAttachment),
+    m_interfaceListener(listener)
+{
+}
+
+DishWashingCyclePhaseIntfControllerImpl::~DishWashingCyclePhaseIntfControllerImpl()
+{
+}
+
+QStatus DishWashingCyclePhaseIntfControllerImpl::Init()
+{
+    QStatus status = HaeInterface::Init();
+    if (ER_OK != status) {
+        QCC_LogError(status, ("%s: Interface init failed.", __func__));
+        return status;
+    }
+
+    status = m_proxyObject.RegisterPropertiesChangedListener(GetInterfaceName().c_str(), NULL, 0, *this, NULL);
+    if (ER_OK != status) {
+        QCC_LogError(status, ("%s: RegisterPropertiesChangedListener failed.", __func__));
+    }
+
+    return status;
+}
+
+void DishWashingCyclePhaseIntfControllerImpl::PropertiesChanged(ProxyBusObject& obj, const char* ifaceName, const MsgArg& changed, const MsgArg& invalidated, void* context)
+{
+    MsgArg* entries;
+    size_t numEntries;
+
+    changed.Get("a{sv}", &numEntries, &entries);
+    for (size_t i = 0; i < numEntries; ++i) {
+        const char* propName;
+        MsgArg* propValue;
+        entries[i].Get("{sv}", &propName, &propValue);
+        String propNameStr(propName);
+
+        if (!s_prop_CyclePhase.compare(propNameStr)) {
+            if (propValue->typeId == ALLJOYN_BYTE) {
+                DishWashingCyclePhaseInterface::DishWashingCyclePhase cyclePhase = (DishWashingCyclePhaseInterface::DishWashingCyclePhase)propValue->v_byte;
+                m_interfaceListener.OnCyclePhasePropertyChanged(obj.GetPath(), cyclePhase);
+            }
+        } else if (!s_prop_SupportedCyclePhases.compare(propNameStr)) {
+            if (propValue->typeId == ALLJOYN_BYTE_ARRAY) {
+                DishWashingCyclePhaseInterface::SupportedCyclePhases supportedCyclePhases;
+                uint8_t *vals;
+                size_t numVals;
+                propValue->Get("ay", &numVals, &vals);
+
+                for (size_t i = 0; i < numVals; ++i)
+                    supportedCyclePhases.push_back((DishWashingCyclePhaseInterface::DishWashingCyclePhase)vals[i]);
+                m_interfaceListener.OnSupportedCyclePhasesPropertyChanged(obj.GetPath(), supportedCyclePhases);
+            }
+        }
+    }
+}
+
+QStatus DishWashingCyclePhaseIntfControllerImpl::GetCyclePhase(void* context)
+{
+    QStatus status = ER_OK;
+
+    status = m_proxyObject.GetPropertyAsync(GetInterfaceName().c_str(),s_prop_CyclePhase.c_str(),this,(ProxyBusObject::Listener::GetPropertyCB)&DishWashingCyclePhaseIntfControllerImpl::GetCyclePhasePropertyCB,context);
+
+    return status;
+
+}
+
+QStatus DishWashingCyclePhaseIntfControllerImpl::GetSupportedCyclePhases(void* context )
+{
+    QStatus status = ER_OK;
+
+    status = m_proxyObject.GetPropertyAsync(GetInterfaceName().c_str(),s_prop_SupportedCyclePhases.c_str(),this,(ProxyBusObject::Listener::GetPropertyCB)&DishWashingCyclePhaseIntfControllerImpl::GetSupportedCyclePhasesPropertyCB,context);
+
+    return status;
+}
+
+QStatus DishWashingCyclePhaseIntfControllerImpl::GetCyclePhasesDescriptions(const qcc::String& language, void* context)
+{
+    QStatus status = ER_OK;
+
+    MsgArg args[1];
+    args[0].typeId = ALLJOYN_STRING;
+    args[0].v_string.str = language.c_str();
+    args[0].v_string.len = language.size();
+
+    status = m_proxyObject.MethodCallAsync(GetInterfaceName().c_str(), s_method_GetVendorPhasesDescription.c_str(), this, (MessageReceiver::ReplyHandler)&DishWashingCyclePhaseIntfControllerImpl::GetCyclePhasesDescriptionReplyHandler, args, 1, context);
+
+    return status;
+}
+
+void DishWashingCyclePhaseIntfControllerImpl::GetCyclePhasePropertyCB(QStatus status, ProxyBusObject* obj, const MsgArg& value, void* context)
+{
+    if(!obj) {
+        return;
+    }
+
+    uint8_t cyclePhase;
+    value.Get("y", &cyclePhase);
+
+    m_interfaceListener.OnResponseGetCyclePhase(status, obj->GetPath(), (DishWashingCyclePhase)cyclePhase, context);
+}
+void DishWashingCyclePhaseIntfControllerImpl::GetSupportedCyclePhasesPropertyCB(QStatus status, ProxyBusObject* obj, const MsgArg& value, void* context)
+{
+    if(!obj) {
+        return;
+    }
+    uint8_t *vals;
+    size_t numVals;
+    value.Get("ay", &numVals, &vals);
+
+    SupportedCyclePhases cyclePhases;
+    for (size_t i = 0; i < numVals; ++i)
+        cyclePhases.push_back((DishWashingCyclePhase)vals[i]);
+
+    m_interfaceListener.OnResponseGetSupportedCyclePhases(status, obj->GetPath(), cyclePhases, context);
+
+}
+
+void DishWashingCyclePhaseIntfControllerImpl::GetCyclePhasesDescriptionReplyHandler(Message& message, void* context)
+{
+    DishWashingCyclePhaseInterface::CyclePhaseDescriptions descriptions;
+    qcc::String errorMessage;
+    const char* errorName = message->GetErrorName(&errorMessage);
+    QStatus status = ER_OK;
+    if (message->GetType() != MESSAGE_METHOD_RET)
+    {
+        status = ER_FAIL;
+    }
+    else
+    {
+        size_t numArgs;
+        const MsgArg* args;
+        message->GetArgs(numArgs, args);
+
+        if (!args[0].HasSignature("a(yss)"))
+        {
+            return;
+        }
+
+        MsgArg* entries;
+        size_t numEntries;
+        DishWashingCyclePhaseInterface::DishWashingPhaseDescriptor desc;
+
+        args[0].Get("a(yss)", &numEntries, &entries);
+        for (size_t i = 0; i < numEntries; ++i)
+        {
+            const char* phaseName, *phaseDesc;
+            uint8_t phase;
+            entries[i].Get("(yss)", &phase, &phaseName, &phaseDesc);
+            desc.phase = (DishWashingCyclePhase)phase;
+            desc.name = String(phaseName);
+            desc.description = String(phaseDesc);
+            descriptions.push_back(desc);
+        }
+    }
+    m_interfaceListener.OnResponseGetCyclePhasesDescriptions(status, m_proxyObject.GetPath(), descriptions, context, errorName, errorMessage.c_str());
+}
+
+} //namespace services
+} //namespace ajn
diff --git a/cpp/src/interfaces/operation/DishWashingCyclePhaseIntfControllerImpl.h b/cpp/src/interfaces/operation/DishWashingCyclePhaseIntfControllerImpl.h
new file mode 100644
index 0000000..bccf9e2
--- /dev/null
+++ b/cpp/src/interfaces/operation/DishWashingCyclePhaseIntfControllerImpl.h
@@ -0,0 +1,85 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#ifndef DISHWASHINGCYCLEPHASEINTFCONTROLLERIMPL_H_
+#define DISHWASHINGCYCLEPHASEINTFCONTROLLERIMPL_H_
+
+#include <alljoyn/Status.h>
+#include <alljoyn/BusAttachment.h>
+#include <alljoyn/hae/interfaces/InterfaceController.h>
+#include <alljoyn/hae/interfaces/operation/DishWashingCyclePhaseIntfController.h>
+
+namespace ajn {
+namespace services {
+
+class DishWashingCyclePhaseIntfControllerListener;
+class HaeProxyBusObject;
+
+/**
+ * DishWashingCyclePhase Interface Controller implementation class
+ */
+class DishWashingCyclePhaseIntfControllerImpl : public InterfaceController, public DishWashingCyclePhaseIntfController {
+  public:
+    /**
+     * Create interface
+     */
+    static HaeInterface* CreateInterface(BusAttachment& busAttachment, InterfaceControllerListener& listener, HaeProxyBusObject& haeProxyObject);
+
+    /**
+     * Constructor of DishWashingCyclePhaseIntfControllerImpl
+     */
+    DishWashingCyclePhaseIntfControllerImpl(BusAttachment& busAttachment, DishWashingCyclePhaseIntfControllerListener& listener, HaeProxyBusObject& haeProxyObject);
+
+    /**
+     * Destructor of DishWashingCyclePhaseIntfControllerImpl
+     */
+    virtual ~DishWashingCyclePhaseIntfControllerImpl();
+
+    /**
+     * Initialize interface
+     * @return status
+     */
+    virtual QStatus Init();
+
+    /**
+     * Get bus attachment
+     * @return bus attachment
+     */
+    virtual BusAttachment& GetBusAttachment() const { return m_busAttachment; }
+
+    virtual QStatus GetCyclePhase(void* context);
+
+    virtual QStatus GetSupportedCyclePhases(void* context );
+
+    virtual QStatus GetCyclePhasesDescriptions(const qcc::String& language, void* context);
+
+  private:
+    DishWashingCyclePhaseIntfControllerImpl();
+
+    void PropertiesChanged(ProxyBusObject& obj, const char* ifaceName, const MsgArg& changed, const MsgArg& invalidated, void* context);
+
+    void GetCyclePhasePropertyCB(QStatus status, ProxyBusObject* obj, const MsgArg& value, void* context);
+    void GetSupportedCyclePhasesPropertyCB(QStatus status, ProxyBusObject* obj, const MsgArg& value, void* context);
+    void GetCyclePhasesDescriptionReplyHandler(Message& message, void* context);
+
+    BusAttachment& m_busAttachment;
+    DishWashingCyclePhaseIntfControllerListener& m_interfaceListener;
+};
+
+} //namespace services
+} //namespace ajn
+
+#endif /* DISHWASHINGCYCLEPHASEINTFCONTROLLERIMPL_H_ */
diff --git a/cpp/src/interfaces/operation/HeatingZoneInterface.cc b/cpp/src/interfaces/operation/HeatingZoneInterface.cc
new file mode 100644
index 0000000..bba3beb
--- /dev/null
+++ b/cpp/src/interfaces/operation/HeatingZoneInterface.cc
@@ -0,0 +1,57 @@
+/******************************************************************************
+ * Copyright (c) 2013-2014, AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#include <alljoyn/hae/LogModule.h>
+#include <alljoyn/hae/interfaces/operation/HeatingZoneInterface.h>
+
+namespace ajn {
+namespace services {
+
+const uint16_t HeatingZoneInterface::s_interfaceVersion = 1;
+
+// Below none secure xml is only for test
+const qcc::String HeatingZoneInterface::s_xml =
+"<node xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance' xsi:noNamespaceSchemaLocation='http://www.allseenalliance.org/schemas/introspect.xsd'>"
+"    <interface name='org.alljoyn.SmartSpaces.Operation.HeatingZone'>"
+"        <description language='en'>This interface provides a capability to monitor the status of heating zones.</description>"
+"        <annotation name='org.alljoyn.Bus.Secure' value='true'/>"
+"        <property name='Version' type='q' access='read'>"
+"            <description language='en'>Interface version</description>"
+"            <annotation name='org.freedesktop.DBus.Property.EmitsChangedSignal' value='true'/>"
+"        </property>"
+"        <property name='NumberOfHeatingZones' type='y' access='read'>"
+"            <description language='en'>Number of heating zones</description>"
+"            <annotation name='org.freedesktop.DBus.Property.EmitsChangedSignal' value='true'/>"
+"        </property>"
+"        <property name='MaxHeatingLevels' type='ay' access='read'>"
+"            <description language='en'>Max heating levels for each zone</description>"
+"            <annotation name='org.freedesktop.DBus.Property.EmitsChangedSignal' value='true'/>"
+"        </property>"
+"        <property name='HeatingLevels' type='ay' access='read'>"
+"            <description language='en'>Current heating levels for each zone</description>"
+"            <annotation name='org.freedesktop.DBus.Property.EmitsChangedSignal' value='true'/>"
+"        </property>"
+"    </interface>"
+"</node>"
+;
+
+const qcc::String HeatingZoneInterface::s_prop_Version = "Version";
+const qcc::String HeatingZoneInterface::s_prop_NumberOfHeatingZones = "NumberOfHeatingZones";
+const qcc::String HeatingZoneInterface::s_prop_MaxHeatingLevels = "MaxHeatingLevels";
+const qcc::String HeatingZoneInterface::s_prop_HeatingLevels = "HeatingLevels";
+
+} //namespace services
+} //namespace ajn
diff --git a/cpp/src/interfaces/operation/HeatingZoneIntfControlleeImpl.cc b/cpp/src/interfaces/operation/HeatingZoneIntfControlleeImpl.cc
new file mode 100644
index 0000000..cd0ef37
--- /dev/null
+++ b/cpp/src/interfaces/operation/HeatingZoneIntfControlleeImpl.cc
@@ -0,0 +1,302 @@
+/******************************************************************************
+ * Copyright (c) 2013-2014, AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#include <qcc/Util.h>
+#include <vector>
+#include <algorithm>
+#include <alljoyn/hae/LogModule.h>
+#include <alljoyn/hae/HaeBusObject.h>
+#include <alljoyn/hae/interfaces/operation/HeatingZoneIntfControlleeListener.h>
+
+#include "HeatingZoneIntfControlleeImpl.h"
+
+using namespace qcc;
+using namespace std;
+
+namespace ajn {
+namespace services {
+
+HaeInterface* HeatingZoneIntfControlleeImpl::CreateInterface(BusAttachment& busAttachment, InterfaceControlleeListener& listener, HaeBusObject& haeBusObject)
+{
+    return new HeatingZoneIntfControlleeImpl(busAttachment, dynamic_cast<HeatingZoneIntfControlleeListener&>(listener), haeBusObject);
+}
+
+HeatingZoneIntfControlleeImpl::HeatingZoneIntfControlleeImpl(BusAttachment& busAttachment, HeatingZoneIntfControlleeListener& listener, HaeBusObject& haeBusObject) :
+    InterfaceControllee(haeBusObject),
+    m_busAttachment(busAttachment),
+    m_interfaceListener(listener)
+{
+}
+
+HeatingZoneIntfControlleeImpl::~HeatingZoneIntfControlleeImpl()
+{
+}
+
+QStatus HeatingZoneIntfControlleeImpl::Init()
+{
+    QStatus status = HaeInterface::Init();
+    return status;
+}
+
+QStatus HeatingZoneIntfControlleeImpl::OnGetProperty(const String propName, MsgArg& val)
+{
+    QStatus status = ER_OK;
+
+    if (!(s_prop_Version.compare(propName)))
+    {
+        val.typeId = ALLJOYN_UINT16;
+        val.v_uint16 = GetInterfaceVersion();
+    }
+    else
+    {
+        if (s_retrievingActualPropertyValue)
+        {
+            if(!s_prop_MaxHeatingLevels.compare(propName))
+            {
+                std::vector<uint8_t> maxHeatingLevels;
+                status = m_interfaceListener.OnGetMaxHeatingLevels(maxHeatingLevels);
+                if(status != ER_OK)
+                {
+                    maxHeatingLevels = GetMaxHeatingLevels();
+                    QCC_LogError(status, ("%s: failed to get actual property value from application. use previous value.", __func__));
+                }
+                else
+                {
+                    //update internal value
+                    SetMaxHeatingLevels(maxHeatingLevels);
+                }
+                uint8_t vals[maxHeatingLevels.size()];
+                size_t i = 0;
+
+                for(i = 0; i < maxHeatingLevels.size(); i++)
+                {
+                    vals[i] = (uint8_t)maxHeatingLevels[i];
+                }
+                val.Set("ay", sizeof(vals)/ sizeof(uint8_t), vals);
+                val.Stabilize();
+            }
+            else if(!s_prop_HeatingLevels.compare(propName))
+            {
+                std::vector<uint8_t> heatingLevels;
+                status = m_interfaceListener.OnGetHeatingLevels(heatingLevels);
+                if(status != ER_OK)
+                {
+                    heatingLevels = GetHeatingLevels();
+                    QCC_LogError(status, ("%s: failed to get actual property value from application. use previous value.", __func__));
+                }
+                else
+                {
+                    //update internal value
+                    SetHeatingLevels(heatingLevels);
+                }
+                uint8_t vals[heatingLevels.size()];
+                size_t i = 0;
+
+                for(i = 0; i < heatingLevels.size(); i++)
+                {
+                    vals[i] = (uint8_t)heatingLevels[i];
+                }
+                val.Set("ay", sizeof(vals)/ sizeof(uint8_t), vals);
+                val.Stabilize();
+            }
+            else if(!s_prop_NumberOfHeatingZones.compare(propName))
+            {
+                uint8_t numOfZones;
+                status = m_interfaceListener.OnGetNumberOfHeatingZones(numOfZones);
+                if(status != ER_OK)
+                {
+                    numOfZones = GetNumberOfHeatingZones();
+                    QCC_LogError(status, ("%s: failed to get actual property value from application. use previous value.", __func__));
+                }
+                else
+                {
+                    SetNumberOfHeatingZones(numOfZones);
+                }
+            }
+            else
+            {
+                status = ER_BUS_NO_SUCH_PROPERTY;
+            }
+        }
+        else
+        {
+            if(!s_prop_HeatingLevels.compare(propName))
+            {
+                std::vector<uint8_t> heatingLevels;
+                heatingLevels = GetHeatingLevels();
+                uint8_t vals[heatingLevels.size()];
+                size_t i = 0;
+
+                for(i = 0; i < heatingLevels.size(); i++)
+                {
+                    vals[i] = (uint8_t)heatingLevels[i];
+                }
+                val.Set("ay", sizeof(vals)/ sizeof(uint8_t), vals);
+                val.Stabilize();
+            }
+            else if(!s_prop_MaxHeatingLevels.compare(propName))
+            {
+                std::vector<uint8_t> maxHeatingLevels;
+                maxHeatingLevels = GetMaxHeatingLevels();
+                uint8_t vals[maxHeatingLevels.size()];
+                size_t i = 0;
+
+                for(i = 0; i < maxHeatingLevels.size(); i++)
+                {
+                    vals[i] = (uint8_t)maxHeatingLevels[i];
+                }
+                val.Set("ay", sizeof(vals)/ sizeof(uint8_t), vals);
+                val.Stabilize();
+            }
+            else if (!s_prop_NumberOfHeatingZones.compare(propName))
+            {
+                uint8_t numOfZones;
+                numOfZones = GetNumberOfHeatingZones();
+                val.typeId = ALLJOYN_BYTE;
+                val.v_byte = numOfZones;
+            }
+            else
+            {
+                status = ER_BUS_NO_SUCH_PROPERTY;
+            }
+        }
+    }
+
+    return status;
+}
+
+QStatus HeatingZoneIntfControlleeImpl::OnSetProperty(const String propName, MsgArg& val)
+{
+    QStatus status = ER_OK;
+
+    return status;
+}
+
+void HeatingZoneIntfControlleeImpl::OnMethodHandler(const InterfaceDescription::Member* member, Message& msg)
+{
+    QStatus status = ER_OK;
+    bool isFound = false;
+    MethodHandlers::const_iterator it;
+    for (it = m_methodHandlers.begin(); it != m_methodHandlers.end(); ++it) {
+        if (it->first == member) {
+            MessageReceiver::MethodHandler handler = it->second;
+            (this->*handler)(member, msg);
+            isFound = true;
+            break;
+        }
+    }
+
+    if (!isFound) {
+        status = ER_BUS_METHOD_CALL_ABORTED;
+        QCC_LogError(status, ("%s: could not found method handler.", __func__));
+        m_busObject.ReplyMethodCall(msg, status);
+    }
+}
+QStatus HeatingZoneIntfControlleeImpl::SetNumberOfHeatingZones(const uint8_t numberOfZones)
+{
+    if(m_numberOfHeatingLevels != numberOfZones)
+    {
+        MsgArg arg;
+        arg.typeId = ALLJOYN_BYTE;
+        arg.v_byte = numberOfZones;
+        m_busObject.EmitPropChanged(GetInterfaceName().c_str(), s_prop_NumberOfHeatingZones.c_str(), arg, 0 , ALLJOYN_FLAG_GLOBAL_BROADCAST);
+        m_numberOfHeatingLevels = numberOfZones;
+    }
+    return ER_OK;
+}
+
+QStatus HeatingZoneIntfControlleeImpl::SetMaxHeatingLevels(const std::vector<uint8_t>& maxHeatingLevels)
+{
+    QStatus status = ER_OK;
+
+    if(maxHeatingLevels.size() != m_numberOfHeatingLevels)
+        return ER_BUS_BAD_VALUE;
+
+    bool listChanged = false;
+    for(size_t i = 0; i < maxHeatingLevels.size(); i ++)
+    {
+        std::vector<uint8_t>::iterator it;
+        it = std::find(m_maxHeatingLevels.begin(),m_maxHeatingLevels.end(),maxHeatingLevels[i]);
+        if(it == m_maxHeatingLevels.end())
+        {
+            listChanged = true;
+            break;
+        }
+    }
+
+    if(listChanged)
+    {
+        m_maxHeatingLevels.clear();
+        for(unsigned int i =0;i<maxHeatingLevels.size();i++)
+            m_maxHeatingLevels.push_back(maxHeatingLevels[i]);
+        uint8_t vals[m_maxHeatingLevels.size()];
+
+        MsgArg val;
+        size_t i = 0;
+
+        for(i = 0; i < m_maxHeatingLevels.size(); i++)
+        {
+            vals[i] = (uint8_t)m_maxHeatingLevels[i];
+        }
+        val.Set("ay", sizeof(vals)/ sizeof(uint8_t), vals);
+        val.Stabilize();
+        m_busObject.EmitPropChanged(GetInterfaceName().c_str(),s_prop_MaxHeatingLevels.c_str(), val, 0, ALLJOYN_FLAG_GLOBAL_BROADCAST);
+    }
+    return status;
+}
+
+QStatus HeatingZoneIntfControlleeImpl::SetHeatingLevels(const std::vector<uint8_t>& heatingLevels)
+{
+    QStatus status = ER_OK;
+
+    if(heatingLevels.size() != m_numberOfHeatingLevels)
+        return ER_BUS_BAD_VALUE;
+
+    bool listChanged = false;
+    for(size_t i = 0; i < heatingLevels.size(); i ++)
+    {
+        std::vector<uint8_t>::iterator it;
+        it = std::find(m_heatingLevels.begin(),m_heatingLevels.end(),heatingLevels[i]);
+        if(it == m_heatingLevels.end())
+        {
+            listChanged = true;
+            break;
+        }
+    }
+
+    if(listChanged)
+    {
+        m_heatingLevels.clear();
+        for(unsigned int i =0;i<heatingLevels.size();i++)
+            m_heatingLevels.push_back(heatingLevels[i]);
+        uint8_t vals[m_heatingLevels.size()];
+
+        MsgArg val;
+        size_t i = 0;
+
+        for(i = 0; i < m_heatingLevels.size(); i++)
+        {
+            vals[i] = (uint8_t)m_heatingLevels[i];
+        }
+        val.Set("ay", sizeof(vals)/ sizeof(uint8_t), vals);
+        val.Stabilize();
+        m_busObject.EmitPropChanged(GetInterfaceName().c_str(),s_prop_HeatingLevels.c_str(), val, 0, ALLJOYN_FLAG_GLOBAL_BROADCAST);
+    }
+    return status;
+}
+
+} //namespace services
+} //namespace ajn
diff --git a/cpp/src/interfaces/operation/HeatingZoneIntfControlleeImpl.h b/cpp/src/interfaces/operation/HeatingZoneIntfControlleeImpl.h
new file mode 100644
index 0000000..b09f5da
--- /dev/null
+++ b/cpp/src/interfaces/operation/HeatingZoneIntfControlleeImpl.h
@@ -0,0 +1,147 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#ifndef HEATINGZONEINTFCONTROLLEEIMPL_H_
+#define HEATINGZONEINTFCONTROLLEEIMPL_H_
+
+#include <alljoyn/Status.h>
+#include <alljoyn/BusAttachment.h>
+#include <alljoyn/InterfaceDescription.h>
+#include <alljoyn/hae/interfaces/InterfaceControllee.h>
+#include <alljoyn/hae/interfaces/InterfaceControlleeListener.h>
+#include <alljoyn/hae/interfaces/operation/HeatingZoneIntfControllee.h>
+
+namespace ajn {
+namespace services {
+
+class HeatingZoneIntfControlleeListener;
+class HaeBusObject;
+
+/**
+ * HeatingZone Interface Controllee implementation class
+ */
+class HeatingZoneIntfControlleeImpl : public InterfaceControllee, public HeatingZoneIntfControllee {
+  public:
+    /**
+     * Create interface
+     */
+    static HaeInterface* CreateInterface(BusAttachment& busAttachment, InterfaceControlleeListener& listener, HaeBusObject& haeBusObject);
+
+    /**
+     * Constructor of HeatingZoneIntfControlleeImpl
+     */
+    HeatingZoneIntfControlleeImpl(BusAttachment& busAttachment, HeatingZoneIntfControlleeListener& listener, HaeBusObject& haeBusObject);
+
+    /**
+     * Destructor of HeatingZoneIntfControlleeImpl
+     */
+    virtual ~HeatingZoneIntfControlleeImpl();
+
+    /**
+     * Initialize interface
+     * @return status
+     */
+     virtual QStatus Init();
+
+    /**
+     * a callback function for getting property.
+     * @param propName   Identifies the property to get
+     * @param[out] val   Returns the property value. The type of this value is the actual value type.
+     * @return status
+     */
+    virtual QStatus OnGetProperty(const qcc::String propName, MsgArg& val);
+
+    /**
+     * a callback function for setting property.
+     * @param propName  Identifies the property to set
+     * @param val       The property value to set. The type of this value is the actual value type.
+     */
+    virtual QStatus OnSetProperty(const qcc::String propName, MsgArg& val);
+
+    /**
+     * method handler
+     * @param member    Method interface member entry.
+     * @param message   The received method call message.
+     */
+    virtual void OnMethodHandler(const InterfaceDescription::Member* member, Message& msg);
+
+    /**
+     * Get method handlers
+     * @return MethodHandlers
+     */
+    virtual const MethodHandlers& GetMethodHanders() const { return m_methodHandlers; }
+
+    /**
+     * Get bus attachment
+     * @return bus attachment
+     */
+    virtual BusAttachment& GetBusAttachment() const { return m_busAttachment; }
+
+
+    /**
+     * Get number of heating zones
+     * @return NumberOfHeatingZones
+     */
+    virtual const uint8_t GetNumberOfHeatingZones() const { return m_numberOfHeatingLevels; }
+
+    /**
+     * Set NumberOfHeatingZones
+     * @param[in] numberOfZones number of heating zones
+     * @return ER_OK on success
+     */
+    virtual QStatus SetNumberOfHeatingZones(const uint8_t numberOfZones);
+
+    /**
+     * Get MaxHeatingLevels
+     * @return the list of maximum heating levels
+     */
+    virtual const std::vector<uint8_t>& GetMaxHeatingLevels() const { return m_maxHeatingLevels; }
+
+    /**
+     * Set MaxHeatingLevels
+     * @param[in] maxHeatingLevels maxHeatingLevels
+     * @return ER_OK on success
+     */
+    virtual QStatus SetMaxHeatingLevels(const std::vector<uint8_t>& maxHeatingLevels);
+
+    /**
+     * Get HeatingLevels
+     * @return the list of heating levels
+     */
+    virtual const std::vector<uint8_t>& GetHeatingLevels() const { return m_heatingLevels; }
+
+    /**
+     * Set HeatingLevels
+     * @param[in] heatingLevels heatingLevels
+     * @return ER_OK on success
+     */
+    virtual QStatus SetHeatingLevels(const std::vector<uint8_t>& heatingLevels);
+
+  private:
+    HeatingZoneIntfControlleeImpl();
+
+    BusAttachment& m_busAttachment;
+    HeatingZoneIntfControlleeListener& m_interfaceListener;
+    MethodHandlers m_methodHandlers;
+    std::vector<uint8_t> m_maxHeatingLevels;
+    std::vector<uint8_t> m_heatingLevels;
+    uint8_t m_numberOfHeatingLevels;
+};
+
+} //namespace services
+} //namespace ajn
+
+#endif /* HEATINGZONEINTFCONTROLLEEIMPL_H_ */
diff --git a/cpp/src/interfaces/operation/HeatingZoneIntfControllerImpl.cc b/cpp/src/interfaces/operation/HeatingZoneIntfControllerImpl.cc
new file mode 100644
index 0000000..a956b4c
--- /dev/null
+++ b/cpp/src/interfaces/operation/HeatingZoneIntfControllerImpl.cc
@@ -0,0 +1,183 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#include <qcc/Util.h>
+
+#include <alljoyn/hae/LogModule.h>
+#include <alljoyn/hae/HaeProxyBusObject.h>
+#include <alljoyn/hae/interfaces/operation/HeatingZoneIntfControllerListener.h>
+
+#include "HeatingZoneIntfControllerImpl.h"
+
+using namespace qcc;
+using namespace std;
+
+namespace ajn {
+namespace services {
+
+HaeInterface* HeatingZoneIntfControllerImpl::CreateInterface(BusAttachment& busAttachment, InterfaceControllerListener& listener, HaeProxyBusObject& haeProxyObject)
+{
+    return new HeatingZoneIntfControllerImpl(busAttachment, dynamic_cast<HeatingZoneIntfControllerListener&>(listener), haeProxyObject);
+}
+
+HeatingZoneIntfControllerImpl::HeatingZoneIntfControllerImpl(BusAttachment& busAttachment, HeatingZoneIntfControllerListener& listener, HaeProxyBusObject& haeProxyObject) :
+    InterfaceController(haeProxyObject),
+    m_busAttachment(busAttachment),
+    m_interfaceListener(listener)
+{
+}
+
+HeatingZoneIntfControllerImpl::~HeatingZoneIntfControllerImpl()
+{
+}
+
+QStatus HeatingZoneIntfControllerImpl::Init()
+{
+    QStatus status = HaeInterface::Init();
+    if (ER_OK != status) {
+        QCC_LogError(status, ("%s: Interface init failed.", __func__));
+        return status;
+    }
+
+    status = m_proxyObject.RegisterPropertiesChangedListener(GetInterfaceName().c_str(), NULL, 0, *this, NULL);
+    if (ER_OK != status) {
+        QCC_LogError(status, ("%s: RegisterPropertiesChangedListener failed.", __func__));
+    }
+
+    return status;
+}
+
+void HeatingZoneIntfControllerImpl::PropertiesChanged(ProxyBusObject& obj, const char* ifaceName, const MsgArg& changed, const MsgArg& invalidated, void* context)
+{
+    MsgArg* entries;
+    size_t numEntries;
+
+    changed.Get("a{sv}", &numEntries, &entries);
+    for (size_t i = 0; i < numEntries; ++i) {
+        const char* propName;
+        MsgArg* propValue;
+        entries[i].Get("{sv}", &propName, &propValue);
+        String propNameStr(propName);
+
+        if (!s_prop_NumberOfHeatingZones.compare(propNameStr)) {
+            if (propValue->typeId == ALLJOYN_BYTE) {
+                uint8_t numOfZones = propValue->v_byte;
+                m_interfaceListener.NumberOfHeatingZonesPropertyChanged(obj.GetPath(), numOfZones);
+            }
+        }
+        else if(!s_prop_MaxHeatingLevels.compare(propNameStr)) {
+            if(propValue->typeId == ALLJOYN_BYTE_ARRAY) {
+                uint8_t *vals;
+                size_t numVals;
+                propValue->Get("ay", &numVals, &vals);
+
+                std::vector<uint8_t> maxHeatingLevels;
+                for (size_t i = 0; i < numVals; ++i)
+                    maxHeatingLevels.push_back(vals[i]);
+                m_interfaceListener.MaxHeatingLevelsPropertyChanged(obj.GetPath(), maxHeatingLevels);
+            }
+        }
+        else if (!s_prop_HeatingLevels.compare(propNameStr)) {
+            if(propValue->typeId == ALLJOYN_BYTE_ARRAY) {
+                uint8_t *vals;
+                size_t numVals;
+                propValue->Get("ay", &numVals, &vals);
+
+                std::vector<uint8_t> heatingLevels;
+                for (size_t i = 0; i < numVals; ++i)
+                    heatingLevels.push_back(vals[i]);
+                m_interfaceListener.HeatingLevelsPropertyChanged(obj.GetPath(), heatingLevels);
+            }
+        }
+    }
+}
+
+QStatus HeatingZoneIntfControllerImpl::GetNumberOfHeatingZones(void* context)
+{
+    QStatus status = ER_OK;
+
+    m_proxyObject.GetPropertyAsync(GetInterfaceName().c_str(), s_prop_NumberOfHeatingZones.c_str(), this, (ProxyBusObject::Listener::GetPropertyCB)&HeatingZoneIntfControllerImpl::GetNumberOfHeatingZonesPropertyCB, context);
+
+    return status;
+}
+
+QStatus HeatingZoneIntfControllerImpl::GetMaxHeatingLevels(void* context )
+{
+    QStatus status = ER_OK;
+
+    m_proxyObject.GetPropertyAsync(GetInterfaceName().c_str(), s_prop_MaxHeatingLevels.c_str(), this, (ProxyBusObject::Listener::GetPropertyCB)&HeatingZoneIntfControllerImpl::GetMaxHeatingLevelsPropertyCB, context);
+
+    return status;
+}
+
+QStatus HeatingZoneIntfControllerImpl::GetHeatingLevels(void* context)
+{
+    QStatus status = ER_OK;
+
+    m_proxyObject.GetPropertyAsync(GetInterfaceName().c_str(), s_prop_HeatingLevels.c_str(), this, (ProxyBusObject::Listener::GetPropertyCB)&HeatingZoneIntfControllerImpl::GetHeatingLevelsPropertyCB, context);
+
+    return status;
+}
+
+void HeatingZoneIntfControllerImpl::GetNumberOfHeatingZonesPropertyCB(QStatus status, ProxyBusObject* obj, const MsgArg& value, void* context)
+{
+    if (!obj) {
+        return;
+    }
+
+    uint8_t numOfZones;
+
+    value.Get("y",&numOfZones);
+
+    m_interfaceListener.OnGetNumberOfHeatingZonesPropertyCallback(status, obj->GetPath(), numOfZones, context);
+}
+
+void HeatingZoneIntfControllerImpl::GetMaxHeatingLevelsPropertyCB(QStatus status, ProxyBusObject* obj, const MsgArg& value, void* context)
+{
+    if (!obj) {
+        return;
+    }
+    uint8_t *vals;
+    size_t numVals;
+    value.Get("ay", &numVals, &vals);
+
+    std::vector<uint8_t> maxHeatingLevels;
+    for (size_t i = 0; i < numVals; ++i) {
+        maxHeatingLevels.push_back(vals[i]);
+    }
+    m_interfaceListener.OnGetMaxHeatingLevelsPropertyCallback(status, obj->GetPath(), maxHeatingLevels, context);
+
+}
+
+void HeatingZoneIntfControllerImpl::GetHeatingLevelsPropertyCB(QStatus status, ProxyBusObject* obj, const MsgArg& value, void* context)
+{
+    if (!obj) {
+        return;
+    }
+    uint8_t *vals;
+    size_t numVals;
+    value.Get("ay", &numVals, &vals);
+
+    std::vector<uint8_t> heatingLevels;
+    for (size_t i = 0; i < numVals; ++i) {
+        heatingLevels.push_back(vals[i]);
+    }
+    m_interfaceListener.OnGetHeatingLevelsPropertyCallback(status, obj->GetPath(), heatingLevels, context);
+}
+
+
+} //namespace services
+} //namespace ajn
diff --git a/cpp/src/interfaces/operation/HeatingZoneIntfControllerImpl.h b/cpp/src/interfaces/operation/HeatingZoneIntfControllerImpl.h
new file mode 100644
index 0000000..97355a0
--- /dev/null
+++ b/cpp/src/interfaces/operation/HeatingZoneIntfControllerImpl.h
@@ -0,0 +1,87 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#ifndef HEATINGZONEINTFCONTROLLERIMPL_H_
+#define HEATINGZONEINTFCONTROLLERIMPL_H_
+
+#include <alljoyn/Status.h>
+#include <alljoyn/BusAttachment.h>
+#include <alljoyn/hae/interfaces/InterfaceController.h>
+#include <alljoyn/hae/interfaces/operation/HeatingZoneIntfController.h>
+
+namespace ajn {
+namespace services {
+
+class HeatingZoneIntfControllerListener;
+class HaeProxyBusObject;
+
+/**
+ * HeatingZone Interface Controller implementation class
+ */
+class HeatingZoneIntfControllerImpl : public InterfaceController, public HeatingZoneIntfController {
+  public:
+    /**
+     * Create interface
+     */
+    static HaeInterface* CreateInterface(BusAttachment& busAttachment, InterfaceControllerListener& listener, HaeProxyBusObject& haeProxyObject);
+
+    /**
+     * Constructor of HeatingZoneIntfControllerImpl
+     */
+    HeatingZoneIntfControllerImpl(BusAttachment& busAttachment, HeatingZoneIntfControllerListener& listener, HaeProxyBusObject& haeProxyObject);
+
+    /**
+     * Destructor of HeatingZoneIntfControllerImpl
+     */
+    virtual ~HeatingZoneIntfControllerImpl();
+
+    /**
+     * Initialize interface
+     * @return status
+     */
+    virtual QStatus Init();
+
+    /**
+     * Get bus attachment
+     * @return bus attachment
+     */
+    virtual BusAttachment& GetBusAttachment() const { return m_busAttachment; }
+
+    virtual QStatus GetNumberOfHeatingZones(void* context);
+
+    virtual QStatus GetMaxHeatingLevels(void* context );
+
+    virtual QStatus GetHeatingLevels(void* context);
+
+  private:
+    HeatingZoneIntfControllerImpl();
+
+    void PropertiesChanged(ProxyBusObject& obj, const char* ifaceName, const MsgArg& changed, const MsgArg& invalidated, void* context);
+
+    void GetNumberOfHeatingZonesPropertyCB(QStatus status, ProxyBusObject* obj, const MsgArg& value, void* context);
+
+    void GetMaxHeatingLevelsPropertyCB(QStatus status, ProxyBusObject* obj, const MsgArg& value, void* context);
+
+    void GetHeatingLevelsPropertyCB(QStatus status, ProxyBusObject* obj, const MsgArg& value, void* context);
+
+    BusAttachment& m_busAttachment;
+    HeatingZoneIntfControllerListener& m_interfaceListener;
+};
+
+} //namespace services
+} //namespace ajn
+
+#endif /* HEATINGZONEINTFCONTROLLERIMPL_H_ */
diff --git a/cpp/src/interfaces/operation/LaundryCyclePhaseInterface.cc b/cpp/src/interfaces/operation/LaundryCyclePhaseInterface.cc
new file mode 100644
index 0000000..4020919
--- /dev/null
+++ b/cpp/src/interfaces/operation/LaundryCyclePhaseInterface.cc
@@ -0,0 +1,63 @@
+/******************************************************************************
+ * Copyright (c) 2013-2014, AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#include <alljoyn/hae/LogModule.h>
+#include <alljoyn/hae/interfaces/operation/LaundryCyclePhaseInterface.h>
+
+namespace ajn {
+namespace services {
+
+const uint16_t LaundryCyclePhaseInterface::s_interfaceVersion = 1;
+
+// Below none secure xml is only for test
+const qcc::String LaundryCyclePhaseInterface::s_xml =
+"<node xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance' xsi:noNamespaceSchemaLocation='http://www.allseenalliance.org/schemas/introspect.xsd'>"
+"    <interface name='org.alljoyn.SmartSpaces.Operation.LaundryCyclePhase'>"
+"        <description language='en'>This interface provides a capability to control the phase of the operational cycle of appliances used to wash and dry clothes</description>"
+"        <annotation name='org.alljoyn.Bus.Secure' value='true'/>"
+"        <property name='Version' type='q' access='read'>"
+"            <description language='en'>Interface version</description>"
+"            <annotation name='org.freedesktop.DBus.Property.EmitsChangedSignal' value='true'/>"
+"        </property>"
+"        <property name='CyclePhase' type='y' access='read'>"
+"            <description language='en'>Current cycle phase</description>"
+"            <annotation name='org.freedesktop.DBus.Property.EmitsChangedSignal' value='true'/>"
+"        </property>"
+"        <property name='SupportedCyclePhases' type='ay' access='read'>"
+"            <description language='en'>List of supported cycle phases</description>"
+"            <annotation name='org.freedesktop.DBus.Property.EmitsChangedSignal' value='true'/>"
+"        </property>"
+"        <method name='GetVendorPhasesDescription'>"
+"            <description language='en'>Get cycle phases description</description>"
+"            <arg name='languageTag' type='s' direction='in'>"
+"                <description language='en'>Preferred language to be used in selecting the output strings</description>"
+"            </arg>"
+"            <arg name='phasesDescription' type='a(yss)' direction='out'>"
+"                <description language='en'>Cycle phases description</description>"
+"            </arg>"
+"        </method>"
+"   </interface>"
+"</node>"
+;
+
+const qcc::String LaundryCyclePhaseInterface::s_prop_Version = "Version";
+const qcc::String LaundryCyclePhaseInterface::s_prop_CyclePhase = "CyclePhase";
+const qcc::String LaundryCyclePhaseInterface::s_prop_SupportedCyclePhases = "SupportedCyclePhases";
+const qcc::String LaundryCyclePhaseInterface::s_method_GetVendorPhasesDescription = "GetVendorPhasesDescription";
+const LaundryCyclePhaseInterface::StandardCyclePhases LaundryCyclePhaseInterface::m_standardCyclePhases = {LAUNDRY_PHASE_UNAVAILABLE,LAUNDRY_PHASE_PRE_WASHING,LAUNDRY_PHASE_WASHING,LAUNDRY_PHASE_RINSING,LAUNDRY_PHASE_SPINNING,LAUNDRY_PHASE_STEAM,LAUNDRY_PHASE_DRYING,LAUNDRY_PHASE_COOLING,LAUNDRY_PHASE_ANTICREASING};
+
+} //namespace services
+} //namespace ajn
diff --git a/cpp/src/interfaces/operation/LaundryCyclePhaseIntfControlleeImpl.cc b/cpp/src/interfaces/operation/LaundryCyclePhaseIntfControlleeImpl.cc
new file mode 100644
index 0000000..f25cdbf
--- /dev/null
+++ b/cpp/src/interfaces/operation/LaundryCyclePhaseIntfControlleeImpl.cc
@@ -0,0 +1,345 @@
+/******************************************************************************
+ * Copyright (c) 2013-2014, AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#include <qcc/Util.h>
+#include <vector>
+#include <algorithm>
+#include <alljoyn/hae/LogModule.h>
+#include <alljoyn/hae/HaeBusObject.h>
+#include <alljoyn/hae/interfaces/operation/LaundryCyclePhaseIntfControlleeListener.h>
+
+#include "LaundryCyclePhaseIntfControlleeImpl.h"
+
+using namespace qcc;
+using namespace std;
+
+namespace ajn {
+namespace services {
+
+HaeInterface* LaundryCyclePhaseIntfControlleeImpl::CreateInterface(BusAttachment& busAttachment, InterfaceControlleeListener& listener, HaeBusObject& haeBusObject)
+{
+    return new LaundryCyclePhaseIntfControlleeImpl(busAttachment, dynamic_cast<LaundryCyclePhaseIntfControlleeListener&>(listener), haeBusObject);
+}
+
+LaundryCyclePhaseIntfControlleeImpl::LaundryCyclePhaseIntfControlleeImpl(BusAttachment& busAttachment, LaundryCyclePhaseIntfControlleeListener& listener, HaeBusObject& haeBusObject) :
+    InterfaceControllee(haeBusObject),
+    m_busAttachment(busAttachment),
+    m_interfaceListener(listener),
+    m_cyclePhase(LaundryCyclePhase::LAUNDRY_PHASE_UNAVAILABLE)
+{
+}
+
+LaundryCyclePhaseIntfControlleeImpl::~LaundryCyclePhaseIntfControlleeImpl()
+{
+}
+
+QStatus LaundryCyclePhaseIntfControlleeImpl::Init()
+{
+    QStatus status = HaeInterface::Init();
+
+    const InterfaceDescription::Member* member = m_interfaceDescription->GetMember(s_method_GetVendorPhasesDescription.c_str());
+    MessageReceiver::MethodHandler methodHandler = static_cast<MessageReceiver::MethodHandler>(&LaundryCyclePhaseIntfControlleeImpl::OnGetCyclePhasesDescription);
+
+    m_methodHandlers.push_back(make_pair(member, methodHandler));
+
+    return status;
+}
+
+QStatus LaundryCyclePhaseIntfControlleeImpl::OnGetProperty(const String propName, MsgArg& val)
+{
+    QStatus status = ER_OK;
+
+    if (!(s_prop_Version.compare(propName))) {
+        val.typeId = ALLJOYN_UINT16;
+        val.v_uint16 = GetInterfaceVersion();
+    }
+    else
+    {
+        if (s_retrievingActualPropertyValue)
+        {
+            if(!s_prop_CyclePhase.compare(propName))
+            {
+                uint8_t cyclePhase;
+                status = m_interfaceListener.OnGetCyclePhase(cyclePhase);
+                if (status != ER_OK) {
+                    cyclePhase = GetCyclePhase();
+                    QCC_LogError(status, ("%s: failed to get actual property value from application. use previous value.", __func__));
+                    status = ER_OK;
+                } else {
+                    SetCyclePhase(cyclePhase); // update the value in ChannelIntfControllee.
+                }
+
+                val.typeId = ALLJOYN_BYTE;
+                val.v_byte = (uint8_t)cyclePhase;
+
+            }
+            else if (!s_prop_SupportedCyclePhases.compare(propName))
+            {
+                SupportedCyclePhases supportedCyclePhases;
+                status = m_interfaceListener.OnGetSupportedCyclePhases(supportedCyclePhases);
+                if(status != ER_OK)
+                {
+                    supportedCyclePhases = GetSupportedCyclePhases();
+                    QCC_LogError(status, ("%s: failed to get actual property value from application. use previous value.", __func__));
+                }
+                else
+                {
+                    //update internal value
+                    SetSupportedCyclePhases(supportedCyclePhases);
+                }
+                uint8_t vals[supportedCyclePhases.size()];
+                size_t i = 0;
+
+                for(i = 0; i < supportedCyclePhases.size(); i++)
+                {
+                    vals[i] = (uint8_t)supportedCyclePhases[i];
+                }
+                val.Set("ay", sizeof(vals)/ sizeof(uint8_t), vals);
+                val.Stabilize();
+            }
+            else
+            {
+                status = ER_BUS_NO_SUCH_PROPERTY;
+            }
+        }
+        else
+        {
+            if(!s_prop_CyclePhase.compare(propName))
+            {
+                uint8_t cyclePhase;
+                cyclePhase = GetCyclePhase();
+
+                val.typeId = ALLJOYN_BYTE;
+                val.v_byte = (uint8_t)cyclePhase;
+            }
+            else if (!s_prop_SupportedCyclePhases.compare(propName))
+            {
+                SupportedCyclePhases supportedCyclePhases;
+                supportedCyclePhases = GetSupportedCyclePhases();
+                uint8_t vals[supportedCyclePhases.size()];
+                size_t i = 0;
+
+                for(i = 0; i < supportedCyclePhases.size(); i++)
+                {
+                    vals[i] = (uint8_t)supportedCyclePhases[i];
+                }
+                val.Set("ay", sizeof(vals)/ sizeof(uint8_t), vals);
+                val.Stabilize();
+            }
+            else
+            {
+                status = ER_BUS_NO_SUCH_PROPERTY;
+            }
+        }
+    }
+
+    return status;
+}
+
+QStatus LaundryCyclePhaseIntfControlleeImpl::OnSetProperty(const String propName, MsgArg& val)
+{
+    QStatus status = ER_OK;
+
+    return status;
+}
+
+void LaundryCyclePhaseIntfControlleeImpl::OnMethodHandler(const InterfaceDescription::Member* member, Message& msg)
+{
+    QStatus status = ER_OK;
+    bool isFound = false;
+    MethodHandlers::const_iterator it;
+    for (it = m_methodHandlers.begin(); it != m_methodHandlers.end(); ++it) {
+        if (it->first == member) {
+            MessageReceiver::MethodHandler handler = it->second;
+            (this->*handler)(member, msg);
+            isFound = true;
+            break;
+        }
+    }
+
+    if (!isFound) {
+        status = ER_BUS_METHOD_CALL_ABORTED;
+        QCC_LogError(status, ("%s: could not found method handler.", __func__));
+        m_busObject.ReplyMethodCall(msg, status);
+    }
+}
+QStatus LaundryCyclePhaseIntfControlleeImpl::SetCyclePhase(const uint8_t cyclePhase)
+{
+    StandardCyclePhases::const_iterator stand_it;
+    std::vector<uint8_t>::iterator vend_it;
+
+    stand_it = std::find(m_standardCyclePhases.begin(), m_standardCyclePhases.end(), cyclePhase);
+    vend_it = std::find(m_vendorDefinedCyclePhases.begin(),m_vendorDefinedCyclePhases.end(),cyclePhase);
+
+    if(vend_it == m_vendorDefinedCyclePhases.end() && stand_it == m_standardCyclePhases.end())
+        return ER_FAIL;
+
+    SupportedCyclePhases::iterator supp_it;
+    supp_it = std::find(m_supportedCyclePhases.begin(),m_supportedCyclePhases.end(),cyclePhase);
+    if(supp_it == m_supportedCyclePhases.end())
+        return ER_FAIL;
+
+    if(m_cyclePhase != cyclePhase)
+    {
+        MsgArg arg;
+        arg.typeId = ALLJOYN_BYTE;
+        arg.v_byte = cyclePhase;
+        m_busObject.EmitPropChanged(GetInterfaceName().c_str(), s_prop_CyclePhase.c_str(), arg, 0, ALLJOYN_FLAG_GLOBAL_BROADCAST);
+        m_cyclePhase = cyclePhase;
+    }
+    return ER_OK;
+}
+
+QStatus LaundryCyclePhaseIntfControlleeImpl::SetSupportedCyclePhases(const SupportedCyclePhases& supportedPhases)
+{
+    uint8_t vals[supportedPhases.size()];
+
+    bool listChanged = false;
+
+    if(m_supportedCyclePhases.size() != supportedPhases.size())
+        listChanged = true;
+    else
+    {
+        for (size_t i = 0; i < supportedPhases.size(); i++)
+        {
+            StandardCyclePhases::const_iterator stand_it;
+            std::vector<uint8_t>::iterator vend_it;
+
+            stand_it = std::find(m_standardCyclePhases.begin(), m_standardCyclePhases.end(), supportedPhases[i]);
+            vend_it = std::find(m_vendorDefinedCyclePhases.begin(),m_vendorDefinedCyclePhases.end(),supportedPhases[i]);
+
+            if(vend_it == m_vendorDefinedCyclePhases.end() && stand_it == m_standardCyclePhases.end())
+                return ER_FAIL;
+
+            if(supportedPhases[i] != m_supportedCyclePhases[i])
+            {
+                listChanged = true;
+                break;
+            }
+        }
+    }
+
+    if(listChanged)
+    {
+        m_supportedCyclePhases.clear();
+        for(size_t i = 0 ; i < supportedPhases.size(); i ++)
+        {
+            m_supportedCyclePhases.push_back(supportedPhases[i]);
+            vals[i] = (uint8_t)supportedPhases[i];
+        }
+
+        MsgArg arg;
+        arg.Set("ay", sizeof(vals)/ sizeof(uint8_t), vals);
+        arg.Stabilize();
+
+        m_busObject.EmitPropChanged(GetInterfaceName().c_str(), s_prop_SupportedCyclePhases.c_str(), arg, 0 , ALLJOYN_FLAG_GLOBAL_BROADCAST);
+    }
+    return ER_OK;
+}
+
+void LaundryCyclePhaseIntfControlleeImpl::OnGetCyclePhasesDescription(const InterfaceDescription::Member* member, Message& msg)
+{
+    cout << "LaundryCyclePhaseIntfControlleeImpl::OnGetCyclePhasesDescription" << endl;
+    QStatus status = ER_OK;
+
+    const MsgArg* args = NULL;
+    size_t numArgs = 0;
+
+    msg->GetArgs(numArgs, args);
+
+    if (numArgs == 1)
+    {
+        qcc::String lang(args[0].v_string.str);
+        if(lang.compare("en"))
+        {
+            status = ER_LANGUAGE_NOT_SUPPORTED;
+            QCC_LogError(status, ("%s: language not suppoerted", __func__));
+            m_busObject.ReplyMethodCall(msg, status);
+        }
+        else
+        {
+            CyclePhaseDescriptions listOfDescriptions;
+            ErrorCode errorCode = NOT_ERROR;
+            status = m_interfaceListener.OnGetCyclePhasesDescriptions(lang, listOfDescriptions, errorCode);
+            if(status == ER_OK)
+            {
+                int numReturned = listOfDescriptions.size();
+                LaundryCyclePhaseInterface::CyclePhaseDescriptions::const_iterator citer;
+                MsgArg args[numReturned];
+                MsgArg retArgs[1];
+                int i=0;
+
+                for(citer = listOfDescriptions.begin(); citer != listOfDescriptions.end(); citer++, i++) {
+                    status = args[i].Set("(yss)", (uint8_t)citer->phase, citer->name.c_str(), citer->description.c_str());
+                    args[i].Stabilize();
+                }
+                status = retArgs[0].Set("a(yss)", i, args);
+                retArgs[0].Stabilize();
+                status = m_busObject.ReplyMethodCall(msg, retArgs, ArraySize(retArgs));
+            }
+            else
+            {
+                if (errorCode == NOT_ERROR)
+                {
+                    QCC_LogError(status, ("%s: status is not ER_OK, but errorCode was not set.", __func__));
+                    m_busObject.ReplyMethodCall(msg, status);
+                }
+                else
+                {
+                    m_busObject.ReplyMethodCall(msg, HaeInterface::GetInterfaceErrorName(errorCode).c_str(),HaeInterface::GetInterfaceErrorMessage(errorCode).c_str());
+                }
+            }
+        }
+    }
+    else
+    {
+        m_busObject.ReplyMethodCall(msg, ER_INVALID_DATA);
+    }
+}
+QStatus LaundryCyclePhaseIntfControlleeImpl::SetVendorDefinedCyclePhases(const std::vector<uint8_t>& vendorPhases)
+{
+    for(size_t i = 0 ; i < vendorPhases.size(); i++)
+    {
+        if(vendorPhases[i] < 0x80 )
+            return ER_FAIL;
+    }
+    bool listChanged = false;
+    if(m_vendorDefinedCyclePhases.size() != vendorPhases.size())
+            listChanged = true;
+    else
+    {
+        for(size_t i = 0 ; i < vendorPhases.size(); i++)
+        {
+            std::vector<uint8_t>::iterator it;
+            it = std::find(m_vendorDefinedCyclePhases.begin(),m_vendorDefinedCyclePhases.end(), vendorPhases[i]);
+            if(it == m_vendorDefinedCyclePhases.end())
+            {
+                listChanged = true;
+                break;
+            }
+        }
+    }
+    if(listChanged)
+    {
+        m_vendorDefinedCyclePhases.clear();
+        for (size_t i =0;i<vendorPhases.size();i++)
+            m_vendorDefinedCyclePhases.push_back(vendorPhases[i]);
+    }
+    return ER_OK;
+}
+
+} //namespace services
+} //namespace ajn
diff --git a/cpp/src/interfaces/operation/LaundryCyclePhaseIntfControlleeImpl.h b/cpp/src/interfaces/operation/LaundryCyclePhaseIntfControlleeImpl.h
new file mode 100644
index 0000000..8fb5fa0
--- /dev/null
+++ b/cpp/src/interfaces/operation/LaundryCyclePhaseIntfControlleeImpl.h
@@ -0,0 +1,121 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#ifndef LAUNDRYCYCLEPHASEINTFCONTROLLEEIMPL_H_
+#define LAUNDRYCYCLEPHASEINTFCONTROLLEEIMPL_H_
+
+#include <alljoyn/Status.h>
+#include <alljoyn/BusAttachment.h>
+#include <alljoyn/InterfaceDescription.h>
+#include <alljoyn/hae/interfaces/InterfaceControllee.h>
+#include <alljoyn/hae/interfaces/InterfaceControlleeListener.h>
+#include <alljoyn/hae/interfaces/operation/LaundryCyclePhaseIntfControllee.h>
+
+namespace ajn {
+namespace services {
+
+class LaundryCyclePhaseIntfControlleeListener;
+class HaeBusObject;
+
+/**
+ * LaundryCyclePhase Interface Controllee implementation class
+ */
+class LaundryCyclePhaseIntfControlleeImpl : public InterfaceControllee, public LaundryCyclePhaseIntfControllee {
+  public:
+    /**
+     * Create interface
+     */
+    static HaeInterface* CreateInterface(BusAttachment& busAttachment, InterfaceControlleeListener& listener, HaeBusObject& haeBusObject);
+
+    /**
+     * Constructor of LaundryCyclePhaseIntfControlleeImpl
+     */
+    LaundryCyclePhaseIntfControlleeImpl(BusAttachment& busAttachment, LaundryCyclePhaseIntfControlleeListener& listener, HaeBusObject& haeBusObject);
+
+    /**
+     * Destructor of LaundryCyclePhaseIntfControlleeImpl
+     */
+    virtual ~LaundryCyclePhaseIntfControlleeImpl();
+
+    /**
+     * Initialize interface
+     * @return status
+     */
+     virtual QStatus Init();
+
+    /**
+     * a callback function for getting property.
+     * @param propName   Identifies the property to get
+     * @param[out] val   Returns the property value. The type of this value is the actual value type.
+     * @return status
+     */
+    virtual QStatus OnGetProperty(const qcc::String propName, MsgArg& val);
+
+    /**
+     * a callback function for setting property.
+     * @param propName  Identifies the property to set
+     * @param val       The property value to set. The type of this value is the actual value type.
+     */
+    virtual QStatus OnSetProperty(const qcc::String propName, MsgArg& val);
+
+    /**
+     * method handler
+     * @param member    Method interface member entry.
+     * @param message   The received method call message.
+     */
+    virtual void OnMethodHandler(const InterfaceDescription::Member* member, Message& msg);
+
+    /**
+     * Get method handlers
+     * @return MethodHandlers
+     */
+    virtual const MethodHandlers& GetMethodHanders() const { return m_methodHandlers; }
+
+    /**
+     * Get bus attachment
+     * @return bus attachment
+     */
+    virtual BusAttachment& GetBusAttachment() const { return m_busAttachment; }
+
+    virtual const uint8_t GetCyclePhase() const { return m_cyclePhase; }
+
+    virtual QStatus SetCyclePhase(const uint8_t cyclePhase);
+
+    virtual const SupportedCyclePhases& GetSupportedCyclePhases() const { return m_supportedCyclePhases; }
+
+    virtual QStatus SetSupportedCyclePhases(const SupportedCyclePhases& descriptions);
+
+    void OnGetCyclePhasesDescription(const InterfaceDescription::Member* member, Message& msg);
+
+    virtual QStatus SetVendorDefinedCyclePhases(const std::vector<uint8_t>& vendorPhases);
+
+  private:
+    LaundryCyclePhaseIntfControlleeImpl();
+
+    BusAttachment& m_busAttachment;
+    LaundryCyclePhaseIntfControlleeListener& m_interfaceListener;
+    MethodHandlers m_methodHandlers;
+    uint8_t m_cyclePhase;
+    SupportedCyclePhases m_supportedCyclePhases;
+    std::vector<uint8_t> m_vendorDefinedCyclePhases;
+
+
+};
+
+} //namespace services
+} //namespace ajn
+
+#endif /* LAUNDRYCYCLEPHASEINTFCONTROLLEEIMPL_H_ */
diff --git a/cpp/src/interfaces/operation/LaundryCyclePhaseIntfControllerImpl.cc b/cpp/src/interfaces/operation/LaundryCyclePhaseIntfControllerImpl.cc
new file mode 100644
index 0000000..964eb21
--- /dev/null
+++ b/cpp/src/interfaces/operation/LaundryCyclePhaseIntfControllerImpl.cc
@@ -0,0 +1,206 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#include <qcc/Util.h>
+
+#include <alljoyn/hae/LogModule.h>
+#include <alljoyn/hae/HaeProxyBusObject.h>
+#include <alljoyn/hae/interfaces/operation/LaundryCyclePhaseIntfControllerListener.h>
+
+#include "LaundryCyclePhaseIntfControllerImpl.h"
+
+using namespace qcc;
+using namespace std;
+
+namespace ajn {
+namespace services {
+
+HaeInterface* LaundryCyclePhaseIntfControllerImpl::CreateInterface(BusAttachment& busAttachment, InterfaceControllerListener& listener, HaeProxyBusObject& haeProxyObject)
+{
+    return new LaundryCyclePhaseIntfControllerImpl(busAttachment, dynamic_cast<LaundryCyclePhaseIntfControllerListener&>(listener), haeProxyObject);
+}
+
+LaundryCyclePhaseIntfControllerImpl::LaundryCyclePhaseIntfControllerImpl(BusAttachment& busAttachment, LaundryCyclePhaseIntfControllerListener& listener, HaeProxyBusObject& haeProxyObject) :
+    InterfaceController(haeProxyObject),
+    m_busAttachment(busAttachment),
+    m_interfaceListener(listener)
+{
+}
+
+LaundryCyclePhaseIntfControllerImpl::~LaundryCyclePhaseIntfControllerImpl()
+{
+}
+
+QStatus LaundryCyclePhaseIntfControllerImpl::Init()
+{
+    QStatus status = HaeInterface::Init();
+    if (ER_OK != status) {
+        QCC_LogError(status, ("%s: Interface init failed.", __func__));
+        return status;
+    }
+
+    status = m_proxyObject.RegisterPropertiesChangedListener(GetInterfaceName().c_str(), NULL, 0, *this, NULL);
+    if (ER_OK != status) {
+        QCC_LogError(status, ("%s: RegisterPropertiesChangedListener failed.", __func__));
+    }
+
+    /**
+     * TODO: Register signal handler
+     */
+
+    return status;
+}
+
+void LaundryCyclePhaseIntfControllerImpl::PropertiesChanged(ProxyBusObject& obj, const char* ifaceName, const MsgArg& changed, const MsgArg& invalidated, void* context)
+{
+    MsgArg* entries;
+    size_t numEntries;
+
+    changed.Get("a{sv}", &numEntries, &entries);
+    for (size_t i = 0; i < numEntries; ++i)
+    {
+        const char* propName;
+        MsgArg* propValue;
+        entries[i].Get("{sv}", &propName, &propValue);
+        String propNameStr(propName);
+
+        if (!s_prop_CyclePhase.compare(propNameStr))
+        {
+            if (propValue->typeId == ALLJOYN_BYTE)
+            {
+                LaundryCyclePhaseInterface::LaundryCyclePhase cyclePhase = (LaundryCyclePhaseInterface::LaundryCyclePhase)propValue->v_byte;
+                m_interfaceListener.OnCyclePhasePropertyChanged(obj.GetPath(), cyclePhase);
+            }
+        }
+        else if (!s_prop_SupportedCyclePhases.compare(propNameStr))
+        {
+            if (propValue->typeId == ALLJOYN_BYTE_ARRAY)
+            {
+                LaundryCyclePhaseInterface::SupportedCyclePhases supportedCyclePhases;
+                uint8_t *vals;
+                size_t numVals;
+                propValue->Get("ay", &numVals, &vals);
+
+                for (size_t i = 0; i < numVals; ++i)
+                    supportedCyclePhases.push_back((LaundryCyclePhaseInterface::LaundryCyclePhase)vals[i]);
+                m_interfaceListener.OnSupportedCyclePhasesPropertyChanged(obj.GetPath(), supportedCyclePhases);
+            }
+        }
+    }
+}
+QStatus LaundryCyclePhaseIntfControllerImpl::GetCyclePhase(void* context)
+{
+    QStatus status = ER_OK;
+
+    status = m_proxyObject.GetPropertyAsync(GetInterfaceName().c_str(),s_prop_CyclePhase.c_str(),this,(ProxyBusObject::Listener::GetPropertyCB)&LaundryCyclePhaseIntfControllerImpl::GetCyclePhasePropertyCB,context);
+
+    return status;
+
+}
+
+QStatus LaundryCyclePhaseIntfControllerImpl::GetSupportedCyclePhases(void* context )
+{
+    QStatus status = ER_OK;
+
+    status = m_proxyObject.GetPropertyAsync(GetInterfaceName().c_str(),s_prop_SupportedCyclePhases.c_str(),this,(ProxyBusObject::Listener::GetPropertyCB)&LaundryCyclePhaseIntfControllerImpl::GetSupportedCyclePhasesPropertyCB,context);
+
+    return status;
+}
+
+QStatus LaundryCyclePhaseIntfControllerImpl::GetCyclePhasesDescriptions(const qcc::String& language, void* context)
+{
+    QStatus status = ER_OK;
+
+    MsgArg args[1];
+    args[0].typeId = ALLJOYN_STRING;
+    args[0].v_string.str = language.c_str();
+    args[0].v_string.len = language.size();
+
+    status = m_proxyObject.MethodCallAsync(GetInterfaceName().c_str(), s_method_GetVendorPhasesDescription.c_str(), this, (MessageReceiver::ReplyHandler)&LaundryCyclePhaseIntfControllerImpl::GetCyclePhasesDescriptionReplyHandler, args, 1, context);
+
+    return status;
+}
+
+void LaundryCyclePhaseIntfControllerImpl::GetCyclePhasePropertyCB(QStatus status, ProxyBusObject* obj, const MsgArg& value, void* context)
+{
+    if(!obj) {
+        return;
+    }
+
+    uint8_t cyclePhase;
+    value.Get("y", &cyclePhase);
+
+    m_interfaceListener.OnResponseGetCyclePhase(status, obj->GetPath(), (LaundryCyclePhase)cyclePhase, context);
+}
+void LaundryCyclePhaseIntfControllerImpl::GetSupportedCyclePhasesPropertyCB(QStatus status, ProxyBusObject* obj, const MsgArg& value, void* context)
+{
+    if(!obj) {
+        return;
+    }
+    uint8_t *vals;
+    size_t numVals;
+    value.Get("ay", &numVals, &vals);
+
+    SupportedCyclePhases cyclePhases;
+    for (size_t i = 0; i < numVals; ++i)
+        cyclePhases.push_back((LaundryCyclePhase)vals[i]);
+
+    m_interfaceListener.OnResponseGetSupportedCyclePhases(status, obj->GetPath(), cyclePhases, context);
+
+}
+
+void LaundryCyclePhaseIntfControllerImpl::GetCyclePhasesDescriptionReplyHandler(Message& message, void* context)
+{
+    LaundryCyclePhaseInterface::CyclePhaseDescriptions descriptions;
+    qcc::String errorMessage;
+    const char* errorName = message->GetErrorName(&errorMessage);
+    QStatus status = ER_OK;
+    if (message->GetType() != MESSAGE_METHOD_RET)
+    {
+        status = ER_FAIL;
+    }
+    else
+    {
+        size_t numArgs;
+        const MsgArg* args;
+        message->GetArgs(numArgs, args);
+
+        if (!args[0].HasSignature("a(yss)"))
+        {
+            return;
+        }
+
+        MsgArg* entries;
+        size_t numEntries;
+        LaundryCyclePhaseInterface::LaundryPhaseDescriptor desc;
+
+        args[0].Get("a(yss)", &numEntries, &entries);
+        for (size_t i = 0; i < numEntries; ++i)
+        {
+            const char* phaseName, *phaseDesc;
+            uint8_t phase;
+            entries[i].Get("(yss)", &phase, &phaseName, &phaseDesc);
+            desc.phase = (LaundryCyclePhase)phase;
+            desc.name = String(phaseName);
+            desc.description = String(phaseDesc);
+            descriptions.push_back(desc);
+        }
+    }
+    m_interfaceListener.OnResponseGetCyclePhasesDescriptions(status, m_proxyObject.GetPath(), descriptions, context, errorName, errorMessage.c_str());
+}
+
+} //namespace services
+} //namespace ajn
diff --git a/cpp/src/interfaces/operation/LaundryCyclePhaseIntfControllerImpl.h b/cpp/src/interfaces/operation/LaundryCyclePhaseIntfControllerImpl.h
new file mode 100644
index 0000000..29e9b68
--- /dev/null
+++ b/cpp/src/interfaces/operation/LaundryCyclePhaseIntfControllerImpl.h
@@ -0,0 +1,85 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#ifndef LAUNDRYCYCLEPHASEINTFCONTROLLERIMPL_H_
+#define LAUNDRYCYCLEPHASEINTFCONTROLLERIMPL_H_
+
+#include <alljoyn/Status.h>
+#include <alljoyn/BusAttachment.h>
+#include <alljoyn/hae/interfaces/InterfaceController.h>
+#include <alljoyn/hae/interfaces/operation/LaundryCyclePhaseIntfController.h>
+
+namespace ajn {
+namespace services {
+
+class LaundryCyclePhaseIntfControllerListener;
+class HaeProxyBusObject;
+
+/**
+ * LaundryCyclePhase Interface Controller implementation class
+ */
+class LaundryCyclePhaseIntfControllerImpl : public InterfaceController, public LaundryCyclePhaseIntfController {
+  public:
+    /**
+     * Create interface
+     */
+    static HaeInterface* CreateInterface(BusAttachment& busAttachment, InterfaceControllerListener& listener, HaeProxyBusObject& haeProxyObject);
+
+    /**
+     * Constructor of LaundryCyclePhaseIntfControllerImpl
+     */
+    LaundryCyclePhaseIntfControllerImpl(BusAttachment& busAttachment, LaundryCyclePhaseIntfControllerListener& listener, HaeProxyBusObject& haeProxyObject);
+
+    /**
+     * Destructor of LaundryCyclePhaseIntfControllerImpl
+     */
+    virtual ~LaundryCyclePhaseIntfControllerImpl();
+
+    /**
+     * Initialize interface
+     * @return status
+     */
+    virtual QStatus Init();
+
+    /**
+     * Get bus attachment
+     * @return bus attachment
+     */
+    virtual BusAttachment& GetBusAttachment() const { return m_busAttachment; }
+
+    virtual QStatus GetCyclePhase(void* context);
+
+    virtual QStatus GetSupportedCyclePhases(void* context );
+
+    virtual QStatus GetCyclePhasesDescriptions(const qcc::String& language, void* context);
+
+  private:
+    LaundryCyclePhaseIntfControllerImpl();
+
+    void PropertiesChanged(ProxyBusObject& obj, const char* ifaceName, const MsgArg& changed, const MsgArg& invalidated, void* context);
+
+    void GetCyclePhasePropertyCB(QStatus status, ProxyBusObject* obj, const MsgArg& value, void* context);
+    void GetSupportedCyclePhasesPropertyCB(QStatus status, ProxyBusObject* obj, const MsgArg& value, void* context);
+    void GetCyclePhasesDescriptionReplyHandler(Message& message, void* context);
+
+    BusAttachment& m_busAttachment;
+    LaundryCyclePhaseIntfControllerListener& m_interfaceListener;
+};
+
+} //namespace services
+} //namespace ajn
+
+#endif /* LAUNDRYCYCLEPHASEINTFCONTROLLERIMPL_H_ */
diff --git a/cpp/src/interfaces/operation/OvenCyclePhaseInterface.cc b/cpp/src/interfaces/operation/OvenCyclePhaseInterface.cc
new file mode 100644
index 0000000..34bc846
--- /dev/null
+++ b/cpp/src/interfaces/operation/OvenCyclePhaseInterface.cc
@@ -0,0 +1,63 @@
+/******************************************************************************
+ * Copyright (c) 2013-2014, AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#include <alljoyn/hae/LogModule.h>
+#include <alljoyn/hae/interfaces/operation/OvenCyclePhaseInterface.h>
+
+namespace ajn {
+namespace services {
+
+const uint16_t OvenCyclePhaseInterface::s_interfaceVersion = 1;
+
+// Below none secure xml is only for test
+const qcc::String OvenCyclePhaseInterface::s_xml =
+"<node xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance' xsi:noNamespaceSchemaLocation='http://www.allseenalliance.org/schemas/introspect.xsd'>"
+"    <interface name='org.alljoyn.SmartSpaces.Operation.OvenCyclePhase'>"
+"        <description language='en'>This interface provides a capability to monitor the phase of the operational cycle of the Oven</description>"
+"        <annotation name='org.alljoyn.Bus.Secure' value='true'/>"
+"        <property name='Version' type='q' access='read'>"
+"            <description language='en'>Interface version</description>"
+"            <annotation name='org.freedesktop.DBus.Property.EmitsChangedSignal' value='true'/>"
+"        </property>"
+"        <property name='CyclePhase' type='y' access='read'>"
+"            <description language='en'>Current cycle phase</description>"
+"            <annotation name='org.freedesktop.DBus.Property.EmitsChangedSignal' value='true'/>"
+"        </property>"
+"        <property name='SupportedCyclePhases' type='ay' access='read'>"
+"            <description language='en'>List of supported cycle phases</description>"
+"            <annotation name='org.freedesktop.DBus.Property.EmitsChangedSignal' value='true'/>"
+"        </property>"
+"        <method name='GetVendorPhasesDescription'>"
+"            <description language='en'>Get cycle phases description</description>"
+"            <arg name='languageTag' type='s' direction='in'>"
+"                <description language='en'>preferred language to be used in selecting the output strings</description>"
+"            </arg>"
+"            <arg name='phasesDescription' type='a(yss)' direction='out'>"
+"                <description language='en'>Cycle phases description</description>"
+"            </arg>"
+"        </method>"
+"   </interface>"
+"</node>"
+;
+
+const qcc::String OvenCyclePhaseInterface::s_prop_Version = "Version";
+const qcc::String OvenCyclePhaseInterface::s_prop_CyclePhase = "CyclePhase";
+const qcc::String OvenCyclePhaseInterface::s_prop_SupportedCyclePhases = "SupportedCyclePhases";
+const qcc::String OvenCyclePhaseInterface::s_method_GetVendorPhasesDescription = "GetVendorPhasesDescription";
+const OvenCyclePhaseInterface::StandardCyclePhases OvenCyclePhaseInterface::m_standardCyclePhases = { OVEN_PHASE_UNAVAILABLE, OVEN_PHASE_PREHEATING, OVEN_PHASE_COOKING, OVEN_PHASE_CLEANING };
+
+} //namespace services
+} //namespace ajn
diff --git a/cpp/src/interfaces/operation/OvenCyclePhaseIntfControlleeImpl.cc b/cpp/src/interfaces/operation/OvenCyclePhaseIntfControlleeImpl.cc
new file mode 100644
index 0000000..eed2d5b
--- /dev/null
+++ b/cpp/src/interfaces/operation/OvenCyclePhaseIntfControlleeImpl.cc
@@ -0,0 +1,345 @@
+/******************************************************************************
+ * Copyright (c) 2013-2014, AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#include <qcc/Util.h>
+#include <vector>
+#include <algorithm>
+#include <alljoyn/hae/LogModule.h>
+#include <alljoyn/hae/HaeBusObject.h>
+#include <alljoyn/hae/interfaces/operation/OvenCyclePhaseIntfControlleeListener.h>
+
+#include "OvenCyclePhaseIntfControlleeImpl.h"
+
+using namespace qcc;
+using namespace std;
+
+namespace ajn {
+namespace services {
+
+HaeInterface* OvenCyclePhaseIntfControlleeImpl::CreateInterface(BusAttachment& busAttachment, InterfaceControlleeListener& listener, HaeBusObject& haeBusObject)
+{
+    return new OvenCyclePhaseIntfControlleeImpl(busAttachment, dynamic_cast<OvenCyclePhaseIntfControlleeListener&>(listener), haeBusObject);
+}
+
+OvenCyclePhaseIntfControlleeImpl::OvenCyclePhaseIntfControlleeImpl(BusAttachment& busAttachment, OvenCyclePhaseIntfControlleeListener& listener, HaeBusObject& haeBusObject) :
+    InterfaceControllee(haeBusObject),
+    m_busAttachment(busAttachment),
+    m_interfaceListener(listener),
+    m_cyclePhase(OvenCyclePhaseInterface::OvenCyclePhase::OVEN_PHASE_PREHEATING)
+{
+}
+
+OvenCyclePhaseIntfControlleeImpl::~OvenCyclePhaseIntfControlleeImpl()
+{
+}
+
+QStatus OvenCyclePhaseIntfControlleeImpl::Init()
+{
+    QStatus status = HaeInterface::Init();
+
+    const InterfaceDescription::Member* member = m_interfaceDescription->GetMember(s_method_GetVendorPhasesDescription.c_str());
+    MessageReceiver::MethodHandler methodHandler = static_cast<MessageReceiver::MethodHandler>(&OvenCyclePhaseIntfControlleeImpl::OnGetCyclePhasesDescription);
+
+    m_methodHandlers.push_back(make_pair(member, methodHandler));
+
+    return status;
+}
+
+QStatus OvenCyclePhaseIntfControlleeImpl::OnGetProperty(const String propName, MsgArg& val)
+{
+    QStatus status = ER_OK;
+
+    if (!(s_prop_Version.compare(propName))) {
+        val.typeId = ALLJOYN_UINT16;
+        val.v_uint16 = GetInterfaceVersion();
+    }
+    else
+    {
+        if (s_retrievingActualPropertyValue)
+        {
+            if(!s_prop_CyclePhase.compare(propName))
+            {
+                uint8_t cyclePhase;
+                status = m_interfaceListener.OnGetCyclePhase(cyclePhase);
+                if (status != ER_OK) {
+                    cyclePhase = GetCyclePhase();
+                    QCC_LogError(status, ("%s: failed to get actual property value from application. use previous value.", __func__));
+                    status = ER_OK;
+                } else {
+                    SetCyclePhase(cyclePhase); // update the value in ChannelIntfControllee.
+                }
+
+                val.typeId = ALLJOYN_BYTE;
+                val.v_byte = (uint8_t)cyclePhase;
+
+            }
+            else if (!s_prop_SupportedCyclePhases.compare(propName))
+            {
+                SupportedCyclePhases supportedCyclePhases;
+                status = m_interfaceListener.OnGetSupportedCyclePhases(supportedCyclePhases);
+                if(status != ER_OK)
+                {
+                    supportedCyclePhases = GetSupportedCyclePhases();
+                    QCC_LogError(status, ("%s: failed to get actual property value from application. use previous value.", __func__));
+                }
+                else
+                {
+                    //update internal value
+                    SetSupportedCyclePhases(supportedCyclePhases);
+                }
+                uint8_t vals[supportedCyclePhases.size()];
+                size_t i = 0;
+
+                for(i = 0; i < supportedCyclePhases.size(); i++)
+                {
+                    vals[i] = (uint8_t)supportedCyclePhases[i];
+                }
+                val.Set("ay", sizeof(vals)/ sizeof(uint8_t), vals);
+                val.Stabilize();
+            }
+            else
+            {
+                status = ER_BUS_NO_SUCH_PROPERTY;
+            }
+        }
+        else
+        {
+            if(!s_prop_CyclePhase.compare(propName))
+            {
+                uint8_t cyclePhase;
+                cyclePhase = GetCyclePhase();
+
+                val.typeId = ALLJOYN_BYTE;
+                val.v_byte = (uint8_t)cyclePhase;
+            }
+            else if (!s_prop_SupportedCyclePhases.compare(propName))
+            {
+                SupportedCyclePhases supportedCyclePhases;
+                supportedCyclePhases = GetSupportedCyclePhases();
+                uint8_t vals[supportedCyclePhases.size()];
+                size_t i = 0;
+
+                for(i = 0; i < supportedCyclePhases.size(); i++)
+                {
+                    vals[i] = (uint8_t)supportedCyclePhases[i];
+                }
+                val.Set("ay", sizeof(vals)/ sizeof(uint8_t), vals);
+                val.Stabilize();
+            }
+            else
+            {
+                status = ER_BUS_NO_SUCH_PROPERTY;
+            }
+        }
+    }
+
+    return status;
+}
+
+QStatus OvenCyclePhaseIntfControlleeImpl::OnSetProperty(const String propName, MsgArg& val)
+{
+    QStatus status = ER_OK;
+
+    return status;
+}
+
+void OvenCyclePhaseIntfControlleeImpl::OnMethodHandler(const InterfaceDescription::Member* member, Message& msg)
+{
+    QStatus status = ER_OK;
+    bool isFound = false;
+    MethodHandlers::const_iterator it;
+    for (it = m_methodHandlers.begin(); it != m_methodHandlers.end(); ++it) {
+        if (it->first == member) {
+            MessageReceiver::MethodHandler handler = it->second;
+            (this->*handler)(member, msg);
+            isFound = true;
+            break;
+        }
+    }
+
+    if (!isFound) {
+        status = ER_BUS_METHOD_CALL_ABORTED;
+        QCC_LogError(status, ("%s: could not found method handler.", __func__));
+        m_busObject.ReplyMethodCall(msg, status);
+    }
+}
+QStatus OvenCyclePhaseIntfControlleeImpl::SetCyclePhase(const uint8_t cyclePhase)
+{
+    StandardCyclePhases::const_iterator stand_it;
+    std::vector<uint8_t>::iterator vend_it;
+
+    stand_it = std::find(m_standardCyclePhases.begin(), m_standardCyclePhases.end(), cyclePhase);
+    vend_it = std::find(m_vendorDefinedCyclePhases.begin(),m_vendorDefinedCyclePhases.end(),cyclePhase);
+
+    if(vend_it == m_vendorDefinedCyclePhases.end() && stand_it == m_standardCyclePhases.end())
+        return ER_FAIL;
+
+    SupportedCyclePhases::iterator supp_it;
+    supp_it = std::find(m_supportedCyclePhases.begin(),m_supportedCyclePhases.end(),cyclePhase);
+    if(supp_it == m_supportedCyclePhases.end())
+        return ER_FAIL;
+
+    if(m_cyclePhase != cyclePhase)
+    {
+        MsgArg arg;
+        arg.typeId = ALLJOYN_BYTE;
+        arg.v_byte = cyclePhase;
+        m_busObject.EmitPropChanged(GetInterfaceName().c_str(), s_prop_CyclePhase.c_str(), arg, 0, ALLJOYN_FLAG_GLOBAL_BROADCAST);
+        m_cyclePhase = cyclePhase;
+    }
+    return ER_OK;
+}
+
+QStatus OvenCyclePhaseIntfControlleeImpl::SetSupportedCyclePhases(const SupportedCyclePhases& supportedPhases)
+{
+    uint8_t vals[supportedPhases.size()];
+
+    bool listChanged = false;
+
+    if(m_supportedCyclePhases.size() != supportedPhases.size())
+        listChanged = true;
+    else
+    {
+        for (size_t i = 0; i < supportedPhases.size(); i++)
+        {
+            StandardCyclePhases::const_iterator stand_it;
+            std::vector<uint8_t>::iterator vend_it;
+
+            stand_it = std::find(m_standardCyclePhases.begin(), m_standardCyclePhases.end(), supportedPhases[i]);
+            vend_it = std::find(m_vendorDefinedCyclePhases.begin(),m_vendorDefinedCyclePhases.end(),supportedPhases[i]);
+
+            if(vend_it == m_vendorDefinedCyclePhases.end() && stand_it == m_standardCyclePhases.end())
+                return ER_FAIL;
+
+            if(supportedPhases[i] != m_supportedCyclePhases[i])
+            {
+                listChanged = true;
+                break;
+            }
+        }
+    }
+
+    if(listChanged)
+    {
+        m_supportedCyclePhases.clear();
+        for(size_t i = 0 ; i < supportedPhases.size(); i ++)
+        {
+            m_supportedCyclePhases.push_back(supportedPhases[i]);
+            vals[i] = (uint8_t)supportedPhases[i];
+        }
+
+        MsgArg arg;
+        arg.Set("ay", sizeof(vals)/ sizeof(uint8_t), vals);
+        arg.Stabilize();
+
+        m_busObject.EmitPropChanged(GetInterfaceName().c_str(), s_prop_SupportedCyclePhases.c_str(), arg, 0 , ALLJOYN_FLAG_GLOBAL_BROADCAST);
+    }
+    return ER_OK;
+}
+
+void OvenCyclePhaseIntfControlleeImpl::OnGetCyclePhasesDescription(const InterfaceDescription::Member* member, Message& msg)
+{
+    cout << "OvenCyclePhaseIntfControlleeImpl::OnGetCyclePhasesDescription" << endl;
+    QStatus status = ER_OK;
+
+    const MsgArg* args = NULL;
+    size_t numArgs = 0;
+
+    msg->GetArgs(numArgs, args);
+
+    if (numArgs == 1)
+    {
+        qcc::String lang(args[0].v_string.str);
+        if(lang.compare("en"))
+        {
+            status = ER_LANGUAGE_NOT_SUPPORTED;
+            QCC_LogError(status, ("%s: language not suppoerted", __func__));
+            m_busObject.ReplyMethodCall(msg, status);
+        }
+        else
+        {
+            CyclePhaseDescriptions listOfDescriptions;
+            ErrorCode errorCode = NOT_ERROR;
+            status = m_interfaceListener.OnGetCyclePhasesDescriptions(lang, listOfDescriptions, errorCode);
+            if(status == ER_OK)
+            {
+                int numReturned = listOfDescriptions.size();
+                OvenCyclePhaseInterface::CyclePhaseDescriptions::const_iterator citer;
+                MsgArg args[numReturned];
+                MsgArg retArgs[1];
+                int i=0;
+
+                for(citer = listOfDescriptions.begin(); citer != listOfDescriptions.end(); citer++, i++) {
+                    status = args[i].Set("(yss)", (uint8_t)citer->phase, citer->name.c_str(), citer->description.c_str());
+                    args[i].Stabilize();
+                }
+                status = retArgs[0].Set("a(yss)", i, args);
+                retArgs[0].Stabilize();
+                status = m_busObject.ReplyMethodCall(msg, retArgs, ArraySize(retArgs));
+            }
+            else
+            {
+                if (errorCode == NOT_ERROR)
+                {
+                    QCC_LogError(status, ("%s: status is not ER_OK, but errorCode was not set.", __func__));
+                    m_busObject.ReplyMethodCall(msg, status);
+                }
+                else
+                {
+                    m_busObject.ReplyMethodCall(msg, HaeInterface::GetInterfaceErrorName(errorCode).c_str(),HaeInterface::GetInterfaceErrorMessage(errorCode).c_str());
+                }
+            }
+        }
+    }
+    else
+    {
+        m_busObject.ReplyMethodCall(msg, ER_INVALID_DATA);
+    }
+}
+QStatus OvenCyclePhaseIntfControlleeImpl::SetVendorDefinedCyclePhases(const std::vector<uint8_t>& vendorPhases)
+{
+    for(size_t i = 0 ; i < vendorPhases.size(); i++)
+    {
+        if(vendorPhases[i] < 0x80 )
+            return ER_FAIL;
+    }
+    bool listChanged = false;
+    if(m_vendorDefinedCyclePhases.size() != vendorPhases.size())
+            listChanged = true;
+    else
+    {
+        for(size_t i = 0 ; i < vendorPhases.size(); i++)
+        {
+            std::vector<uint8_t>::iterator it;
+            it = std::find(m_vendorDefinedCyclePhases.begin(),m_vendorDefinedCyclePhases.end(), vendorPhases[i]);
+            if(it == m_vendorDefinedCyclePhases.end())
+            {
+                listChanged = true;
+                break;
+            }
+        }
+    }
+    if(listChanged)
+    {
+        m_vendorDefinedCyclePhases.clear();
+        for (size_t i =0;i<vendorPhases.size();i++)
+            m_vendorDefinedCyclePhases.push_back(vendorPhases[i]);
+    }
+    return ER_OK;
+}
+
+} //namespace services
+} //namespace ajn
diff --git a/cpp/src/interfaces/operation/OvenCyclePhaseIntfControlleeImpl.h b/cpp/src/interfaces/operation/OvenCyclePhaseIntfControlleeImpl.h
new file mode 100644
index 0000000..557edc7
--- /dev/null
+++ b/cpp/src/interfaces/operation/OvenCyclePhaseIntfControlleeImpl.h
@@ -0,0 +1,120 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#ifndef OVENCYCLEPHASEINTFCONTROLLEEIMPL_H_
+#define OVENCYCLEPHASEINTFCONTROLLEEIMPL_H_
+
+#include <alljoyn/Status.h>
+#include <alljoyn/BusAttachment.h>
+#include <alljoyn/InterfaceDescription.h>
+#include <alljoyn/hae/interfaces/InterfaceControllee.h>
+#include <alljoyn/hae/interfaces/InterfaceControlleeListener.h>
+#include <alljoyn/hae/interfaces/operation/OvenCyclePhaseIntfControllee.h>
+
+namespace ajn {
+namespace services {
+
+class OvenCyclePhaseIntfControlleeListener;
+class HaeBusObject;
+
+/**
+ * OvenCyclePhase Interface Controllee implementation class
+ */
+class OvenCyclePhaseIntfControlleeImpl : public InterfaceControllee, public OvenCyclePhaseIntfControllee {
+  public:
+    /**
+     * Create interface
+     */
+    static HaeInterface* CreateInterface(BusAttachment& busAttachment, InterfaceControlleeListener& listener, HaeBusObject& haeBusObject);
+
+    /**
+     * Constructor of OvenCyclePhaseIntfControlleeImpl
+     */
+    OvenCyclePhaseIntfControlleeImpl(BusAttachment& busAttachment, OvenCyclePhaseIntfControlleeListener& listener, HaeBusObject& haeBusObject);
+
+    /**
+     * Destructor of OvenCyclePhaseIntfControlleeImpl
+     */
+    virtual ~OvenCyclePhaseIntfControlleeImpl();
+
+    /**
+     * Initialize interface
+     * @return status
+     */
+     virtual QStatus Init();
+
+    /**
+     * a callback function for getting property.
+     * @param propName   Identifies the property to get
+     * @param[out] val   Returns the property value. The type of this value is the actual value type.
+     * @return status
+     */
+    virtual QStatus OnGetProperty(const qcc::String propName, MsgArg& val);
+
+    /**
+     * a callback function for setting property.
+     * @param propName  Identifies the property to set
+     * @param val       The property value to set. The type of this value is the actual value type.
+     */
+    virtual QStatus OnSetProperty(const qcc::String propName, MsgArg& val);
+
+    /**
+     * method handler
+     * @param member    Method interface member entry.
+     * @param message   The received method call message.
+     */
+    virtual void OnMethodHandler(const InterfaceDescription::Member* member, Message& msg);
+
+    /**
+     * Get method handlers
+     * @return MethodHandlers
+     */
+    virtual const MethodHandlers& GetMethodHanders() const { return m_methodHandlers; }
+
+    /**
+     * Get bus attachment
+     * @return bus attachment
+     */
+    virtual BusAttachment& GetBusAttachment() const { return m_busAttachment; }
+
+    virtual const uint8_t GetCyclePhase() const { return m_cyclePhase; }
+
+    virtual QStatus SetCyclePhase(const uint8_t cyclePhase);
+
+    virtual const SupportedCyclePhases& GetSupportedCyclePhases() const { return m_supportedCyclePhases; }
+
+    virtual QStatus SetSupportedCyclePhases(const SupportedCyclePhases& descriptions);
+
+    void OnGetCyclePhasesDescription(const InterfaceDescription::Member* member, Message& msg);
+
+    virtual QStatus SetVendorDefinedCyclePhases(const std::vector<uint8_t>& vendorPhases);
+
+  private:
+    OvenCyclePhaseIntfControlleeImpl();
+
+    BusAttachment& m_busAttachment;
+    OvenCyclePhaseIntfControlleeListener& m_interfaceListener;
+    MethodHandlers m_methodHandlers;
+    uint8_t m_cyclePhase;
+    SupportedCyclePhases m_supportedCyclePhases;
+    std::vector<uint8_t> m_vendorDefinedCyclePhases;
+
+};
+
+} //namespace services
+} //namespace ajn
+
+#endif /* OVENCYCLEPHASEINTFCONTROLLEEIMPL_H_ */
diff --git a/cpp/src/interfaces/operation/OvenCyclePhaseIntfControllerImpl.cc b/cpp/src/interfaces/operation/OvenCyclePhaseIntfControllerImpl.cc
new file mode 100644
index 0000000..98328b0
--- /dev/null
+++ b/cpp/src/interfaces/operation/OvenCyclePhaseIntfControllerImpl.cc
@@ -0,0 +1,197 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#include <qcc/Util.h>
+
+#include <alljoyn/hae/LogModule.h>
+#include <alljoyn/hae/HaeProxyBusObject.h>
+#include <alljoyn/hae/interfaces/operation/OvenCyclePhaseIntfControllerListener.h>
+
+#include "OvenCyclePhaseIntfControllerImpl.h"
+
+using namespace qcc;
+using namespace std;
+
+namespace ajn {
+namespace services {
+
+HaeInterface* OvenCyclePhaseIntfControllerImpl::CreateInterface(BusAttachment& busAttachment, InterfaceControllerListener& listener, HaeProxyBusObject& haeProxyObject)
+{
+    return new OvenCyclePhaseIntfControllerImpl(busAttachment, dynamic_cast<OvenCyclePhaseIntfControllerListener&>(listener), haeProxyObject);
+}
+
+OvenCyclePhaseIntfControllerImpl::OvenCyclePhaseIntfControllerImpl(BusAttachment& busAttachment, OvenCyclePhaseIntfControllerListener& listener, HaeProxyBusObject& haeProxyObject) :
+    InterfaceController(haeProxyObject),
+    m_busAttachment(busAttachment),
+    m_interfaceListener(listener)
+{
+}
+
+OvenCyclePhaseIntfControllerImpl::~OvenCyclePhaseIntfControllerImpl()
+{
+}
+
+QStatus OvenCyclePhaseIntfControllerImpl::Init()
+{
+    QStatus status = HaeInterface::Init();
+    if (ER_OK != status) {
+        QCC_LogError(status, ("%s: Interface init failed.", __func__));
+        return status;
+    }
+
+    status = m_proxyObject.RegisterPropertiesChangedListener(GetInterfaceName().c_str(), NULL, 0, *this, NULL);
+    if (ER_OK != status) {
+        QCC_LogError(status, ("%s: RegisterPropertiesChangedListener failed.", __func__));
+    }
+
+    return status;
+}
+
+void OvenCyclePhaseIntfControllerImpl::PropertiesChanged(ProxyBusObject& obj, const char* ifaceName, const MsgArg& changed, const MsgArg& invalidated, void* context)
+{
+    MsgArg* entries;
+    size_t numEntries;
+
+    changed.Get("a{sv}", &numEntries, &entries);
+    for (size_t i = 0; i < numEntries; ++i) {
+        const char* propName;
+        MsgArg* propValue;
+        entries[i].Get("{sv}", &propName, &propValue);
+        String propNameStr(propName);
+
+        if (!s_prop_CyclePhase.compare(propNameStr)) {
+            if (propValue->typeId == ALLJOYN_BYTE) {
+                OvenCyclePhaseInterface::OvenCyclePhase cyclePhase = (OvenCyclePhaseInterface::OvenCyclePhase)propValue->v_byte;
+                m_interfaceListener.OnCyclePhasePropertyChanged(obj.GetPath(), cyclePhase);
+            }
+        } else if (!s_prop_SupportedCyclePhases.compare(propNameStr)) {
+            if (propValue->typeId == ALLJOYN_BYTE_ARRAY) {
+                OvenCyclePhaseInterface::SupportedCyclePhases supportedCyclePhases;
+                uint8_t *vals;
+                size_t numVals;
+                propValue->Get("ay", &numVals, &vals);
+
+                for (size_t i = 0; i < numVals; ++i)
+                    supportedCyclePhases.push_back((OvenCyclePhaseInterface::OvenCyclePhase)vals[i]);
+                m_interfaceListener.OnSupportedCyclePhasesPropertyChanged(obj.GetPath(), supportedCyclePhases);
+            }
+        }
+    }
+}
+
+QStatus OvenCyclePhaseIntfControllerImpl::GetCyclePhase(void* context)
+{
+    QStatus status = ER_OK;
+
+    status = m_proxyObject.GetPropertyAsync(GetInterfaceName().c_str(),s_prop_CyclePhase.c_str(),this,(ProxyBusObject::Listener::GetPropertyCB)&OvenCyclePhaseIntfControllerImpl::GetCyclePhasePropertyCB,context);
+
+    return status;
+
+}
+
+QStatus OvenCyclePhaseIntfControllerImpl::GetSupportedCyclePhases(void* context )
+{
+    QStatus status = ER_OK;
+
+    status = m_proxyObject.GetPropertyAsync(GetInterfaceName().c_str(),s_prop_SupportedCyclePhases.c_str(),this,(ProxyBusObject::Listener::GetPropertyCB)&OvenCyclePhaseIntfControllerImpl::GetSupportedCyclePhasesPropertyCB,context);
+
+    return status;
+}
+
+QStatus OvenCyclePhaseIntfControllerImpl::GetCyclePhasesDescriptions(const qcc::String& language, void* context)
+{
+    QStatus status = ER_OK;
+
+    MsgArg args[1];
+    args[0].typeId = ALLJOYN_STRING;
+    args[0].v_string.str = language.c_str();
+    args[0].v_string.len = language.size();
+
+    status = m_proxyObject.MethodCallAsync(GetInterfaceName().c_str(), s_method_GetVendorPhasesDescription.c_str(), this, (MessageReceiver::ReplyHandler)&OvenCyclePhaseIntfControllerImpl::GetCyclePhasesDescriptionReplyHandler, args, 1, context);
+
+    return status;
+}
+
+void OvenCyclePhaseIntfControllerImpl::GetCyclePhasePropertyCB(QStatus status, ProxyBusObject* obj, const MsgArg& value, void* context)
+{
+    if(!obj) {
+        return;
+    }
+
+    uint8_t cyclePhase;
+    value.Get("y", &cyclePhase);
+
+    m_interfaceListener.OnResponseGetCyclePhase(status, obj->GetPath(), (OvenCyclePhase)cyclePhase, context);
+}
+void OvenCyclePhaseIntfControllerImpl::GetSupportedCyclePhasesPropertyCB(QStatus status, ProxyBusObject* obj, const MsgArg& value, void* context)
+{
+    if(!obj) {
+        return;
+    }
+    uint8_t *vals;
+    size_t numVals;
+    value.Get("ay", &numVals, &vals);
+
+    SupportedCyclePhases cyclePhases;
+    for (size_t i = 0; i < numVals; ++i)
+        cyclePhases.push_back((OvenCyclePhase)vals[i]);
+
+    m_interfaceListener.OnResponseGetSupportedCyclePhases(status, obj->GetPath(), cyclePhases, context);
+
+}
+
+void OvenCyclePhaseIntfControllerImpl::GetCyclePhasesDescriptionReplyHandler(Message& message, void* context)
+{
+    OvenCyclePhaseInterface::CyclePhaseDescriptions descriptions;
+    qcc::String errorMessage;
+    const char* errorName = message->GetErrorName(&errorMessage);
+    QStatus status = ER_OK;
+    if (message->GetType() != MESSAGE_METHOD_RET)
+    {
+        status = ER_FAIL;
+    }
+    else
+    {
+        size_t numArgs;
+        const MsgArg* args;
+        message->GetArgs(numArgs, args);
+
+        if (!args[0].HasSignature("a(yss)"))
+        {
+            return;
+        }
+
+        MsgArg* entries;
+        size_t numEntries;
+        OvenCyclePhaseInterface::OvenPhaseDescriptor desc;
+
+        args[0].Get("a(yss)", &numEntries, &entries);
+        for (size_t i = 0; i < numEntries; ++i)
+        {
+            const char* phaseName, *phaseDesc;
+            uint8_t phase;
+            entries[i].Get("(yss)", &phase, &phaseName, &phaseDesc);
+            desc.phase = (OvenCyclePhase)phase;
+            desc.name = String(phaseName);
+            desc.description = String(phaseDesc);
+            descriptions.push_back(desc);
+        }
+    }
+    m_interfaceListener.OnResponseGetCyclePhasesDescriptions(status, m_proxyObject.GetPath(), descriptions, context, errorName, errorMessage.c_str());
+}
+
+} //namespace services
+} //namespace ajn
diff --git a/cpp/src/interfaces/operation/OvenCyclePhaseIntfControllerImpl.h b/cpp/src/interfaces/operation/OvenCyclePhaseIntfControllerImpl.h
new file mode 100644
index 0000000..d7db359
--- /dev/null
+++ b/cpp/src/interfaces/operation/OvenCyclePhaseIntfControllerImpl.h
@@ -0,0 +1,85 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#ifndef OVENCYCLEPHASEINTFCONTROLLERIMPL_H_
+#define OVENCYCLEPHASEINTFCONTROLLERIMPL_H_
+
+#include <alljoyn/Status.h>
+#include <alljoyn/BusAttachment.h>
+#include <alljoyn/hae/interfaces/InterfaceController.h>
+#include <alljoyn/hae/interfaces/operation/OvenCyclePhaseIntfController.h>
+
+namespace ajn {
+namespace services {
+
+class OvenCyclePhaseIntfControllerListener;
+class HaeProxyBusObject;
+
+/**
+ * OvenCyclePhase Interface Controller implementation class
+ */
+class OvenCyclePhaseIntfControllerImpl : public InterfaceController, public OvenCyclePhaseIntfController {
+  public:
+    /**
+     * Create interface
+     */
+    static HaeInterface* CreateInterface(BusAttachment& busAttachment, InterfaceControllerListener& listener, HaeProxyBusObject& haeProxyObject);
+
+    /**
+     * Constructor of OvenCyclePhaseIntfControllerImpl
+     */
+    OvenCyclePhaseIntfControllerImpl(BusAttachment& busAttachment, OvenCyclePhaseIntfControllerListener& listener, HaeProxyBusObject& haeProxyObject);
+
+    /**
+     * Destructor of OvenCyclePhaseIntfControllerImpl
+     */
+    virtual ~OvenCyclePhaseIntfControllerImpl();
+
+    /**
+     * Initialize interface
+     * @return status
+     */
+    virtual QStatus Init();
+
+    /**
+     * Get bus attachment
+     * @return bus attachment
+     */
+    virtual BusAttachment& GetBusAttachment() const { return m_busAttachment; }
+
+    virtual QStatus GetCyclePhase(void* context);
+
+    virtual QStatus GetSupportedCyclePhases(void* context );
+
+    virtual QStatus GetCyclePhasesDescriptions(const qcc::String& language, void* context);
+
+  private:
+    OvenCyclePhaseIntfControllerImpl();
+
+    void PropertiesChanged(ProxyBusObject& obj, const char* ifaceName, const MsgArg& changed, const MsgArg& invalidated, void* context);
+
+    void GetCyclePhasePropertyCB(QStatus status, ProxyBusObject* obj, const MsgArg& value, void* context);
+    void GetSupportedCyclePhasesPropertyCB(QStatus status, ProxyBusObject* obj, const MsgArg& value, void* context);
+    void GetCyclePhasesDescriptionReplyHandler(Message& message, void* context);
+
+    BusAttachment& m_busAttachment;
+    OvenCyclePhaseIntfControllerListener& m_interfaceListener;
+};
+
+} //namespace services
+} //namespace ajn
+
+#endif /* OVENCYCLEPHASEINTFCONTROLLERIMPL_H_ */
diff --git a/cpp/src/interfaces/operation/RapidModeInterface.cc b/cpp/src/interfaces/operation/RapidModeInterface.cc
new file mode 100644
index 0000000..da70ff0
--- /dev/null
+++ b/cpp/src/interfaces/operation/RapidModeInterface.cc
@@ -0,0 +1,50 @@
+/******************************************************************************
+ * Copyright (c) 2013-2014, AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#include <alljoyn/hae/LogModule.h>
+#include <alljoyn/hae/interfaces/operation/RapidModeInterface.h>
+
+namespace ajn {
+namespace services {
+
+const uint16_t RapidModeInterface::s_interfaceVersion = 1;
+
+// Below none secure xml is only for test
+const qcc::String RapidModeInterface::s_xml =
+"<node xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance' xsi:noNamespaceSchemaLocation='http://www.allseenalliance.org/schemas/introspect.xsd'>"
+"    <interface name='org.alljoyn.SmartSpaces.Operation.RapidMode'>"
+"        <description language='en'>Interface that exposes the Rapid (or Turbo) mode.  This is the opposite of ResourceSaving, the device works in a more aggressive mode, usually at an efficiency or noise level penalty. </description>"
+"        <annotation name='org.alljoyn.Bus.Secure' value='true' />"
+"        <property name='Version' type='q' access='read'>"
+"            <description language='en'>The version of this interface</description>"
+"            <annotation name='org.freedesktop.DBus.Property.EmitsChangedSignal' value='true'/>"
+"        </property>"
+"        <property name='RapidMode' type='b' access='readwrite'>"
+"            <description language='en'>True if the device is currently operating in rapid mode.</description>"
+"            <annotation name='org.freedesktop.DBus.Property.EmitsChangedSignal' value='true'/>"
+"        </property>"
+"    </interface>"
+"</node>"
+;
+
+const qcc::String RapidModeInterface::s_prop_Version = "Version";
+const qcc::String RapidModeInterface::s_prop_RapidMode = "RapidMode";
+/**
+ * TODO: initialize property, method and signal name variable
+ */
+
+} //namespace services
+} //namespace ajn
diff --git a/cpp/src/interfaces/operation/RapidModeIntfControlleeImpl.cc b/cpp/src/interfaces/operation/RapidModeIntfControlleeImpl.cc
new file mode 100644
index 0000000..e198e0b
--- /dev/null
+++ b/cpp/src/interfaces/operation/RapidModeIntfControlleeImpl.cc
@@ -0,0 +1,165 @@
+/******************************************************************************
+ * Copyright (c) 2013-2014, AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#include <qcc/Util.h>
+
+#include <alljoyn/hae/LogModule.h>
+#include <alljoyn/hae/HaeBusObject.h>
+#include <alljoyn/hae/interfaces/operation/RapidModeIntfControlleeListener.h>
+
+#include "RapidModeIntfControlleeImpl.h"
+
+using namespace qcc;
+using namespace std;
+
+namespace ajn {
+namespace services {
+
+HaeInterface* RapidModeIntfControlleeImpl::CreateInterface(BusAttachment& busAttachment, InterfaceControlleeListener& listener, HaeBusObject& haeBusObject)
+{
+    return new RapidModeIntfControlleeImpl(busAttachment, dynamic_cast<RapidModeIntfControlleeListener&>(listener), haeBusObject);
+}
+
+RapidModeIntfControlleeImpl::RapidModeIntfControlleeImpl(BusAttachment& busAttachment, RapidModeIntfControlleeListener& listener, HaeBusObject& haeBusObject) :
+    InterfaceControllee(haeBusObject),
+    m_busAttachment(busAttachment),
+    m_interfaceListener(listener),
+    m_rapidMode(false)
+{
+}
+
+RapidModeIntfControlleeImpl::~RapidModeIntfControlleeImpl()
+{
+}
+
+QStatus RapidModeIntfControlleeImpl::Init()
+{
+    QStatus status = HaeInterface::Init();
+    return status;
+}
+
+QStatus RapidModeIntfControlleeImpl::OnGetProperty(const String propName, MsgArg& val)
+{
+    QStatus status = ER_OK;
+
+    cout << "On get property. propName: " << propName << endl;
+
+    if (!(s_prop_Version.compare(propName))) {
+        val.typeId = ALLJOYN_UINT16;
+        val.v_uint16 = GetInterfaceVersion();
+    } else {
+        if (s_retrievingActualPropertyValue) {
+            if(!s_prop_RapidMode.compare(propName)) {
+                bool rapidMode;
+                status = m_interfaceListener.OnGetRapidMode(rapidMode);
+                if(status != ER_OK) {
+                    QCC_LogError(status, ("%s: failed to get property.",__func__));
+                    rapidMode = GetRapidMode();
+                }
+                else
+                {
+                    //update internal value;
+                    SetRapidMode(rapidMode);
+                }
+                val.typeId = ALLJOYN_BOOLEAN;
+                val.v_bool = rapidMode;
+            }
+            else {
+                status = ER_BUS_NO_SUCH_PROPERTY;
+            }
+        } else {
+            if(!s_prop_RapidMode.compare(propName)) {
+                bool rapidMode = GetRapidMode();
+                val.typeId = ALLJOYN_BOOLEAN;
+                val.v_bool = rapidMode;
+            }
+            else {
+                status = ER_BUS_NO_SUCH_PROPERTY;
+            }
+       }
+    }
+
+    return status;
+}
+
+QStatus RapidModeIntfControlleeImpl::OnSetProperty(const String propName, MsgArg& val)
+{
+    QStatus status = ER_OK;
+    cout << "On Set property. propName: " << propName << endl;
+
+    if(!s_prop_RapidMode.compare(propName)){
+        if(val.typeId != ALLJOYN_BOOLEAN) {
+            status = ER_BUS_BAD_VALUE_TYPE;
+            return status;
+        }
+        bool rapidMode;
+        status = val.Get("b", &rapidMode);
+        if(status != ER_OK) {
+            status = ER_BUS_PROPERTY_VALUE_NOT_SET;
+            return status;
+        }
+        status = m_interfaceListener.OnSetRapidMode(rapidMode);
+        if(status != ER_OK) {
+            status = ER_INVALID_DATA;
+            QCC_LogError(status, ("%s: property value not set ", __func__));
+        } else {
+            status = SetRapidMode(rapidMode);
+        }
+    }
+    else {
+        status = ER_BUS_NO_SUCH_PROPERTY;
+    }
+
+    return status;
+}
+
+void RapidModeIntfControlleeImpl::OnMethodHandler(const InterfaceDescription::Member* member, Message& msg)
+{
+    QStatus status = ER_OK;
+    bool isFound = false;
+    MethodHandlers::const_iterator it;
+    for (it = m_methodHandlers.begin(); it != m_methodHandlers.end(); ++it) {
+        if (it->first == member) {
+            MessageReceiver::MethodHandler handler = it->second;
+            (this->*handler)(member, msg);
+            isFound = true;
+            break;
+        }
+    }
+
+    if (!isFound) {
+        status = ER_BUS_METHOD_CALL_ABORTED;
+        QCC_LogError(status, ("%s: could not found method handler.", __func__));
+        m_busObject.ReplyMethodCall(msg, status);
+    }
+}
+
+QStatus RapidModeIntfControlleeImpl::SetRapidMode(const bool rapidMode)
+{
+    if(m_rapidMode != rapidMode)
+    {
+        MsgArg val;
+        val.typeId = ALLJOYN_BOOLEAN;
+        val.v_bool = rapidMode;
+
+        m_busObject.EmitPropChanged(GetInterfaceName().c_str(), s_prop_RapidMode.c_str(), val, 0, ALLJOYN_FLAG_GLOBAL_BROADCAST);
+        m_rapidMode = rapidMode;
+    }
+    return ER_OK;
+}
+
+} //namespace services
+} //namespace ajn
diff --git a/cpp/src/interfaces/operation/RapidModeIntfControlleeImpl.h b/cpp/src/interfaces/operation/RapidModeIntfControlleeImpl.h
new file mode 100644
index 0000000..b52ae43
--- /dev/null
+++ b/cpp/src/interfaces/operation/RapidModeIntfControlleeImpl.h
@@ -0,0 +1,118 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#ifndef RAPIDMODEINTFCONTROLLEEIMPL_H_
+#define RAPIDMODEINTFCONTROLLEEIMPL_H_
+
+#include <alljoyn/Status.h>
+#include <alljoyn/BusAttachment.h>
+#include <alljoyn/InterfaceDescription.h>
+#include <alljoyn/hae/interfaces/InterfaceControllee.h>
+#include <alljoyn/hae/interfaces/InterfaceControlleeListener.h>
+#include <alljoyn/hae/interfaces/operation/RapidModeIntfControllee.h>
+
+namespace ajn {
+namespace services {
+
+class RapidModeIntfControlleeListener;
+class HaeBusObject;
+
+/**
+ * RapidMode Interface Controllee implementation class
+ */
+class RapidModeIntfControlleeImpl : public InterfaceControllee, public RapidModeIntfControllee {
+  public:
+    /**
+     * Create interface
+     */
+    static HaeInterface* CreateInterface(BusAttachment& busAttachment, InterfaceControlleeListener& listener, HaeBusObject& haeBusObject);
+
+    /**
+     * Constructor of RapidModeIntfControlleeImpl
+     */
+    RapidModeIntfControlleeImpl(BusAttachment& busAttachment, RapidModeIntfControlleeListener& listener, HaeBusObject& haeBusObject);
+
+    /**
+     * Destructor of RapidModeIntfControlleeImpl
+     */
+    virtual ~RapidModeIntfControlleeImpl();
+
+    /**
+     * Initialize interface
+     * @return status
+     */
+     virtual QStatus Init();
+
+    /**
+     * a callback function for getting property.
+     * @param propName   Identifies the property to get
+     * @param[out] val   Returns the property value. The type of this value is the actual value type.
+     * @return status
+     */
+    virtual QStatus OnGetProperty(const qcc::String propName, MsgArg& val);
+
+    /**
+     * a callback function for setting property.
+     * @param propName  Identifies the property to set
+     * @param val       The property value to set. The type of this value is the actual value type.
+     */
+    virtual QStatus OnSetProperty(const qcc::String propName, MsgArg& val);
+
+    /**
+     * method handler
+     * @param member    Method interface member entry.
+     * @param message   The received method call message.
+     */
+    virtual void OnMethodHandler(const InterfaceDescription::Member* member, Message& msg);
+
+    /**
+     * Get method handlers
+     * @return MethodHandlers
+     */
+    virtual const MethodHandlers& GetMethodHanders() const { return m_methodHandlers; }
+
+    /**
+     * Get bus attachment
+     * @return bus attachment
+     */
+    virtual BusAttachment& GetBusAttachment() const { return m_busAttachment; }
+
+    /**
+     * Get RapidMode
+     * @return rapid mode
+     */
+    virtual const bool GetRapidMode() const { return m_rapidMode; }
+
+    /**
+     * Set RapidMode
+     * @param[in] rapid mode
+     * @return ER_OK on successful
+     */
+    virtual QStatus SetRapidMode(const bool rapidMode);
+
+  private:
+    RapidModeIntfControlleeImpl();
+
+    BusAttachment& m_busAttachment;
+    RapidModeIntfControlleeListener& m_interfaceListener;
+    MethodHandlers m_methodHandlers;
+    bool m_rapidMode;
+};
+
+} //namespace services
+} //namespace ajn
+
+#endif /* RAPIDMODEINTFCONTROLLEEIMPL_H_ */
diff --git a/cpp/src/interfaces/operation/RapidModeIntfControllerImpl.cc b/cpp/src/interfaces/operation/RapidModeIntfControllerImpl.cc
new file mode 100644
index 0000000..be6ed43
--- /dev/null
+++ b/cpp/src/interfaces/operation/RapidModeIntfControllerImpl.cc
@@ -0,0 +1,135 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#include <qcc/Util.h>
+
+#include <alljoyn/hae/LogModule.h>
+#include <alljoyn/hae/HaeProxyBusObject.h>
+#include <alljoyn/hae/interfaces/operation/RapidModeIntfControllerListener.h>
+
+#include "RapidModeIntfControllerImpl.h"
+
+using namespace qcc;
+using namespace std;
+
+namespace ajn {
+namespace services {
+
+HaeInterface* RapidModeIntfControllerImpl::CreateInterface(BusAttachment& busAttachment, InterfaceControllerListener& listener, HaeProxyBusObject& haeProxyObject)
+{
+    return new RapidModeIntfControllerImpl(busAttachment, dynamic_cast<RapidModeIntfControllerListener&>(listener), haeProxyObject);
+}
+
+RapidModeIntfControllerImpl::RapidModeIntfControllerImpl(BusAttachment& busAttachment, RapidModeIntfControllerListener& listener, HaeProxyBusObject& haeProxyObject) :
+    InterfaceController(haeProxyObject),
+    m_busAttachment(busAttachment),
+    m_interfaceListener(listener)
+{
+}
+
+RapidModeIntfControllerImpl::~RapidModeIntfControllerImpl()
+{
+}
+
+QStatus RapidModeIntfControllerImpl::Init()
+{
+    QStatus status = HaeInterface::Init();
+    if (ER_OK != status) {
+        QCC_LogError(status, ("%s: Interface init failed.", __func__));
+        return status;
+    }
+
+    status = m_proxyObject.RegisterPropertiesChangedListener(GetInterfaceName().c_str(), NULL, 0, *this, NULL);
+    if (ER_OK != status) {
+        QCC_LogError(status, ("%s: RegisterPropertiesChangedListener failed.", __func__));
+    }
+
+    /**
+     * TODO: Register signal handler
+     */
+
+    return status;
+}
+
+void RapidModeIntfControllerImpl::PropertiesChanged(ProxyBusObject& obj, const char* ifaceName, const MsgArg& changed, const MsgArg& invalidated, void* context)
+{
+    MsgArg* entries;
+    size_t numEntries;
+
+    changed.Get("a{sv}", &numEntries, &entries);
+    for (size_t i = 0; i < numEntries; ++i)
+    {
+        const char* propName;
+        MsgArg* propValue;
+        entries[i].Get("{sv}", &propName, &propValue);
+        String propNameStr(propName);
+
+        if (!s_prop_RapidMode.compare(propNameStr)) {
+            if (propValue->typeId == ALLJOYN_BOOLEAN) {
+                bool rapidMode = propValue->v_bool;
+                m_interfaceListener.RapidModePropertyChanged(obj.GetPath(), rapidMode);
+            }
+        }
+    }
+}
+
+QStatus RapidModeIntfControllerImpl::GetRapidMode(void* context)
+{
+    QStatus status = ER_OK;
+
+    cout << "IF: " << GetInterfaceName().c_str() << endl;
+    cout << "prop: " << s_prop_RapidMode.c_str() << endl;
+    status = m_proxyObject.GetPropertyAsync(GetInterfaceName().c_str(), s_prop_RapidMode.c_str(), this, (ProxyBusObject::Listener::GetPropertyCB)&RapidModeIntfControllerImpl::GetRapidModePropertyCB, context);
+
+    return status;
+}
+
+QStatus RapidModeIntfControllerImpl::SetRapidMode(const bool rapidMode, void* context)
+{
+    QStatus status = ER_OK;
+
+    MsgArg arg;
+    arg.Set("b", rapidMode);
+    cout << "IF: " << GetInterfaceName().c_str() << endl;
+    cout << "prop: " << s_prop_RapidMode.c_str() << endl;
+    status = m_proxyObject.SetPropertyAsync(GetInterfaceName().c_str(), s_prop_RapidMode.c_str(), arg, this, (ProxyBusObject::Listener::SetPropertyCB)&RapidModeIntfControllerImpl::SetRapidModePropertyCB, context);
+
+    return status;
+}
+
+
+void RapidModeIntfControllerImpl::SetRapidModePropertyCB(QStatus status, ProxyBusObject* obj, void* context)
+{
+    if(!obj){
+        return;
+    }
+
+    m_interfaceListener.OnSetRapidModePropertyCallback(status, obj->GetPath(), context);
+}
+void RapidModeIntfControllerImpl::GetRapidModePropertyCB(QStatus status, ProxyBusObject* obj, const MsgArg& value, void* context)
+{
+    if(!obj) {
+        return;
+    }
+    bool rapidMode;
+
+    value.Get("b", &rapidMode);
+
+    m_interfaceListener.OnGetRapidModePropertyCallback(status, obj->GetPath(), rapidMode, context);
+}
+
+} //namespace services
+} //namespace ajn
diff --git a/cpp/src/interfaces/operation/RapidModeIntfControllerImpl.h b/cpp/src/interfaces/operation/RapidModeIntfControllerImpl.h
new file mode 100644
index 0000000..f997b01
--- /dev/null
+++ b/cpp/src/interfaces/operation/RapidModeIntfControllerImpl.h
@@ -0,0 +1,93 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#ifndef RAPIDMODEINTFCONTROLLERIMPL_H_
+#define RAPIDMODEINTFCONTROLLERIMPL_H_
+
+#include <alljoyn/Status.h>
+#include <alljoyn/BusAttachment.h>
+#include <alljoyn/hae/interfaces/InterfaceController.h>
+#include <alljoyn/hae/interfaces/operation/RapidModeIntfController.h>
+
+namespace ajn {
+namespace services {
+
+class RapidModeIntfControllerListener;
+class HaeProxyBusObject;
+
+/**
+ * RapidMode Interface Controller implementation class
+ */
+class RapidModeIntfControllerImpl : public InterfaceController, public RapidModeIntfController {
+  public:
+    /**
+     * Create interface
+     */
+    static HaeInterface* CreateInterface(BusAttachment& busAttachment, InterfaceControllerListener& listener, HaeProxyBusObject& haeProxyObject);
+
+    /**
+     * Constructor of RapidModeIntfControllerImpl
+     */
+    RapidModeIntfControllerImpl(BusAttachment& busAttachment, RapidModeIntfControllerListener& listener, HaeProxyBusObject& haeProxyObject);
+
+    /**
+     * Destructor of RapidModeIntfControllerImpl
+     */
+    virtual ~RapidModeIntfControllerImpl();
+
+    /**
+     * Initialize interface
+     * @return status
+     */
+    virtual QStatus Init();
+
+    /**
+     * Get bus attachment
+     * @return bus attachment
+     */
+    virtual BusAttachment& GetBusAttachment() const { return m_busAttachment; }
+
+    /**
+     * Get RapidMode
+     * @param[in] context the context that is passed to the callback handler
+     * return ER_OK on successful
+     */
+    virtual QStatus GetRapidMode(void* context = NULL);
+
+    /**
+     * Set RapidMode
+     * @param[in] rapidMode rapid mode
+     * @param[in] context the context that is passed to the callback handler
+     * return ER_OK on successful
+     */
+    virtual QStatus SetRapidMode(const bool rapidMode, void* context = NULL);
+
+  private:
+    RapidModeIntfControllerImpl();
+
+    void PropertiesChanged(ProxyBusObject& obj, const char* ifaceName, const MsgArg& changed, const MsgArg& invalidated, void* context);
+
+    void SetRapidModePropertyCB(QStatus status, ProxyBusObject* obj, void* context);
+    void GetRapidModePropertyCB(QStatus status, ProxyBusObject* obj, const MsgArg& value, void* context);
+
+    BusAttachment& m_busAttachment;
+    RapidModeIntfControllerListener& m_interfaceListener;
+};
+
+} //namespace services
+} //namespace ajn
+
+#endif /* RAPIDMODEINTFCONTROLLERIMPL_H_ */
diff --git a/cpp/src/interfaces/operation/RemoteControllabilityInterface.cc b/cpp/src/interfaces/operation/RemoteControllabilityInterface.cc
new file mode 100644
index 0000000..e3a75c7
--- /dev/null
+++ b/cpp/src/interfaces/operation/RemoteControllabilityInterface.cc
@@ -0,0 +1,47 @@
+/******************************************************************************
+ * Copyright (c) 2013-2014, AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#include <alljoyn/hae/LogModule.h>
+#include <alljoyn/hae/interfaces/operation/RemoteControllabilityInterface.h>
+
+namespace ajn {
+namespace services {
+
+const uint16_t RemoteControllabilityInterface::s_interfaceVersion = 1;
+
+// Below none secure xml is only for test
+const qcc::String RemoteControllabilityInterface::s_xml =
+"<node xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance' xsi:noNamespaceSchemaLocation='http://www.allseenalliance.org/schemas/introspect.xsd'>"
+"    <interface name='org.alljoyn.SmartSpaces.Operation.RemoteControllability'>"
+"        <description language='en'>This interface provides a capability to monitor a remote control enabled/disabled status.</description>"
+"        <annotation name='org.alljoyn.Bus.Secure' value='true'/>"
+"        <property name='Version' type='q' access='read'>"
+"            <description language='en'>Interface version</description>"
+"            <annotation name='org.freedesktop.DBus.Property.EmitsChangedSignal' value='true'/>"
+"        </property>"
+"        <property name='IsControllable' type='b' access='read'>"
+"            <description language='en'>Status of remote controllability. </description>"
+"            <annotation name='org.freedesktop.DBus.Property.EmitsChangedSignal' value='true'/>"
+"        </property>"
+"    </interface>"
+"</node>"
+;
+
+const qcc::String RemoteControllabilityInterface::s_prop_Version = "Version";
+const qcc::String RemoteControllabilityInterface::s_prop_IsControllable = "IsControllable";
+
+} //namespace services
+} //namespace ajn
diff --git a/cpp/src/interfaces/operation/RemoteControllabilityIntfControlleeImpl.cc b/cpp/src/interfaces/operation/RemoteControllabilityIntfControlleeImpl.cc
new file mode 100644
index 0000000..6235b13
--- /dev/null
+++ b/cpp/src/interfaces/operation/RemoteControllabilityIntfControlleeImpl.cc
@@ -0,0 +1,153 @@
+/******************************************************************************
+ * Copyright (c) 2013-2014, AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#include <qcc/Util.h>
+
+#include <alljoyn/hae/LogModule.h>
+#include <alljoyn/hae/interfaces/operation/RemoteControllabilityIntfControlleeListener.h>
+
+#include "RemoteControllabilityIntfControlleeImpl.h"
+#include <alljoyn/hae/HaeBusObject.h>
+
+using namespace qcc;
+using namespace std;
+
+namespace ajn {
+namespace services {
+
+HaeInterface* RemoteControllabilityIntfControlleeImpl::CreateInterface(BusAttachment& busAttachment, InterfaceControlleeListener& listener, HaeBusObject& haeBusObject)
+{
+    return new RemoteControllabilityIntfControlleeImpl(busAttachment, dynamic_cast<RemoteControllabilityIntfControlleeListener&>(listener), haeBusObject);
+}
+
+RemoteControllabilityIntfControlleeImpl::RemoteControllabilityIntfControlleeImpl(BusAttachment& busAttachment, RemoteControllabilityIntfControlleeListener& listener, HaeBusObject& haeBusObject) :
+    InterfaceControllee(haeBusObject),
+    m_busAttachment(busAttachment),
+    m_interfaceListener(listener),
+    m_isControllable(true)
+{
+}
+
+RemoteControllabilityIntfControlleeImpl::~RemoteControllabilityIntfControlleeImpl()
+{
+}
+
+QStatus RemoteControllabilityIntfControlleeImpl::Init()
+{
+    QStatus status = HaeInterface::Init();
+
+    return status;
+}
+
+QStatus RemoteControllabilityIntfControlleeImpl::OnGetProperty(const String propName, MsgArg& val)
+{
+    QStatus status = ER_OK;
+
+    if (!(s_prop_Version.compare(propName)))
+    {
+        val.typeId = ALLJOYN_UINT16;
+        val.v_uint16 = GetInterfaceVersion();
+    }
+    else
+    {
+        if (s_retrievingActualPropertyValue)
+        {
+            if(!s_prop_IsControllable.compare(propName))
+            {
+                bool isControllable;
+                status = m_interfaceListener.OnGetIsControllable(isControllable);
+                if (status != ER_OK)
+                {
+                    isControllable= GetIsControllable();
+                    QCC_LogError(status, ("%s: failed to get actual property value from application. use previous value.", __func__));
+                    status = ER_OK;
+                }
+                else
+                {
+                    QCC_LogError(status, ("%s: else in this function. Line = %d", __func__, __LINE__));
+                    //Update internal value and emit propChanged if this prop is changed
+                    SetIsControllable(isControllable);
+                }
+                val.typeId = ALLJOYN_BYTE;
+                val.v_bool = isControllable;
+            }
+            else
+            {
+                status = ER_BUS_NO_SUCH_PROPERTY;
+            }
+        }
+        else
+        {
+            if (!(s_prop_IsControllable.compare(propName)))
+            {
+                const bool isControllable= GetIsControllable();
+                val.typeId = ALLJOYN_BOOLEAN;
+                val.v_bool = isControllable;
+            }
+            else
+            {
+                status = ER_BUS_NO_SUCH_PROPERTY;
+            }
+        }
+    }
+
+    return status;
+}
+
+QStatus RemoteControllabilityIntfControlleeImpl::OnSetProperty(const String propName, MsgArg& val)
+{
+    QStatus status = ER_OK;
+
+    return status;
+}
+
+QStatus RemoteControllabilityIntfControlleeImpl::SetIsControllable(const bool isControllable)
+{
+    if(m_isControllable != isControllable)
+    {
+        MsgArg val;
+        val.typeId = ALLJOYN_BOOLEAN;
+        val.v_bool = isControllable;
+        m_busObject.EmitPropChanged(GetInterfaceName().c_str(), s_prop_IsControllable.c_str(), val, 0, ALLJOYN_FLAG_GLOBAL_BROADCAST);
+        m_isControllable= isControllable;
+    }
+    return ER_OK;
+}
+
+void RemoteControllabilityIntfControlleeImpl::OnMethodHandler(const InterfaceDescription::Member* member, Message& msg)
+{
+    QStatus status = ER_OK;
+    bool isFound = false;
+    MethodHandlers::const_iterator it;
+    for (it = m_methodHandlers.begin(); it != m_methodHandlers.end(); ++it) {
+        if (it->first == member) {
+            MessageReceiver::MethodHandler handler = it->second;
+            (this->*handler)(member, msg);
+            isFound = true;
+            break;
+        }
+    }
+
+    if (!isFound) {
+        status = ER_BUS_METHOD_CALL_ABORTED;
+        QCC_LogError(status, ("%s: could not found method handler.", __func__));
+        m_busObject.ReplyMethodCall(msg, status);
+    }
+}
+
+
+} //namespace services
+} //namespace ajn
diff --git a/cpp/src/interfaces/operation/RemoteControllabilityIntfControlleeImpl.h b/cpp/src/interfaces/operation/RemoteControllabilityIntfControlleeImpl.h
new file mode 100644
index 0000000..f7ba847
--- /dev/null
+++ b/cpp/src/interfaces/operation/RemoteControllabilityIntfControlleeImpl.h
@@ -0,0 +1,118 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#ifndef REMOTECONTROLLABILITYINTFCONTROLLEEIMPL_H_
+#define REMOTECONTROLLABILITYINTFCONTROLLEEIMPL_H_
+
+#include <alljoyn/Status.h>
+#include <alljoyn/BusAttachment.h>
+#include <alljoyn/InterfaceDescription.h>
+#include <alljoyn/hae/interfaces/InterfaceControllee.h>
+#include <alljoyn/hae/interfaces/InterfaceControlleeListener.h>
+#include <alljoyn/hae/interfaces/operation/RemoteControllabilityIntfControllee.h>
+
+namespace ajn {
+namespace services {
+
+class RemoteControllabilityIntfControlleeListener;
+class HaeBusObject;
+
+/**
+ * RemoteControllability Interface Controllee implementation class
+ */
+class RemoteControllabilityIntfControlleeImpl : public InterfaceControllee, public RemoteControllabilityIntfControllee {
+  public:
+    /**
+     * Create interface
+     */
+    static HaeInterface* CreateInterface(BusAttachment& busAttachment, InterfaceControlleeListener& listener, HaeBusObject& haeBusObject);
+
+    /**
+     * Constructor of RemoteControllabilityIntfControlleeImpl
+     */
+    RemoteControllabilityIntfControlleeImpl(BusAttachment& busAttachment, RemoteControllabilityIntfControlleeListener& listener, HaeBusObject& haeBusObject);
+
+    /**
+     * Destructor of RemoteControllabilityIntfControlleeImpl
+     */
+    virtual ~RemoteControllabilityIntfControlleeImpl();
+
+    /**
+     * Initialize interface
+     * @return status
+     */
+     virtual QStatus Init();
+
+    /**
+     * a callback function for getting property.
+     * @param propName   Identifies the property to get
+     * @param[out] val   Returns the property value. The type of this value is the actual value type.
+     * @return status
+     */
+    virtual QStatus OnGetProperty(const qcc::String propName, MsgArg& val);
+
+    /**
+     * a callback function for setting property.
+     * @param propName  Identifies the property to set
+     * @param val       The property value to set. The type of this value is the actual value type.
+     */
+    virtual QStatus OnSetProperty(const qcc::String propName, MsgArg& val);
+
+    /**
+     * method handler
+     * @param member    Method interface member entry.
+     * @param message   The received method call message.
+     */
+    virtual void OnMethodHandler(const InterfaceDescription::Member* member, Message& msg);
+
+    /**
+     * Get method handlers
+     * @return MethodHandlers
+     */
+    virtual const MethodHandlers& GetMethodHanders() const { return m_methodHandlers; }
+
+    /**
+     * Get bus attachment
+     * @return bus attachment
+     */
+    virtual BusAttachment& GetBusAttachment() const { return m_busAttachment; }
+
+    /**
+     * Get isControllable
+     * @return isControllable
+     */
+    virtual const bool GetIsControllable() const {return m_isControllable; }
+
+    /**
+     * Set isControllable
+     * @param[in] isControllable isControllable
+     * @return ER_OK on success
+     */
+    virtual QStatus SetIsControllable(const bool isControllable);
+
+  private:
+    RemoteControllabilityIntfControlleeImpl();
+
+    BusAttachment& m_busAttachment;
+    RemoteControllabilityIntfControlleeListener& m_interfaceListener;
+    MethodHandlers m_methodHandlers;
+    bool m_isControllable;
+};
+
+} //namespace services
+} //namespace ajn
+
+#endif /* REMOTECONTROLLABILITYINTFCONTROLLEEIMPL_H_ */
diff --git a/cpp/src/interfaces/operation/RemoteControllabilityIntfControllerImpl.cc b/cpp/src/interfaces/operation/RemoteControllabilityIntfControllerImpl.cc
new file mode 100644
index 0000000..74d44c3
--- /dev/null
+++ b/cpp/src/interfaces/operation/RemoteControllabilityIntfControllerImpl.cc
@@ -0,0 +1,106 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#include <qcc/Util.h>
+
+#include <alljoyn/hae/LogModule.h>
+#include <alljoyn/hae/HaeProxyBusObject.h>
+#include <alljoyn/hae/interfaces/operation/RemoteControllabilityIntfControllerListener.h>
+
+#include "RemoteControllabilityIntfControllerImpl.h"
+
+
+using namespace qcc;
+using namespace std;
+
+namespace ajn {
+namespace services {
+
+HaeInterface* RemoteControllabilityIntfControllerImpl::CreateInterface(BusAttachment& busAttachment, InterfaceControllerListener& listener, HaeProxyBusObject& haeProxyObject)
+{
+    return new RemoteControllabilityIntfControllerImpl(busAttachment, dynamic_cast<RemoteControllabilityIntfControllerListener&>(listener), haeProxyObject);
+}
+
+RemoteControllabilityIntfControllerImpl::RemoteControllabilityIntfControllerImpl(BusAttachment& busAttachment, RemoteControllabilityIntfControllerListener& listener, HaeProxyBusObject& haeProxyObject) :
+    InterfaceController(haeProxyObject),
+    m_busAttachment(busAttachment),
+    m_interfaceListener(listener)
+{
+}
+
+RemoteControllabilityIntfControllerImpl::~RemoteControllabilityIntfControllerImpl()
+{
+}
+
+QStatus RemoteControllabilityIntfControllerImpl::Init()
+{
+    QStatus status = HaeInterface::Init();
+    if (ER_OK != status) {
+        QCC_LogError(status, ("%s: Interface init failed.", __func__));
+        return status;
+    }
+
+    status = m_proxyObject.RegisterPropertiesChangedListener(GetInterfaceName().c_str(), NULL, 0, *this, NULL);
+    if (ER_OK != status) {
+        QCC_LogError(status, ("%s: RegisterPropertiesChangedListener failed.", __func__));
+    }
+
+    return status;
+}
+
+void RemoteControllabilityIntfControllerImpl::PropertiesChanged(ProxyBusObject& obj, const char* ifaceName, const MsgArg& changed, const MsgArg& invalidated, void* context)
+{
+    MsgArg* entries;
+    size_t numEntries;
+
+    changed.Get("a{sv}", &numEntries, &entries);
+    for (size_t i = 0; i < numEntries; ++i) {
+        const char* propName;
+        MsgArg* propValue;
+        entries[i].Get("{sv}", &propName, &propValue);
+        String propNameStr(propName);
+
+        if (!s_prop_IsControllable.compare(propNameStr)) {
+            if (propValue->typeId == ALLJOYN_BOOLEAN) {
+                uint8_t volume = propValue->v_bool;
+                m_interfaceListener.IsControllalbePropertyChanged(obj.GetPath(), volume);
+            }
+        }
+    }
+}
+QStatus RemoteControllabilityIntfControllerImpl::GetIsControllable(void* context)
+{
+    QStatus status = ER_OK;
+
+    status = m_proxyObject.GetPropertyAsync(GetInterfaceName().c_str(), s_prop_IsControllable.c_str(), this, (ProxyBusObject::Listener::GetPropertyCB)&RemoteControllabilityIntfControllerImpl::GetIsControllablePropertyCB, context);
+
+    return status;
+}
+
+void RemoteControllabilityIntfControllerImpl::GetIsControllablePropertyCB(QStatus status, ProxyBusObject* obj, const MsgArg& value, void* context)
+{
+    if (!obj) {
+        return;
+    }
+
+    bool isControllable;
+    value.Get("b", &isControllable);
+
+    m_interfaceListener.GetIsControllablePropertyCallback(status, obj->GetPath(), isControllable, context);
+}
+
+} //namespace services
+} //namespace ajn
diff --git a/cpp/src/interfaces/operation/RemoteControllabilityIntfControllerImpl.h b/cpp/src/interfaces/operation/RemoteControllabilityIntfControllerImpl.h
new file mode 100644
index 0000000..58f349b
--- /dev/null
+++ b/cpp/src/interfaces/operation/RemoteControllabilityIntfControllerImpl.h
@@ -0,0 +1,83 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#ifndef REMOTECONTROLLABILITYINTFCONTROLLERIMPL_H_
+#define REMOTECONTROLLABILITYINTFCONTROLLERIMPL_H_
+
+#include <alljoyn/Status.h>
+#include <alljoyn/BusAttachment.h>
+#include <alljoyn/hae/interfaces/InterfaceController.h>
+#include <alljoyn/hae/interfaces/operation/RemoteControllabilityIntfController.h>
+
+namespace ajn {
+namespace services {
+
+class RemoteControllabilityIntfControllerListener;
+class HaeProxyBusObject;
+
+/**
+ * RemoteControllability Interface Controller implementation class
+ */
+class RemoteControllabilityIntfControllerImpl : public InterfaceController, public RemoteControllabilityIntfController {
+  public:
+    /**
+     * Create interface
+     */
+    static HaeInterface* CreateInterface(BusAttachment& busAttachment, InterfaceControllerListener& listener, HaeProxyBusObject& haeProxyObject);
+
+    /**
+     * Constructor of RemoteControllabilityIntfControllerImpl
+     */
+    RemoteControllabilityIntfControllerImpl(BusAttachment& busAttachment, RemoteControllabilityIntfControllerListener& listener, HaeProxyBusObject& haeProxyObject);
+
+    /**
+     * Destructor of RemoteControllabilityIntfControllerImpl
+     */
+    virtual ~RemoteControllabilityIntfControllerImpl();
+
+    /**
+     * Initialize interface
+     * @return status
+     */
+    virtual QStatus Init();
+
+    /**
+     * Get bus attachment
+     * @return bus attachment
+     */
+    virtual BusAttachment& GetBusAttachment() const { return m_busAttachment; }
+
+    /**
+     * Get isControllable
+     * @param[in] context the context that is passed to the callback handler
+     * @return ER_OK on success
+     */
+    virtual QStatus GetIsControllable(void* context);
+
+
+  private:
+    RemoteControllabilityIntfControllerImpl();
+    void PropertiesChanged(ProxyBusObject& obj, const char* ifaceName, const MsgArg& changed, const MsgArg& invalidated, void* context);
+    void GetIsControllablePropertyCB(QStatus status, ProxyBusObject* obj, const MsgArg& value, void* context);
+
+    BusAttachment& m_busAttachment;
+    RemoteControllabilityIntfControllerListener& m_interfaceListener;
+};
+
+} //namespace services
+} //namespace ajn
+
+#endif /* REMOTECONTROLLABILITYINTFCONTROLLERIMPL_H_ */
diff --git a/cpp/src/interfaces/operation/SoilLevelInterface.cc b/cpp/src/interfaces/operation/SoilLevelInterface.cc
new file mode 100644
index 0000000..35a390c
--- /dev/null
+++ b/cpp/src/interfaces/operation/SoilLevelInterface.cc
@@ -0,0 +1,60 @@
+/******************************************************************************
+ * Copyright (c) 2013-2014, AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#include <alljoyn/hae/LogModule.h>
+#include <alljoyn/hae/interfaces/operation/SoilLevelInterface.h>
+
+namespace ajn {
+namespace services {
+
+const uint16_t SoilLevelInterface::s_interfaceVersion = 1;
+
+// Below none secure xml is only for test
+const qcc::String SoilLevelInterface::s_xml =
+"<node xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance' xsi:noNamespaceSchemaLocation='http://www.allseenalliance.org/schemas/introspect.xsd'>"
+"    <interface name='org.alljoyn.SmartSpaces.Operation.SoilLevel'>"
+"        <description language='en'>This interface provides a capability to set target soil level</description>"
+"        <annotation name='org.alljoyn.Bus.Secure' value='true'/>"
+"        <property name='Version' type='q' access='read'>"
+"            <description language='en'>The interface version</description>"
+"            <annotation name='org.freedesktop.DBus.Property.EmitsChangedSignal' value='true'/>"
+"        </property>"
+"        <property name='MaxLevel' type='y' access='read'>"
+"            <annotation name='org.freedesktop.DBus.Property.EmitsChangedSignal' value='true'/>"
+"            <description language='en'>Maximum value allowed for target soil level setting</description>"
+"        </property>"
+"        <property name='TargetLevel' type='y' access='readwrite'>"
+"            <annotation name='org.freedesktop.DBus.Property.EmitsChangedSignal' value='true'/>"
+"            <description language='en'>Target set-point value of soil level</description>"
+"        </property>"
+"        <property name='SelectableLevels' type='ay' access='read'>"
+"            <annotation name='org.freedesktop.DBus.Property.EmitsChangedSignal' value='true'/>"
+"            <description language='en'>List of the values of soil level which can be selected</description>"
+"        </property>"
+"    </interface>"
+"</node>"
+;
+
+const qcc::String SoilLevelInterface::s_prop_Version = "Version";
+const qcc::String SoilLevelInterface::s_prop_MaxLevel = "MaxLevel";
+const qcc::String SoilLevelInterface::s_prop_TargetLevel = "TargetLevel";
+const qcc::String SoilLevelInterface::s_prop_SelectableLevels = "SelectableLevels";
+/**
+ * TODO: initialize property, method and signal name variable
+ */
+
+} //namespace services
+} //namespace ajn
diff --git a/cpp/src/interfaces/operation/SoilLevelIntfControlleeImpl.cc b/cpp/src/interfaces/operation/SoilLevelIntfControlleeImpl.cc
new file mode 100644
index 0000000..20d95b9
--- /dev/null
+++ b/cpp/src/interfaces/operation/SoilLevelIntfControlleeImpl.cc
@@ -0,0 +1,246 @@
+/******************************************************************************
+ * Copyright (c) 2013-2014, AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#include <qcc/Util.h>
+#include <vector>
+#include <algorithm>
+#include <alljoyn/hae/LogModule.h>
+#include <alljoyn/hae/HaeBusObject.h>
+#include <alljoyn/hae/interfaces/operation/SoilLevelIntfControlleeListener.h>
+
+#include "SoilLevelIntfControlleeImpl.h"
+
+using namespace qcc;
+using namespace std;
+
+namespace ajn {
+namespace services {
+
+HaeInterface* SoilLevelIntfControlleeImpl::CreateInterface(BusAttachment& busAttachment, InterfaceControlleeListener& listener, HaeBusObject& haeBusObject)
+{
+    return new SoilLevelIntfControlleeImpl(busAttachment, dynamic_cast<SoilLevelIntfControlleeListener&>(listener), haeBusObject);
+}
+
+SoilLevelIntfControlleeImpl::SoilLevelIntfControlleeImpl(BusAttachment& busAttachment, SoilLevelIntfControlleeListener& listener, HaeBusObject& haeBusObject) :
+    InterfaceControllee(haeBusObject),
+    m_busAttachment(busAttachment),
+    m_interfaceListener(listener),
+    m_targetLevel(1),
+    m_maxLevel(6)
+{
+}
+
+SoilLevelIntfControlleeImpl::~SoilLevelIntfControlleeImpl()
+{
+}
+
+QStatus SoilLevelIntfControlleeImpl::Init()
+{
+    QStatus status = HaeInterface::Init();
+    return status;
+}
+
+QStatus SoilLevelIntfControlleeImpl::OnGetProperty(const String propName, MsgArg& val)
+{
+    QStatus status = ER_OK;
+
+    if (!(s_prop_Version.compare(propName))) {
+        val.typeId = ALLJOYN_UINT16;
+        val.v_uint16 = GetInterfaceVersion();
+    } else if (!s_prop_SelectableLevels.compare(propName)) {
+        std::vector<uint8_t> levels = GetSelectableLevels();
+
+        uint8_t vals[levels.size()];
+
+        size_t i = 0;
+
+        for(i = 0; i < levels.size(); i++)
+            vals[i] = (uint8_t)levels[i];
+
+        val.Set("ay", sizeof(vals)/ sizeof(uint8_t), vals);
+        val.Stabilize();
+    }
+    else {
+        if (s_retrievingActualPropertyValue) {
+            if(!s_prop_MaxLevel.compare(propName))
+            {
+                uint8_t maxLvl;
+                status = m_interfaceListener.OnGetMaxLevel(maxLvl);
+                if(status != ER_OK) {
+                    QCC_LogError(status, ("%s: failed to get max level prop", __func__));
+                }
+                else {
+                    //update and emit
+                    SetMaxLevel(maxLvl);
+                }
+                val.typeId = ALLJOYN_BYTE;
+                val.v_byte = maxLvl;
+            }
+            else if (!s_prop_TargetLevel.compare(propName))
+            {
+                uint8_t targLvl;
+                status = m_interfaceListener.OnGetTargetLevel(targLvl);
+                if(status != ER_OK) {
+                    QCC_LogError(status, ("%s: failed to get max level prop", __func__));
+                }
+                else {
+                    //update and emit
+                    SetTargetLevel(targLvl);
+                }
+                val.typeId = ALLJOYN_BYTE;
+                val.v_byte = targLvl;
+            }
+            else {
+                status = ER_BUS_NO_SUCH_PROPERTY;
+            }
+
+        } else {
+            if(!s_prop_MaxLevel.compare(propName)){
+                uint8_t maxLvl = GetMaxLevel();
+                val.typeId = ALLJOYN_BYTE;
+                val.v_byte = maxLvl;
+            } else if(!s_prop_TargetLevel.compare(propName)) {
+                uint8_t targLvl = GetTargetLevel();
+                val.typeId = ALLJOYN_BYTE;
+                val.v_byte = targLvl;
+            }
+            else {
+                status = ER_BUS_NO_SUCH_PROPERTY;
+            }
+        }
+    }
+    return status;
+}
+
+QStatus SoilLevelIntfControlleeImpl::OnSetProperty(const String propName, MsgArg& val)
+{
+    QStatus status = ER_OK;
+    if(!s_prop_TargetLevel.compare(propName)) {
+        if(val.typeId != ALLJOYN_BYTE){
+            status = ER_BUS_BAD_VALUE_TYPE;
+            return status;
+        } else {
+            std::vector<uint8_t>::iterator it;
+            it = std::find(m_selectableLevels.begin(), m_selectableLevels.end(), val.v_byte);
+            if(it == m_selectableLevels.end() || val.v_byte > GetMaxLevel()) {
+                status = ER_INVALID_DATA;
+                QCC_LogError(status, ("%s: property value not set ", __func__));
+            }
+            status = m_interfaceListener.OnSetTargetLevel(val.v_byte);
+            if(status != ER_OK) {
+                status = ER_INVALID_DATA;
+                QCC_LogError(status, ("%s: property value not set ", __func__));
+            } else {
+                status = SetTargetLevel(val.v_byte);
+            }
+        }
+    } else {
+        status = ER_BUS_NO_SUCH_PROPERTY;
+    }
+    return status;
+}
+
+void SoilLevelIntfControlleeImpl::OnMethodHandler(const InterfaceDescription::Member* member, Message& msg)
+{
+    QStatus status = ER_OK;
+    bool isFound = false;
+    MethodHandlers::const_iterator it;
+    for (it = m_methodHandlers.begin(); it != m_methodHandlers.end(); ++it) {
+        if (it->first == member) {
+            MessageReceiver::MethodHandler handler = it->second;
+            (this->*handler)(member, msg);
+            isFound = true;
+            break;
+        }
+    }
+
+    if (!isFound) {
+        status = ER_BUS_METHOD_CALL_ABORTED;
+        QCC_LogError(status, ("%s: could not found method handler.", __func__));
+        m_busObject.ReplyMethodCall(msg, status);
+    }
+}
+
+QStatus SoilLevelIntfControlleeImpl::SetMaxLevel(uint8_t maxLevel)
+{
+    if(maxLevel != m_maxLevel)
+    {
+        MsgArg arg;
+        arg.typeId = ALLJOYN_BYTE;
+        arg.v_byte = maxLevel;
+        m_busObject.EmitPropChanged(GetInterfaceName().c_str(), s_prop_MaxLevel.c_str(), arg, 0, ALLJOYN_FLAG_GLOBAL_BROADCAST);
+        m_maxLevel = maxLevel;
+    }
+    return ER_OK;
+}
+
+QStatus SoilLevelIntfControlleeImpl::SetTargetLevel(uint8_t targetLevel)
+{
+    std::vector<uint8_t>::iterator it;
+    it = std::find(m_selectableLevels.begin(), m_selectableLevels.end(), targetLevel);
+    if(it == m_selectableLevels.end() || targetLevel > GetMaxLevel()) {
+        return ER_INVALID_DATA;
+    }
+
+    if(targetLevel != m_targetLevel)
+    {
+        MsgArg arg;
+        arg.typeId = ALLJOYN_BYTE;
+        arg.v_byte = targetLevel;
+        m_busObject.EmitPropChanged(GetInterfaceName().c_str(), s_prop_TargetLevel.c_str(), arg, 0, ALLJOYN_FLAG_GLOBAL_BROADCAST);
+        m_targetLevel = targetLevel;
+    }
+    return ER_OK;
+}
+
+QStatus SoilLevelIntfControlleeImpl::SetSelectableLevels(const std::vector<uint8_t>& selectableLevels)
+{
+    bool isValid = false;
+    isValid = std::is_sorted(selectableLevels.begin(), selectableLevels.end());
+
+    for(size_t i=0; i < selectableLevels.size(); i ++) {
+        if (selectableLevels[i] > GetMaxLevel()) {
+            isValid = false;
+            break;
+        }
+    }
+
+    if (!isValid)
+        return ER_INVALID_DATA;
+
+    MsgArg arg;
+    uint8_t vals[selectableLevels.size()];
+
+    size_t i = 0;
+
+    for(i = 0; i < selectableLevels.size(); i++)
+        vals[i] = (uint8_t)selectableLevels[i];
+    arg.Set("ay", sizeof(vals)/sizeof(uint8_t), vals);
+    arg.Stabilize();
+
+    if(m_selectableLevels.size() > 0)
+        m_selectableLevels.clear();
+
+    for(i = 0; i < selectableLevels.size(); i ++)
+        m_selectableLevels.push_back(selectableLevels[i]);
+
+    m_busObject.EmitPropChanged(GetInterfaceName().c_str(), s_prop_SelectableLevels.c_str(), arg, 0 ,ALLJOYN_FLAG_GLOBAL_BROADCAST);
+
+    return ER_OK;
+}
+
+} //namespace services
+} //namespace ajn
diff --git a/cpp/src/interfaces/operation/SoilLevelIntfControlleeImpl.h b/cpp/src/interfaces/operation/SoilLevelIntfControlleeImpl.h
new file mode 100644
index 0000000..7fd9e5f
--- /dev/null
+++ b/cpp/src/interfaces/operation/SoilLevelIntfControlleeImpl.h
@@ -0,0 +1,146 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#ifndef SOILLEVELINTFCONTROLLEEIMPL_H_
+#define SOILLEVELINTFCONTROLLEEIMPL_H_
+
+#include <alljoyn/Status.h>
+#include <alljoyn/BusAttachment.h>
+#include <alljoyn/InterfaceDescription.h>
+#include <alljoyn/hae/interfaces/InterfaceControllee.h>
+#include <alljoyn/hae/interfaces/InterfaceControlleeListener.h>
+#include <alljoyn/hae/interfaces/operation/SoilLevelIntfControllee.h>
+
+namespace ajn {
+namespace services {
+
+class SoilLevelIntfControlleeListener;
+class HaeBusObject;
+
+/**
+ * SoilLevel Interface Controllee implementation class
+ */
+class SoilLevelIntfControlleeImpl : public InterfaceControllee, public SoilLevelIntfControllee {
+  public:
+    /**
+     * Create interface
+     */
+    static HaeInterface* CreateInterface(BusAttachment& busAttachment, InterfaceControlleeListener& listener, HaeBusObject& haeBusObject);
+
+    /**
+     * Constructor of SoilLevelIntfControlleeImpl
+     */
+    SoilLevelIntfControlleeImpl(BusAttachment& busAttachment, SoilLevelIntfControlleeListener& listener, HaeBusObject& haeBusObject);
+
+    /**
+     * Destructor of SoilLevelIntfControlleeImpl
+     */
+    virtual ~SoilLevelIntfControlleeImpl();
+
+    /**
+     * Initialize interface
+     * @return status
+     */
+     virtual QStatus Init();
+
+    /**
+     * a callback function for getting property.
+     * @param propName   Identifies the property to get
+     * @param[out] val   Returns the property value. The type of this value is the actual value type.
+     * @return status
+     */
+    virtual QStatus OnGetProperty(const qcc::String propName, MsgArg& val);
+
+    /**
+     * a callback function for setting property.
+     * @param propName  Identifies the property to set
+     * @param val       The property value to set. The type of this value is the actual value type.
+     */
+    virtual QStatus OnSetProperty(const qcc::String propName, MsgArg& val);
+
+    /**
+     * method handler
+     * @param member    Method interface member entry.
+     * @param message   The received method call message.
+     */
+    virtual void OnMethodHandler(const InterfaceDescription::Member* member, Message& msg);
+
+    /**
+     * Get method handlers
+     * @return MethodHandlers
+     */
+    virtual const MethodHandlers& GetMethodHanders() const { return m_methodHandlers; }
+
+    /**
+     * Get bus attachment
+     * @return bus attachment
+     */
+    virtual BusAttachment& GetBusAttachment() const { return m_busAttachment; }
+
+    /**
+     * Get MaxLevel
+     * @return max level
+     */
+    virtual const uint8_t GetMaxLevel() const { return m_maxLevel; }
+
+    /**
+     * Set MaxLevel
+     * @param[in] maxLevel maxLevel
+     * @return ER_OK on success
+     */
+    virtual QStatus SetMaxLevel(uint8_t maxLevel);
+
+    /**
+     * Get targetLevel
+     * @return target level
+     */
+    virtual const uint8_t GetTargetLevel () const { return m_targetLevel; }
+
+    /**
+     * Set TargetLevel
+     * @param[in] targetLevel targetLevel
+     * @return ER_OK on success
+     */
+    virtual QStatus SetTargetLevel(uint8_t targetLevel);
+
+    /**
+     * Get SelectableLevels
+     * @return the list of selectable levels
+     */
+    virtual const std::vector<uint8_t>& GetSelectableLevels() const { return m_selectableLevels; }
+
+    /**
+     * Set SelectableLevels
+     * @param[in] selectableLevels the list of selectable levels
+     * @return ER_OK on success
+     */
+    virtual QStatus SetSelectableLevels(const std::vector<uint8_t>& selectableLevels);
+
+  private:
+    SoilLevelIntfControlleeImpl();
+
+    BusAttachment& m_busAttachment;
+    SoilLevelIntfControlleeListener& m_interfaceListener;
+    MethodHandlers m_methodHandlers;
+    uint8_t m_targetLevel;
+    uint8_t m_maxLevel;
+    std::vector<uint8_t> m_selectableLevels;
+};
+
+} //namespace services
+} //namespace ajn
+
+#endif /* SOILLEVELINTFCONTROLLEEIMPL_H_ */
diff --git a/cpp/src/interfaces/operation/SoilLevelIntfControllerImpl.cc b/cpp/src/interfaces/operation/SoilLevelIntfControllerImpl.cc
new file mode 100644
index 0000000..b27737d
--- /dev/null
+++ b/cpp/src/interfaces/operation/SoilLevelIntfControllerImpl.cc
@@ -0,0 +1,208 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#include <qcc/Util.h>
+#include <vector>
+#include <alljoyn/hae/LogModule.h>
+#include <alljoyn/hae/HaeProxyBusObject.h>
+#include <alljoyn/hae/interfaces/operation/SoilLevelIntfControllerListener.h>
+
+#include "SoilLevelIntfControllerImpl.h"
+
+using namespace qcc;
+using namespace std;
+
+namespace ajn {
+namespace services {
+
+HaeInterface* SoilLevelIntfControllerImpl::CreateInterface(BusAttachment& busAttachment, InterfaceControllerListener& listener, HaeProxyBusObject& haeProxyObject)
+{
+    return new SoilLevelIntfControllerImpl(busAttachment, dynamic_cast<SoilLevelIntfControllerListener&>(listener), haeProxyObject);
+}
+
+SoilLevelIntfControllerImpl::SoilLevelIntfControllerImpl(BusAttachment& busAttachment, SoilLevelIntfControllerListener& listener, HaeProxyBusObject& haeProxyObject) :
+    InterfaceController(haeProxyObject),
+    m_busAttachment(busAttachment),
+    m_interfaceListener(listener)
+{
+}
+
+SoilLevelIntfControllerImpl::~SoilLevelIntfControllerImpl()
+{
+}
+
+QStatus SoilLevelIntfControllerImpl::Init()
+{
+    QStatus status = HaeInterface::Init();
+    if (ER_OK != status) {
+        QCC_LogError(status, ("%s: Interface init failed.", __func__));
+        return status;
+    }
+
+    status = m_proxyObject.RegisterPropertiesChangedListener(GetInterfaceName().c_str(), NULL, 0, *this, NULL);
+    if (ER_OK != status) {
+        QCC_LogError(status, ("%s: RegisterPropertiesChangedListener failed.", __func__));
+    }
+
+    /**
+     * TODO: Register signal handler
+     */
+
+    return status;
+}
+
+void SoilLevelIntfControllerImpl::PropertiesChanged(ProxyBusObject& obj, const char* ifaceName, const MsgArg& changed, const MsgArg& invalidated, void* context)
+{
+    MsgArg* entries;
+    size_t numEntries;
+
+    changed.Get("a{sv}", &numEntries, &entries);
+    for (size_t i = 0; i < numEntries; ++i) {
+        const char* propName;
+        MsgArg* propValue;
+        entries[i].Get("{sv}", &propName, &propValue);
+        String propNameStr(propName);
+
+        if (!s_prop_MaxLevel.compare(propNameStr)) {
+            if (propValue->typeId == ALLJOYN_BYTE) {
+                uint8_t level = propValue->v_byte;
+                m_interfaceListener.MaxLevelPropertyChanged(obj.GetPath(), level);
+            }
+        } else if (!s_prop_TargetLevel.compare(propNameStr)){
+            if(propValue->typeId == ALLJOYN_BYTE) {
+                uint8_t level = propValue->v_byte;
+                m_interfaceListener.TargetLevelPropertyChanged(obj.GetPath(), level);
+            }
+        } else if(!s_prop_SelectableLevels.compare(propNameStr)) {
+            uint8_t *vals;
+            size_t numVals;
+            std::vector<uint8_t> levels;
+            propValue->Get("ay", &numVals, &vals);
+
+            cout << "Selectable Levels: " << endl;
+            for (size_t i = 0; i < numVals; ++i) {
+                levels.push_back(vals[i]);
+            }
+            m_interfaceListener.SelectableLevelsPropertyChanged(obj.GetPath(), levels);
+        }
+    }
+}
+
+QStatus SoilLevelIntfControllerImpl::GetMaxLevel(void* context)
+{
+    QStatus status = ER_OK;
+
+    status = m_proxyObject.GetPropertyAsync(GetInterfaceName().c_str(), s_prop_MaxLevel.c_str(), this, (ProxyBusObject::Listener::GetPropertyCB)&SoilLevelIntfControllerImpl::GetMaxLevelPropertyCB,context);
+
+    return status;
+}
+
+QStatus SoilLevelIntfControllerImpl::GetTargetLevel(void* context)
+{
+    QStatus status = ER_OK;
+
+    status = m_proxyObject.GetPropertyAsync(GetInterfaceName().c_str(), s_prop_TargetLevel.c_str(), this, (ProxyBusObject::Listener::GetPropertyCB)&SoilLevelIntfControllerImpl::GetTargetLevelPropertyCB,context);
+
+    return status;
+}
+QStatus SoilLevelIntfControllerImpl::SetTargetLevel(const uint8_t targetLevel, void* context)
+{
+    QStatus status = ER_OK;
+
+    MsgArg arg;
+    arg.Set("y", targetLevel);
+
+    status = m_proxyObject.SetPropertyAsync(GetInterfaceName().c_str(), s_prop_TargetLevel.c_str(), arg, this, (ProxyBusObject::Listener::SetPropertyCB)&SoilLevelIntfControllerImpl::SetTargetLevelPropertyCB,context);
+
+    return status;
+}
+QStatus SoilLevelIntfControllerImpl::GetSelectableLevels(void* context)
+{
+    QStatus status = ER_OK;
+
+    status = m_proxyObject.GetPropertyAsync(GetInterfaceName().c_str(), s_prop_SelectableLevels.c_str(), this, (ProxyBusObject::Listener::GetPropertyCB)&SoilLevelIntfControllerImpl::GetSelectableLevelsPropertyCB,context);
+
+    return status;
+}
+/**
+ * TODO: define functions to request the set/get properties
+ * GetProperty function of read-only property must not be defined in the controller side.
+ */
+
+/*
+ * TODO: define functions to request the method call
+ */
+
+void SoilLevelIntfControllerImpl::GetMaxLevelPropertyCB(QStatus status, ProxyBusObject* obj, const MsgArg& value, void* context)
+{
+    if(!obj) {
+        return;
+    }
+
+    uint8_t maxLevel;
+    cout << "# SoilLevelIntfControllerImpl::GetMaxLevelPropertyCB" << endl;
+    value.Get("y", &maxLevel);
+
+    m_interfaceListener.GetMaxLevelPropertyCallback(status,obj->GetPath(),maxLevel,context);
+}
+void SoilLevelIntfControllerImpl::GetTargetLevelPropertyCB(QStatus status, ProxyBusObject* obj, const MsgArg& value, void* context)
+{
+    if(!obj) {
+        return;
+    }
+
+    uint8_t targetLevel;
+    value.Get("y", &targetLevel);
+
+    m_interfaceListener.GetTargetLevelPropertyCallback(status,obj->GetPath(),targetLevel,context);
+}
+void SoilLevelIntfControllerImpl::SetTargetLevelPropertyCB(QStatus status, ProxyBusObject* obj, void* context)
+{
+    if(!obj){
+        return;
+    }
+    m_interfaceListener.SetTargetLevelPropertyCallback(status,obj->GetPath(),context);
+}
+void SoilLevelIntfControllerImpl::GetSelectableLevelsPropertyCB(QStatus status, ProxyBusObject* obj, const MsgArg& value, void* context)
+{
+
+    if(!obj){
+        return;
+    }
+
+    uint8_t *vals;
+    size_t numVals;
+    std::vector<uint8_t> levels;
+    value.Get("ay", &numVals, &vals);
+
+    cout << "Selectable Levels: " << endl;
+    for (size_t i = 0; i < numVals; ++i) {
+        levels.push_back(vals[i]);
+    }
+
+    m_interfaceListener.GetSelectableLevelsPropertyCallback(status,obj->GetPath(), levels, context);
+}
+
+/*
+ * TODO: define method reply handler
+ */
+
+/*
+ * TODO: define signal handler
+ */
+
+} //namespace services
+} //namespace ajn
diff --git a/cpp/src/interfaces/operation/SoilLevelIntfControllerImpl.h b/cpp/src/interfaces/operation/SoilLevelIntfControllerImpl.h
new file mode 100644
index 0000000..708331b
--- /dev/null
+++ b/cpp/src/interfaces/operation/SoilLevelIntfControllerImpl.h
@@ -0,0 +1,118 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#ifndef SOILLEVELINTFCONTROLLERIMPL_H_
+#define SOILLEVELINTFCONTROLLERIMPL_H_
+
+#include <alljoyn/Status.h>
+#include <alljoyn/BusAttachment.h>
+#include <alljoyn/hae/interfaces/InterfaceController.h>
+#include <alljoyn/hae/interfaces/operation/SoilLevelIntfController.h>
+
+namespace ajn {
+namespace services {
+
+class SoilLevelIntfControllerListener;
+class HaeProxyBusObject;
+
+/**
+ * SoilLevel Interface Controller implementation class
+ */
+class SoilLevelIntfControllerImpl : public InterfaceController, public SoilLevelIntfController {
+  public:
+    /**
+     * Create interface
+     */
+    static HaeInterface* CreateInterface(BusAttachment& busAttachment, InterfaceControllerListener& listener, HaeProxyBusObject& haeProxyObject);
+
+    /**
+     * Constructor of SoilLevelIntfControllerImpl
+     */
+    SoilLevelIntfControllerImpl(BusAttachment& busAttachment, SoilLevelIntfControllerListener& listener, HaeProxyBusObject& haeProxyObject);
+
+    /**
+     * Destructor of SoilLevelIntfControllerImpl
+     */
+    virtual ~SoilLevelIntfControllerImpl();
+
+    /**
+     * Initialize interface
+     * @return status
+     */
+    virtual QStatus Init();
+
+    /**
+     * Get bus attachment
+     * @return bus attachment
+     */
+    virtual BusAttachment& GetBusAttachment() const { return m_busAttachment; }
+
+    /**
+     * Get MaxLevel
+     * @param[in] context the context that is passed to the callback handler
+     * @return ER_OK on success
+     */
+    virtual QStatus GetMaxLevel(void* context = NULL);
+
+    /**
+     * Get TargetLevel
+     * @param[in] context the context that is passed to the callback handler
+     * @return ER_OK on success
+     */
+    virtual QStatus GetTargetLevel(void* context = NULL);
+
+    /**
+     * Set TargetLevel
+     * @param[in] targetLevel targetLevel
+     * @param[in] context the context that is passed to the callback handler
+     * @return ER_OK on success
+     */
+    virtual QStatus SetTargetLevel(const uint8_t targetLevel, void* context = NULL);
+
+    /**
+     * Get SelectableLevels
+     * @param[in] context the context that is passed to the callback handler
+     * @return ER_OK on success
+     */
+    virtual QStatus GetSelectableLevels(void* context = NULL);
+
+  private:
+    SoilLevelIntfControllerImpl();
+
+    void PropertiesChanged(ProxyBusObject& obj, const char* ifaceName, const MsgArg& changed, const MsgArg& invalidated, void* context);
+
+    void GetMaxLevelPropertyCB(QStatus status, ProxyBusObject* obj, const MsgArg& value, void* context);
+    void GetTargetLevelPropertyCB(QStatus status, ProxyBusObject* obj, const MsgArg& value, void* context);
+    void SetTargetLevelPropertyCB(QStatus status, ProxyBusObject* obj, void* context);
+    void GetSelectableLevelsPropertyCB(QStatus status, ProxyBusObject* obj, const MsgArg& value, void* context);
+
+
+    /*
+     * TODO: define method reply handler
+     */
+
+    /*
+     * TODO: define signal handler
+     */
+
+    BusAttachment& m_busAttachment;
+    SoilLevelIntfControllerListener& m_interfaceListener;
+};
+
+} //namespace services
+} //namespace ajn
+
+#endif /* SOILLEVELINTFCONTROLLERIMPL_H_ */
diff --git a/cpp/src/interfaces/operation/SpinSpeedLevelInterface.cc b/cpp/src/interfaces/operation/SpinSpeedLevelInterface.cc
new file mode 100644
index 0000000..9d37647
--- /dev/null
+++ b/cpp/src/interfaces/operation/SpinSpeedLevelInterface.cc
@@ -0,0 +1,56 @@
+/******************************************************************************
+ * Copyright (c) 2013-2014, AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#include <alljoyn/hae/LogModule.h>
+#include <alljoyn/hae/interfaces/operation/SpinSpeedLevelInterface.h>
+
+namespace ajn {
+namespace services {
+
+const uint16_t SpinSpeedLevelInterface::s_interfaceVersion = 1;
+
+// Below none secure xml is only for test
+const qcc::String SpinSpeedLevelInterface::s_xml =
+"<node xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance' xsi:noNamespaceSchemaLocation='http://www.allseenalliance.org/schemas/introspect.xsd'>"
+"    <interface name='org.alljoyn.SmartSpaces.Operation.SpinSpeedLevel'>"
+"        <description language='en'>This interface provides a capability to set the spin speed level</description>"
+"        <annotation name='org.alljoyn.Bus.Secure' value='true'/>"
+"        <property name='Version' type='q' access='read'>"
+"            <description language='en'>The interface version</description>"
+"            <annotation name='org.freedesktop.DBus.Property.EmitsChangedSignal' value='true'/>"
+"        </property>"
+"        <property name='MaxLevel' type='y' access='read'>"
+"            <annotation name='org.freedesktop.DBus.Property.EmitsChangedSignal' value='false'/>"
+"            <description language='en'>Maximum value allowed for the spin speed level setting</description>"
+"        </property>"
+"        <property name='TargetLevel' type='y' access='readwrite'>"
+"            <annotation name='org.freedesktop.DBus.Property.EmitsChangedSignal' value='true'/>"
+"            <description language='en'>Target set-point value of spin speed level</description>"
+"        </property>"
+"        <property name='SelectableLevels' type='ay' access='read'>"
+"            <annotation name='org.freedesktop.DBus.Property.EmitsChangedSignal' value='true'/>"
+"            <description language='en'>List of the values of spin speed level which can be selected</description>"
+"        </property>"
+"    </interface>"
+"</node>"
+;
+
+const qcc::String SpinSpeedLevelInterface::s_prop_Version = "Version";
+const qcc::String SpinSpeedLevelInterface::s_prop_MaxLevel = "MaxLevel";
+const qcc::String SpinSpeedLevelInterface::s_prop_TargetLevel = "TargetLevel";
+const qcc::String SpinSpeedLevelInterface::s_prop_SelectableLevels = "SelectableLevels";
+} //namespace services
+} //namespace ajn
diff --git a/cpp/src/interfaces/operation/SpinSpeedLevelIntfControlleeImpl.cc b/cpp/src/interfaces/operation/SpinSpeedLevelIntfControlleeImpl.cc
new file mode 100644
index 0000000..c87ac14
--- /dev/null
+++ b/cpp/src/interfaces/operation/SpinSpeedLevelIntfControlleeImpl.cc
@@ -0,0 +1,250 @@
+/******************************************************************************
+ * Copyright (c) 2013-2014, AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#include <qcc/Util.h>
+#include <algorithm>
+#include <alljoyn/hae/LogModule.h>
+#include <alljoyn/hae/HaeBusObject.h>
+#include <alljoyn/hae/interfaces/operation/SpinSpeedLevelIntfControlleeListener.h>
+
+#include "SpinSpeedLevelIntfControlleeImpl.h"
+
+using namespace qcc;
+using namespace std;
+
+namespace ajn {
+namespace services {
+
+HaeInterface* SpinSpeedLevelIntfControlleeImpl::CreateInterface(BusAttachment& busAttachment, InterfaceControlleeListener& listener, HaeBusObject& haeBusObject)
+{
+    return new SpinSpeedLevelIntfControlleeImpl(busAttachment, dynamic_cast<SpinSpeedLevelIntfControlleeListener&>(listener), haeBusObject);
+}
+
+SpinSpeedLevelIntfControlleeImpl::SpinSpeedLevelIntfControlleeImpl(BusAttachment& busAttachment, SpinSpeedLevelIntfControlleeListener& listener, HaeBusObject& haeBusObject) :
+    InterfaceControllee(haeBusObject),
+    m_busAttachment(busAttachment),
+    m_interfaceListener(listener),
+    m_targetLevel(2),
+    m_maxLevel(5)
+{
+}
+
+SpinSpeedLevelIntfControlleeImpl::~SpinSpeedLevelIntfControlleeImpl()
+{
+}
+
+QStatus SpinSpeedLevelIntfControlleeImpl::Init()
+{
+    QStatus status = HaeInterface::Init();
+
+
+    return status;
+}
+
+QStatus SpinSpeedLevelIntfControlleeImpl::OnGetProperty(const String propName, MsgArg& val)
+{
+    QStatus status = ER_OK;
+    if (!(s_prop_Version.compare(propName))) {
+        val.typeId = ALLJOYN_UINT16;
+        val.v_uint16 = GetInterfaceVersion();
+    } else if (!s_prop_SelectableLevels.compare(propName)) {
+        std::vector<uint8_t> levels = GetSelectableLevels();
+
+        uint8_t vals[levels.size()];
+
+        size_t i = 0;
+
+        for(i = 0; i < levels.size(); i++)
+        {
+            vals[i] = (uint8_t)levels[i];
+        }
+        val.Set("ay", sizeof(vals)/ sizeof(uint8_t), vals);
+        val.Stabilize();
+    }
+    else {
+        if (s_retrievingActualPropertyValue) {
+            if(!s_prop_MaxLevel.compare(propName))
+            {
+                uint8_t maxLvl;
+                status = m_interfaceListener.OnGetMaxLevel(maxLvl);
+                if(status != ER_OK) {
+                    QCC_LogError(status, ("%s: failed to get max level prop", __func__));
+                }
+                else {
+                    //update and emit
+                    SetMaxLevel(maxLvl);
+                }
+                val.typeId = ALLJOYN_BYTE;
+                val.v_byte = maxLvl;
+            }
+            else if (!s_prop_TargetLevel.compare(propName))
+            {
+                uint8_t targLvl;
+                status = m_interfaceListener.OnGetTargetLevel(targLvl);
+                if(status != ER_OK) {
+                    QCC_LogError(status, ("%s: failed to get max level prop", __func__));
+                }
+                else {
+                    //update and emit
+                    SetTargetLevel(targLvl);
+                }
+                val.typeId = ALLJOYN_BYTE;
+                val.v_byte = targLvl;
+            }
+            else {
+                status = ER_BUS_NO_SUCH_PROPERTY;
+            }
+
+        } else {
+            if(!s_prop_MaxLevel.compare(propName)){
+                uint8_t maxLvl = GetMaxLevel();
+                val.typeId = ALLJOYN_BYTE;
+                val.v_byte = maxLvl;
+            } else if(!s_prop_TargetLevel.compare(propName)) {
+                uint8_t targLvl = GetTargetLevel();
+                val.typeId = ALLJOYN_BYTE;
+                val.v_byte = targLvl;
+            }
+            else {
+                status = ER_BUS_NO_SUCH_PROPERTY;
+            }
+       }
+    }
+    return status;
+}
+
+QStatus SpinSpeedLevelIntfControlleeImpl::OnSetProperty(const String propName, MsgArg& val)
+{
+    QStatus status = ER_OK;
+
+    if(!s_prop_TargetLevel.compare(propName)) {
+        if(val.typeId != ALLJOYN_BYTE){
+            status = ER_BUS_BAD_VALUE_TYPE;
+            return status;
+        } else {
+            std::vector<uint8_t>::iterator it;
+            it = std::find(m_selectableLevels.begin(), m_selectableLevels.end(), val.v_byte);
+            if(it == m_selectableLevels.end() || val.v_byte > GetMaxLevel()) {
+                status = ER_INVALID_DATA;
+                QCC_LogError(status, ("%s: property value not set ", __func__));
+            }
+            status = m_interfaceListener.OnSetTargetLevel(val.v_byte);
+            if(status != ER_OK) {
+                status = ER_INVALID_DATA;
+                QCC_LogError(status, ("%s: property value not set ", __func__));
+            } else {
+                status = SetTargetLevel(val.v_byte);
+            }
+        }
+    } else {
+        status = ER_BUS_NO_SUCH_PROPERTY;
+    }
+
+
+    return status;
+}
+
+void SpinSpeedLevelIntfControlleeImpl::OnMethodHandler(const InterfaceDescription::Member* member, Message& msg)
+{
+    QStatus status = ER_OK;
+    bool isFound = false;
+    MethodHandlers::const_iterator it;
+    for (it = m_methodHandlers.begin(); it != m_methodHandlers.end(); ++it) {
+        if (it->first == member) {
+            MessageReceiver::MethodHandler handler = it->second;
+            (this->*handler)(member, msg);
+            isFound = true;
+            break;
+        }
+    }
+
+    if (!isFound) {
+        status = ER_BUS_METHOD_CALL_ABORTED;
+        QCC_LogError(status, ("%s: could not found method handler.", __func__));
+        m_busObject.ReplyMethodCall(msg, status);
+    }
+}
+QStatus SpinSpeedLevelIntfControlleeImpl::SetMaxLevel(uint8_t maxLevel)
+{
+    if(maxLevel != m_maxLevel)
+    {
+        MsgArg arg;
+        arg.typeId = ALLJOYN_BYTE;
+        arg.v_byte = maxLevel;
+        m_busObject.EmitPropChanged(GetInterfaceName().c_str(), s_prop_MaxLevel.c_str(), arg, 0, ALLJOYN_FLAG_GLOBAL_BROADCAST);
+        m_maxLevel = maxLevel;
+    }
+    return ER_OK;
+}
+
+QStatus SpinSpeedLevelIntfControlleeImpl::SetTargetLevel(uint8_t targetLevel)
+{
+    std::vector<uint8_t>::iterator it;
+    it = std::find(m_selectableLevels.begin(), m_selectableLevels.end(), targetLevel);
+    if(it == m_selectableLevels.end() || targetLevel > GetMaxLevel()) {
+        return ER_INVALID_DATA;
+    }
+
+    if(targetLevel != m_targetLevel)
+    {
+        MsgArg arg;
+        arg.typeId = ALLJOYN_BYTE;
+        arg.v_byte = targetLevel;
+        m_busObject.EmitPropChanged(GetInterfaceName().c_str(), s_prop_TargetLevel.c_str(), arg, 0, ALLJOYN_FLAG_GLOBAL_BROADCAST);
+        m_targetLevel = targetLevel;
+    }
+    return ER_OK;
+}
+
+QStatus SpinSpeedLevelIntfControlleeImpl::SetSelectableLevels(const std::vector<uint8_t>& selectableLevels)
+{
+
+    bool isValid = false;
+    isValid = std::is_sorted(selectableLevels.begin(), selectableLevels.end());
+
+    for(size_t i=0; i < selectableLevels.size(); i ++) {
+        if (selectableLevels[i] > GetMaxLevel()) {
+            isValid = false;
+            break;
+        }
+    }
+
+    if (!isValid)
+        return ER_INVALID_DATA;
+
+    MsgArg arg;
+    uint8_t vals[selectableLevels.size()];
+
+    for(size_t i = 0; i < selectableLevels.size(); i++)
+    {
+        vals[i] = (uint8_t)selectableLevels[i];
+    }
+    arg.Set("ay", sizeof(vals)/sizeof(uint8_t), vals);
+    arg.Stabilize();
+
+    if(m_selectableLevels.size() > 0)
+        m_selectableLevels.clear();
+
+    for(size_t i = 0; i < selectableLevels.size(); i ++)
+        m_selectableLevels.push_back(selectableLevels[i]);
+
+    m_busObject.EmitPropChanged(GetInterfaceName().c_str(), s_prop_SelectableLevels.c_str(), arg, 0 ,ALLJOYN_FLAG_GLOBAL_BROADCAST);
+
+    return ER_OK;
+}
+
+} //namespace services
+} //namespace ajn
diff --git a/cpp/src/interfaces/operation/SpinSpeedLevelIntfControlleeImpl.h b/cpp/src/interfaces/operation/SpinSpeedLevelIntfControlleeImpl.h
new file mode 100644
index 0000000..a402d67
--- /dev/null
+++ b/cpp/src/interfaces/operation/SpinSpeedLevelIntfControlleeImpl.h
@@ -0,0 +1,147 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#ifndef SPINSPEEDLEVELINTFCONTROLLEEIMPL_H_
+#define SPINSPEEDLEVELINTFCONTROLLEEIMPL_H_
+
+#include <alljoyn/Status.h>
+#include <alljoyn/BusAttachment.h>
+#include <alljoyn/InterfaceDescription.h>
+#include <alljoyn/hae/interfaces/InterfaceControllee.h>
+#include <alljoyn/hae/interfaces/InterfaceControlleeListener.h>
+#include <alljoyn/hae/interfaces/operation/SpinSpeedLevelIntfControllee.h>
+
+namespace ajn {
+namespace services {
+
+class SpinSpeedLevelIntfControlleeListener;
+class HaeBusObject;
+
+/**
+ * SpinSpeedLevel Interface Controllee implementation class
+ */
+class SpinSpeedLevelIntfControlleeImpl : public InterfaceControllee, public SpinSpeedLevelIntfControllee {
+  public:
+    /**
+     * Create interface
+     */
+    static HaeInterface* CreateInterface(BusAttachment& busAttachment, InterfaceControlleeListener& listener, HaeBusObject& haeBusObject);
+
+    /**
+     * Constructor of SpinSpeedLevelIntfControlleeImpl
+     */
+    SpinSpeedLevelIntfControlleeImpl(BusAttachment& busAttachment, SpinSpeedLevelIntfControlleeListener& listener, HaeBusObject& haeBusObject);
+
+    /**
+     * Destructor of SpinSpeedLevelIntfControlleeImpl
+     */
+    virtual ~SpinSpeedLevelIntfControlleeImpl();
+
+    /**
+     * Initialize interface
+     * @return status
+     */
+     virtual QStatus Init();
+
+    /**
+     * a callback function for getting property.
+     * @param propName   Identifies the property to get
+     * @param[out] val   Returns the property value. The type of this value is the actual value type.
+     * @return status
+     */
+    virtual QStatus OnGetProperty(const qcc::String propName, MsgArg& val);
+
+    /**
+     * a callback function for setting property.
+     * @param propName  Identifies the property to set
+     * @param val       The property value to set. The type of this value is the actual value type.
+     */
+    virtual QStatus OnSetProperty(const qcc::String propName, MsgArg& val);
+
+    /**
+     * method handler
+     * @param member    Method interface member entry.
+     * @param message   The received method call message.
+     */
+    virtual void OnMethodHandler(const InterfaceDescription::Member* member, Message& msg);
+
+    /**
+     * Get method handlers
+     * @return MethodHandlers
+     */
+    virtual const MethodHandlers& GetMethodHanders() const { return m_methodHandlers; }
+
+    /**
+     * Get bus attachment
+     * @return bus attachment
+     */
+    virtual BusAttachment& GetBusAttachment() const { return m_busAttachment; }
+
+    /**
+     * Get MaxLevel
+     * @return max level
+     */
+    virtual const uint8_t GetMaxLevel() const { return m_maxLevel; }
+
+    /**
+     * Set MaxLevel
+     * @param[in] maxLevel maxLevel
+     * @return ER_OK on success
+     */
+    virtual QStatus SetMaxLevel(uint8_t maxLevel);
+
+    /**
+     * Get targetLevel
+     * @return target level
+     */
+    virtual const uint8_t GetTargetLevel () const { return m_targetLevel; }
+
+    /**
+     * Set TargetLevel
+     * @param[in] targetLevel targetLevel
+     * @return ER_OK on success
+     */
+    virtual QStatus SetTargetLevel(uint8_t targetLevel);
+
+    /**
+     * Get SelectableLevels
+     * @return the list of selectable levels
+     */
+    virtual const std::vector<uint8_t>& GetSelectableLevels() const { return m_selectableLevels; }
+
+    /**
+     * Set SelectableLevels
+     * @param[in] selectableLevels the list of selectable levels
+     * @return ER_OK on success
+     */
+    virtual QStatus SetSelectableLevels(const std::vector<uint8_t>& selectableLevels);
+
+  private:
+    SpinSpeedLevelIntfControlleeImpl();
+
+    BusAttachment& m_busAttachment;
+    SpinSpeedLevelIntfControlleeListener& m_interfaceListener;
+    MethodHandlers m_methodHandlers;
+    uint8_t m_targetLevel;
+    uint8_t m_maxLevel;
+    std::vector<uint8_t> m_selectableLevels;
+
+};
+
+} //namespace services
+} //namespace ajn
+
+#endif /* SPINSPEEDLEVELINTFCONTROLLEEIMPL_H_ */
diff --git a/cpp/src/interfaces/operation/SpinSpeedLevelIntfControllerImpl.cc b/cpp/src/interfaces/operation/SpinSpeedLevelIntfControllerImpl.cc
new file mode 100644
index 0000000..a0157bc
--- /dev/null
+++ b/cpp/src/interfaces/operation/SpinSpeedLevelIntfControllerImpl.cc
@@ -0,0 +1,188 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#include <qcc/Util.h>
+
+#include <alljoyn/hae/LogModule.h>
+#include <alljoyn/hae/HaeProxyBusObject.h>
+#include <alljoyn/hae/interfaces/operation/SpinSpeedLevelIntfControllerListener.h>
+
+#include "SpinSpeedLevelIntfControllerImpl.h"
+
+using namespace qcc;
+using namespace std;
+
+namespace ajn {
+namespace services {
+
+HaeInterface* SpinSpeedLevelIntfControllerImpl::CreateInterface(BusAttachment& busAttachment, InterfaceControllerListener& listener, HaeProxyBusObject& haeProxyObject)
+{
+    return new SpinSpeedLevelIntfControllerImpl(busAttachment, dynamic_cast<SpinSpeedLevelIntfControllerListener&>(listener), haeProxyObject);
+}
+
+SpinSpeedLevelIntfControllerImpl::SpinSpeedLevelIntfControllerImpl(BusAttachment& busAttachment, SpinSpeedLevelIntfControllerListener& listener, HaeProxyBusObject& haeProxyObject) :
+    InterfaceController(haeProxyObject),
+    m_busAttachment(busAttachment),
+    m_interfaceListener(listener)
+{
+}
+
+SpinSpeedLevelIntfControllerImpl::~SpinSpeedLevelIntfControllerImpl()
+{
+}
+
+QStatus SpinSpeedLevelIntfControllerImpl::Init()
+{
+    QStatus status = HaeInterface::Init();
+    if (ER_OK != status) {
+        QCC_LogError(status, ("%s: Interface init failed.", __func__));
+        return status;
+    }
+
+    status = m_proxyObject.RegisterPropertiesChangedListener(GetInterfaceName().c_str(), NULL, 0, *this, NULL);
+    if (ER_OK != status) {
+        QCC_LogError(status, ("%s: RegisterPropertiesChangedListener failed.", __func__));
+    }
+
+    return status;
+}
+
+void SpinSpeedLevelIntfControllerImpl::PropertiesChanged(ProxyBusObject& obj, const char* ifaceName, const MsgArg& changed, const MsgArg& invalidated, void* context)
+{
+    MsgArg* entries;
+    size_t numEntries;
+
+    changed.Get("a{sv}", &numEntries, &entries);
+    for (size_t i = 0; i < numEntries; ++i) {
+        const char* propName;
+        MsgArg* propValue;
+        entries[i].Get("{sv}", &propName, &propValue);
+        String propNameStr(propName);
+
+        if (!s_prop_MaxLevel.compare(propNameStr)) {
+            if (propValue->typeId == ALLJOYN_BYTE) {
+                uint8_t level = propValue->v_byte;
+                m_interfaceListener.MaxLevelPropertyChanged(obj.GetPath(), level);
+            }
+        } else if (!s_prop_TargetLevel.compare(propNameStr)){
+            if(propValue->typeId == ALLJOYN_BYTE) {
+                uint8_t level = propValue->v_byte;
+                m_interfaceListener.TargetLevelPropertyChanged(obj.GetPath(), level);
+            }
+        } else if(!s_prop_SelectableLevels.compare(propNameStr)) {
+            uint8_t *vals;
+            size_t numVals;
+            std::vector<uint8_t> levels;
+            propValue->Get("ay", &numVals, &vals);
+
+            cout << "Selectable Levels: " << endl;
+            for (size_t i = 0; i < numVals; ++i) {
+                levels.push_back(vals[i]);
+            }
+            m_interfaceListener.SelectableLevelsPropertyChanged(obj.GetPath(), levels);
+        }
+    }
+}
+QStatus SpinSpeedLevelIntfControllerImpl::GetMaxLevel(void* context)
+{
+    QStatus status = ER_OK;
+
+    status = m_proxyObject.GetPropertyAsync(GetInterfaceName().c_str(), s_prop_MaxLevel.c_str(), this, (ProxyBusObject::Listener::GetPropertyCB)&SpinSpeedLevelIntfControllerImpl::GetMaxLevelPropertyCB,context);
+
+    return status;
+}
+
+QStatus SpinSpeedLevelIntfControllerImpl::GetTargetLevel(void* context)
+{
+    QStatus status = ER_OK;
+
+    status = m_proxyObject.GetPropertyAsync(GetInterfaceName().c_str(), s_prop_TargetLevel.c_str(), this, (ProxyBusObject::Listener::GetPropertyCB)&SpinSpeedLevelIntfControllerImpl::GetTargetLevelPropertyCB,context);
+
+    return status;
+}
+QStatus SpinSpeedLevelIntfControllerImpl::SetTargetLevel(const uint8_t targetLevel, void* context)
+{
+    QStatus status = ER_OK;
+
+    MsgArg arg;
+    arg.Set("y", targetLevel);
+
+    status = m_proxyObject.SetPropertyAsync(GetInterfaceName().c_str(), s_prop_TargetLevel.c_str(), arg, this, (ProxyBusObject::Listener::SetPropertyCB)&SpinSpeedLevelIntfControllerImpl::SetTargetLevelPropertyCB,context);
+
+    return status;
+}
+QStatus SpinSpeedLevelIntfControllerImpl::GetSelectableLevels(void* context)
+{
+    QStatus status = ER_OK;
+
+    status = m_proxyObject.GetPropertyAsync(GetInterfaceName().c_str(), s_prop_SelectableLevels.c_str(), this, (ProxyBusObject::Listener::GetPropertyCB)&SpinSpeedLevelIntfControllerImpl::GetSelectableLevelsPropertyCB,context);
+
+    return status;
+}
+
+void SpinSpeedLevelIntfControllerImpl::GetMaxLevelPropertyCB(QStatus status, ProxyBusObject* obj, const MsgArg& value, void* context)
+{
+    if(!obj) {
+        return;
+    }
+
+    uint8_t maxLevel;
+    cout << "# SoilLevelIntfControllerImpl::GetMaxLevelPropertyCB" << endl;
+    value.Get("y", &maxLevel);
+
+    m_interfaceListener.GetMaxLevelPropertyCallback(status,obj->GetPath(),maxLevel,context);
+}
+void SpinSpeedLevelIntfControllerImpl::GetTargetLevelPropertyCB(QStatus status, ProxyBusObject* obj, const MsgArg& value, void* context)
+{
+    if(!obj) {
+        return;
+    }
+
+    uint8_t targetLevel;
+    value.Get("y", &targetLevel);
+
+    m_interfaceListener.GetTargetLevelPropertyCallback(status,obj->GetPath(),targetLevel,context);
+}
+void SpinSpeedLevelIntfControllerImpl::SetTargetLevelPropertyCB(QStatus status, ProxyBusObject* obj, void* context)
+{
+    if(!obj){
+        return;
+    }
+    m_interfaceListener.SetTargetLevelPropertyCallback(status,obj->GetPath(),context);
+}
+void SpinSpeedLevelIntfControllerImpl::GetSelectableLevelsPropertyCB(QStatus status, ProxyBusObject* obj, const MsgArg& value, void* context)
+{
+
+    if(!obj){
+        return;
+    }
+
+    uint8_t *vals;
+    size_t numVals;
+    std::vector<uint8_t> levels;
+    value.Get("ay", &numVals, &vals);
+
+    cout << "Selectable Levels: " << endl;
+    for (size_t i = 0; i < numVals; ++i) {
+        levels.push_back(vals[i]);
+    }
+
+    m_interfaceListener.GetSelectableLevelsPropertyCallback(status,obj->GetPath(), levels, context);
+}
+
+
+} //namespace services
+} //namespace ajn
diff --git a/cpp/src/interfaces/operation/SpinSpeedLevelIntfControllerImpl.h b/cpp/src/interfaces/operation/SpinSpeedLevelIntfControllerImpl.h
new file mode 100644
index 0000000..14aa5b3
--- /dev/null
+++ b/cpp/src/interfaces/operation/SpinSpeedLevelIntfControllerImpl.h
@@ -0,0 +1,109 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#ifndef SPINSPEEDLEVELINTFCONTROLLERIMPL_H_
+#define SPINSPEEDLEVELINTFCONTROLLERIMPL_H_
+
+#include <alljoyn/Status.h>
+#include <alljoyn/BusAttachment.h>
+#include <alljoyn/hae/interfaces/InterfaceController.h>
+#include <alljoyn/hae/interfaces/operation/SpinSpeedLevelIntfController.h>
+
+namespace ajn {
+namespace services {
+
+class SpinSpeedLevelIntfControllerListener;
+class HaeProxyBusObject;
+
+/**
+ * SpinSpeedLevel Interface Controller implementation class
+ */
+class SpinSpeedLevelIntfControllerImpl : public InterfaceController, public SpinSpeedLevelIntfController {
+  public:
+    /**
+     * Create interface
+     */
+    static HaeInterface* CreateInterface(BusAttachment& busAttachment, InterfaceControllerListener& listener, HaeProxyBusObject& haeProxyObject);
+
+    /**
+     * Constructor of SpinSpeedLevelIntfControllerImpl
+     */
+    SpinSpeedLevelIntfControllerImpl(BusAttachment& busAttachment, SpinSpeedLevelIntfControllerListener& listener, HaeProxyBusObject& haeProxyObject);
+
+    /**
+     * Destructor of SpinSpeedLevelIntfControllerImpl
+     */
+    virtual ~SpinSpeedLevelIntfControllerImpl();
+
+    /**
+     * Initialize interface
+     * @return status
+     */
+    virtual QStatus Init();
+
+    /**
+     * Get bus attachment
+     * @return bus attachment
+     */
+    virtual BusAttachment& GetBusAttachment() const { return m_busAttachment; }
+
+    /**
+     * Get MaxLevel
+     * @param[in] context the context that is passed to the callback handler
+     * @return ER_OK on success
+     */
+    virtual QStatus GetMaxLevel(void* context = NULL);
+
+    /**
+     * Get TargetLevel
+     * @param[in] context the context that is passed to the callback handler
+     * @return ER_OK on success
+     */
+    virtual QStatus GetTargetLevel(void* context = NULL);
+
+    /**
+     * Set TargetLevel
+     * @param[in] targetLevel targetLevel
+     * @param[in] context the context that is passed to the callback handler
+     * @return ER_OK on success
+     */
+    virtual QStatus SetTargetLevel(const uint8_t targetLevel, void* context = NULL);
+
+    /**
+     * Get SelectableLevels
+     * @param[in] context the context that is passed to the callback handler
+     * @return ER_OK on success
+     */
+    virtual QStatus GetSelectableLevels(void* context = NULL);
+
+  private:
+    SpinSpeedLevelIntfControllerImpl();
+
+    void PropertiesChanged(ProxyBusObject& obj, const char* ifaceName, const MsgArg& changed, const MsgArg& invalidated, void* context);
+
+    void GetMaxLevelPropertyCB(QStatus status, ProxyBusObject* obj, const MsgArg& value, void* context);
+    void GetTargetLevelPropertyCB(QStatus status, ProxyBusObject* obj, const MsgArg& value, void* context);
+    void SetTargetLevelPropertyCB(QStatus status, ProxyBusObject* obj, void* context);
+    void GetSelectableLevelsPropertyCB(QStatus status, ProxyBusObject* obj, const MsgArg& value, void* context);
+
+    BusAttachment& m_busAttachment;
+    SpinSpeedLevelIntfControllerListener& m_interfaceListener;
+};
+
+} //namespace services
+} //namespace ajn
+
+#endif /* SPINSPEEDLEVELINTFCONTROLLERIMPL_H_ */
diff --git a/cpp/src/interfaces/operation/TimerInterface.cc b/cpp/src/interfaces/operation/TimerInterface.cc
new file mode 100644
index 0000000..e1ca783
--- /dev/null
+++ b/cpp/src/interfaces/operation/TimerInterface.cc
@@ -0,0 +1,82 @@
+/******************************************************************************
+ * Copyright (c) 2013-2014, AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#include <alljoyn/hae/LogModule.h>
+#include <alljoyn/hae/interfaces/operation/TimerInterface.h>
+
+namespace ajn {
+namespace services {
+
+const uint16_t TimerInterface::s_interfaceVersion = 1;
+
+// Below none secure xml is only for test
+const qcc::String TimerInterface::s_xml =
+"<node xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance' xsi:noNamespaceSchemaLocation='http://www.allseenalliance.org/schemas/introspect.xsd'>"
+"    <interface name='org.alljoyn.SmartSpaces.Operation.Timer'>"
+"        <description language='en'>This interface provides capability to monitor and control the times when the appliance executes its operations</description>"
+"        <annotation name='org.alljoyn.Bus.Secure' value='true'/>"
+"        <property name='Version' type='q' access='read'/>"
+"        <property name='ReferenceTimer' type='i' access='read'>"
+"            <annotation name='org.freedesktop.DBus.Property.EmitsChangedSignal' value='false'/>"
+"            <description language='en'>Time counter to be used as reference</description>"
+"        </property>"
+"        <property name='TargetTimeToStart' type='i' access='read'>"
+"            <annotation name='org.freedesktop.DBus.Property.EmitsChangedSignal' value='true'/>"
+"            <description language='en'>Time when the appliance is expected to start its operation</description>"
+"        </property>"
+"        <property name='TargetTimeToStop' type='i' access='read'>"
+"            <annotation name='org.freedesktop.DBus.Property.EmitsChangedSignal' value='true'/>"
+"            <description language='en'>Time when the appliance is expected to stop its operation</description>"
+"        </property>"
+"        <property name='EstimatedTimeToEnd' type='i' access='read'>"
+"            <annotation name='org.freedesktop.DBus.Property.EmitsChangedSignal' value='false'/>"
+"            <description language='en'>Time to the ends of appliance operation</description>"
+"        </property>"
+"        <property name='RunningTime' type='i' access='read'>"
+"            <annotation name='org.freedesktop.DBus.Property.EmitsChangedSignal' value='false'/>"
+"            <description language='en'>Time of current operation</description>"
+"        </property>"
+"        <property name='TargetDuration' type='i' access='read'>"
+"            <annotation name='org.freedesktop.DBus.Property.EmitsChangedSignal' value='true'/>"
+"            <description language='en'>Time representing the target duration of the operation as per user selection</description>"
+"        </property>"
+"        <method name='SetTargetTimeToStart'>"
+"            <arg name='targetTimeToStart' type='i' direction='in'>"
+"                <description language='en'>Time to be set</description>"
+"            </arg>"
+"        </method>"
+"        <method name='SetTargetTimeToStop'>"
+"             <arg name='targetTimeToStop' type='i' direction='in'>"
+"                <description language='en'>Time to be set</description>"
+"            </arg>"
+"        </method>"
+"    </interface>"
+"</node>"
+;
+
+const qcc::String TimerInterface::s_prop_Version = "Version";
+const qcc::String TimerInterface::s_prop_ReferenceTimer = "ReferenceTimer";
+const qcc::String TimerInterface::s_prop_TargetTimeToStart = "TargetTimeToStart";
+const qcc::String TimerInterface::s_prop_TargetTimeToStop = "TargetTimeToStop";
+const qcc::String TimerInterface::s_prop_EstimatedTimeToEnd = "EstimatedTimeToEnd";
+const qcc::String TimerInterface::s_prop_RunningTime = "RunningTime";
+const qcc::String TimerInterface::s_prop_TargetDuration = "TargetDuration";
+
+const qcc::String TimerInterface::s_method_SetTargetTimeToStart = "SetTargetTimeToStart";
+const qcc::String TimerInterface::s_method_SetTargetTimeToStop = "SetTargetTimeToStop";
+
+} //namespace services
+} //namespace ajn
diff --git a/cpp/src/interfaces/operation/TimerIntfControlleeImpl.cc b/cpp/src/interfaces/operation/TimerIntfControlleeImpl.cc
new file mode 100644
index 0000000..9978a89
--- /dev/null
+++ b/cpp/src/interfaces/operation/TimerIntfControlleeImpl.cc
@@ -0,0 +1,381 @@
+/******************************************************************************
+ * Copyright (c) 2013-2014, AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#include <qcc/Util.h>
+
+#include <alljoyn/hae/LogModule.h>
+#include <alljoyn/hae/HaeBusObject.h>
+#include <alljoyn/hae/interfaces/operation/TimerIntfControlleeListener.h>
+
+#include "TimerIntfControlleeImpl.h"
+
+using namespace qcc;
+using namespace std;
+
+namespace ajn {
+namespace services {
+
+HaeInterface* TimerIntfControlleeImpl::CreateInterface(BusAttachment& busAttachment, InterfaceControlleeListener& listener, HaeBusObject& haeBusObject)
+{
+    return new TimerIntfControlleeImpl(busAttachment, dynamic_cast<TimerIntfControlleeListener&>(listener), haeBusObject);
+}
+
+TimerIntfControlleeImpl::TimerIntfControlleeImpl(BusAttachment& busAttachment, TimerIntfControlleeListener& listener, HaeBusObject& haeBusObject) :
+    InterfaceControllee(haeBusObject),
+    m_busAttachment(busAttachment),
+    m_interfaceListener(listener),
+    m_referenceTimer(0),
+    m_targetTimeToStart(0),
+    m_targetTimeToStop(0)
+{
+}
+
+TimerIntfControlleeImpl::~TimerIntfControlleeImpl()
+{
+}
+
+QStatus TimerIntfControlleeImpl::Init()
+{
+    QStatus status = HaeInterface::Init();
+
+    const InterfaceDescription::Member* memberStart = m_interfaceDescription->GetMember(s_method_SetTargetTimeToStart.c_str());
+    MessageReceiver::MethodHandler methodHandlerStart = static_cast<MessageReceiver::MethodHandler>(&TimerIntfControlleeImpl::OnSetTargetTimeToStart);
+
+    m_methodHandlers.push_back(make_pair(memberStart, methodHandlerStart));
+
+    const InterfaceDescription::Member* memberStop = m_interfaceDescription->GetMember(s_method_SetTargetTimeToStop.c_str());
+    MessageReceiver::MethodHandler methodHandlerStop = static_cast<MessageReceiver::MethodHandler>(&TimerIntfControlleeImpl::OnSetTargetTimeToStop);
+
+    m_methodHandlers.push_back(make_pair(memberStop, methodHandlerStop));
+
+    return status;
+}
+
+QStatus TimerIntfControlleeImpl::OnGetProperty(const String propName, MsgArg& val)
+{
+    QStatus status = ER_OK;
+
+    if (!(s_prop_Version.compare(propName)))
+    {
+        val.typeId = ALLJOYN_UINT16;
+        val.v_uint16 = GetInterfaceVersion();
+    }
+    else
+    {
+        if (s_retrievingActualPropertyValue)
+        {
+            if(!s_prop_ReferenceTimer.compare(propName))
+            {
+
+                int32_t time;
+                status = m_interfaceListener.GetReferenceTimer(time);
+                if(status != ER_OK)
+                {
+                    //time = GetReferenceTimer();
+                    QCC_LogError(status, ("%s: Failed to get property", __func__));
+                }
+                else
+                {
+                    SetReferenceTimer(time);
+                }
+                val.typeId = ALLJOYN_INT32;
+                val.v_int32 = time;
+            }
+            else if (!s_prop_TargetTimeToStart.compare(propName))
+            {
+                int32_t time;
+                status = m_interfaceListener.GetTargetTimeToStart(time);
+                if(status != ER_OK)
+                {
+                    //time = GetReferenceTimer();
+                    QCC_LogError(status, ("%s: Failed to get property", __func__));
+                }
+                else
+                {
+                }
+                val.typeId = ALLJOYN_INT32;
+                val.v_int32 = time;
+            }
+            else if (!s_prop_TargetTimeToStop.compare(propName))
+            {
+                int32_t time;
+                status = m_interfaceListener.GetTargetTimeToStop(time);
+                if(status != ER_OK)
+                {
+                    //time = GetReferenceTimer();
+                    QCC_LogError(status, ("%s: Failed to get property", __func__));
+                }
+                else
+                {
+                    time = 0;
+                }
+                val.typeId = ALLJOYN_INT32;
+                val.v_int32 = time;
+            }
+            else if (!s_prop_RunningTime.compare(propName))
+            {
+                int32_t time;
+                status = m_interfaceListener.GetRunningTime(time);
+                if(status != ER_OK)
+                {
+                    //time = GetReferenceTimer();
+                    QCC_LogError(status, ("%s: Failed to get property", __func__));
+                }
+                else
+                {
+                    time = 0;
+                }
+                val.typeId = ALLJOYN_INT32;
+                val.v_int32 = time;
+            }
+            else if (!s_prop_TargetDuration.compare(propName))
+            {
+                int32_t time;
+                status = m_interfaceListener.GetTargetDuration(time);
+                if(status != ER_OK)
+                {
+                    //time = GetReferenceTimer();
+                    QCC_LogError(status, ("%s: Failed to get property", __func__));
+                }
+                else
+                {
+                    SetTargetDuration(time);
+                }
+                val.typeId = ALLJOYN_INT32;
+                val.v_int32 = time;
+            }
+            else if (!s_prop_EstimatedTimeToEnd.compare(propName))
+            {
+                int32_t time;
+                status = m_interfaceListener.GetEstimatedTimeToEnd(time);
+                if(status != ER_OK)
+                {
+                    //time = GetReferenceTimer();
+                    QCC_LogError(status, ("%s: Failed to get property", __func__));
+                }
+                else
+                {
+                    SetEstimatedTimeToEnd(time);
+                }
+                val.typeId = ALLJOYN_INT32;
+                val.v_int32 = time;
+            }
+            else
+            {
+                status = ER_BUS_NO_SUCH_PROPERTY;
+            }
+        }
+        else
+        {
+            if(!s_prop_ReferenceTimer.compare(propName))
+            {
+                int32_t time = GetReferenceTimer();
+                val.typeId = ALLJOYN_INT32;
+                val.v_int32 = time;
+            }
+            else if (!s_prop_TargetTimeToStart.compare(propName))
+            {
+                int32_t time = GetTargetTimeToStart();
+                val.typeId = ALLJOYN_INT32;
+                val.v_int32 = time;
+            }
+            else if (!s_prop_TargetTimeToStop.compare(propName))
+            {
+                int32_t time = GetTargetTimeToStop();
+                val.typeId = ALLJOYN_INT32;
+                val.v_int32 = time;
+            }
+            else if (!s_prop_RunningTime.compare(propName))
+            {
+                int32_t time = GetRunningTime();
+                val.typeId = ALLJOYN_INT32;
+                val.v_int32 = time;
+            }
+            else if (!s_prop_TargetDuration.compare(propName))
+            {
+                int32_t time = GetTargetDuration();
+                val.typeId = ALLJOYN_INT32;
+                val.v_int32 = time;
+            }
+            else if (!s_prop_EstimatedTimeToEnd.compare(propName))
+            {
+                int32_t time = GetEstimatedTimeToEnd();
+                val.typeId = ALLJOYN_INT32;
+                val.v_int32 = time;
+            }
+            else
+            {
+                status = ER_BUS_NO_SUCH_PROPERTY;
+            }
+        }
+    }
+    return status;
+}
+
+QStatus TimerIntfControlleeImpl::OnSetProperty(const String propName, MsgArg& val)
+{
+    QStatus status = ER_OK;
+
+    return status;
+}
+
+void TimerIntfControlleeImpl::OnMethodHandler(const InterfaceDescription::Member* member, Message& msg)
+{
+    QStatus status = ER_OK;
+    bool isFound = false;
+    MethodHandlers::const_iterator it;
+    for (it = m_methodHandlers.begin(); it != m_methodHandlers.end(); ++it) {
+        if (it->first == member) {
+            MessageReceiver::MethodHandler handler = it->second;
+            (this->*handler)(member, msg);
+            isFound = true;
+            break;
+        }
+    }
+
+    if (!isFound) {
+        status = ER_BUS_METHOD_CALL_ABORTED;
+        QCC_LogError(status, ("%s: could not found method handler.", __func__));
+        m_busObject.ReplyMethodCall(msg, status);
+    }
+}
+
+
+QStatus TimerIntfControlleeImpl::SetReferenceTimer(const int32_t time)
+{
+    if(m_referenceTimer != time)
+    {
+        MsgArg arg;
+        arg.typeId = ALLJOYN_INT32;
+        arg.v_int32 = time;
+        m_busObject.EmitPropChanged(GetInterfaceName().c_str(), s_prop_ReferenceTimer.c_str(), arg,0,ALLJOYN_FLAG_GLOBAL_BROADCAST);
+        m_referenceTimer = time;
+    }
+    return ER_OK;
+}
+
+QStatus TimerIntfControlleeImpl::SetEstimatedTimeToEnd(const int32_t time)
+{
+//    if(m != time)
+//    {
+//        MsgArg arg;
+//        arg.typeId = ALLJOYN_INT32;
+//        arg.v_int32 = time;
+//        m_busObject.EmitPropChanged(GetInterfaceName().c_str(), s_prop_ReferenceTimer.c_str(), arg,0,ALLJOYN_FLAG_GLOBAL_BROADCAST);
+//        m_referenceTimer = time;
+//    }
+    return ER_OK;
+}
+
+QStatus TimerIntfControlleeImpl::SetRunningTime(const int32_t time)
+{
+//    if(m_referenceTimer != time)
+//    {
+//        MsgArg arg;
+//        arg.typeId = ALLJOYN_INT32;
+//        arg.v_int32 = time;
+//        m_busObject.EmitPropChanged(GetInterfaceName().c_str(), s_prop_ReferenceTimer.c_str(), arg,0,ALLJOYN_FLAG_GLOBAL_BROADCAST);
+//        m_referenceTimer = time;
+//    }
+    return ER_OK;
+}
+
+QStatus TimerIntfControlleeImpl::SetTargetDuration(const int32_t time)
+{
+//    if(m_referenceTimer != time)
+//    {
+//        MsgArg arg;
+//        arg.typeId = ALLJOYN_INT32;
+//        arg.v_int32 = time;
+//        m_busObject.EmitPropChanged(GetInterfaceName().c_str(), s_prop_ReferenceTimer.c_str(), arg,0,ALLJOYN_FLAG_GLOBAL_BROADCAST);
+//        m_referenceTimer = time;
+//    }
+    return ER_OK;
+}
+
+void TimerIntfControlleeImpl::OnSetTargetTimeToStart(const InterfaceDescription::Member* member, Message& msg)
+{
+    cout << "TimerIntfControlleeImpl::OnSetTargetTimeToStart" << endl;
+    QStatus status = ER_OK;
+
+    const MsgArg* args = NULL;
+    size_t numArgs = 0;
+
+    msg->GetArgs(numArgs, args);
+
+    if (numArgs == 1)
+    {
+        if(args[0].typeId != ALLJOYN_INT32)
+            m_busObject.ReplyMethodCall(msg, ER_BAD_ARG_1);
+        int32_t time = args[0].v_int32;
+        ErrorCode errorCode = NOT_ERROR;
+        status = m_interfaceListener.OnSetTargetTimeToStart(time, errorCode);
+        if (status == ER_OK) {
+            m_targetTimeToStart = time;
+            m_busObject.ReplyMethodCall(msg, status);
+        } else {
+            if (errorCode == NOT_ERROR) {
+                QCC_LogError(status, ("%s: status is not ER_OK, but errorCode was not set.", __func__));
+                m_busObject.ReplyMethodCall(msg, status);
+            } else {
+                    m_busObject.ReplyMethodCall(msg, HaeInterface::GetInterfaceErrorName(errorCode).c_str(),
+                            HaeInterface::GetInterfaceErrorMessage(errorCode).c_str());
+            }
+        }
+    }
+    else
+    {
+        m_busObject.ReplyMethodCall(msg, ER_INVALID_DATA);
+    }
+}
+void TimerIntfControlleeImpl::OnSetTargetTimeToStop(const InterfaceDescription::Member* member, Message& msg)
+{
+    cout << "TimerIntfControlleeImpl::OnSetTargetTimeToStop" << endl;
+    QStatus status = ER_OK;
+
+    const MsgArg* args = NULL;
+    size_t numArgs = 0;
+
+    msg->GetArgs(numArgs, args);
+
+    if (numArgs == 1)
+    {
+        if(args[0].typeId != ALLJOYN_INT32)
+            m_busObject.ReplyMethodCall(msg, ER_BAD_ARG_1);
+        int32_t time = args[0].v_int32;
+        ErrorCode errorCode = NOT_ERROR;
+        status = m_interfaceListener.OnSetTargetTimeToStop(time, errorCode);
+        if (status == ER_OK) {
+            m_targetTimeToStop = time;
+            m_busObject.ReplyMethodCall(msg, status);
+        } else {
+            if (errorCode == NOT_ERROR) {
+                QCC_LogError(status, ("%s: status is not ER_OK, but errorCode was not set.", __func__));
+                m_busObject.ReplyMethodCall(msg, status);
+            } else {
+                    m_busObject.ReplyMethodCall(msg, HaeInterface::GetInterfaceErrorName(errorCode).c_str(),
+                            HaeInterface::GetInterfaceErrorMessage(errorCode).c_str());
+            }
+        }
+    }
+    else
+    {
+        m_busObject.ReplyMethodCall(msg, ER_INVALID_DATA);
+    }
+}
+
+} //namespace services
+} //namespace ajn
diff --git a/cpp/src/interfaces/operation/TimerIntfControlleeImpl.h b/cpp/src/interfaces/operation/TimerIntfControlleeImpl.h
new file mode 100644
index 0000000..2c29493
--- /dev/null
+++ b/cpp/src/interfaces/operation/TimerIntfControlleeImpl.h
@@ -0,0 +1,129 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#ifndef TIMERINTFCONTROLLEEIMPL_H_
+#define TIMERINTFCONTROLLEEIMPL_H_
+
+#include <alljoyn/Status.h>
+#include <alljoyn/BusAttachment.h>
+#include <alljoyn/InterfaceDescription.h>
+#include <alljoyn/hae/interfaces/InterfaceControllee.h>
+#include <alljoyn/hae/interfaces/InterfaceControlleeListener.h>
+#include <alljoyn/hae/interfaces/operation/TimerIntfControllee.h>
+
+namespace ajn {
+namespace services {
+
+class TimerIntfControlleeListener;
+class HaeBusObject;
+
+/**
+ * Timer Interface Controllee implementation class
+ */
+class TimerIntfControlleeImpl : public InterfaceControllee, public TimerIntfControllee {
+  public:
+    /**
+     * Create interface
+     */
+    static HaeInterface* CreateInterface(BusAttachment& busAttachment, InterfaceControlleeListener& listener, HaeBusObject& haeBusObject);
+
+    /**
+     * Constructor of TimerIntfControlleeImpl
+     */
+    TimerIntfControlleeImpl(BusAttachment& busAttachment, TimerIntfControlleeListener& listener, HaeBusObject& haeBusObject);
+
+    /**
+     * Destructor of TimerIntfControlleeImpl
+     */
+    virtual ~TimerIntfControlleeImpl();
+
+    /**
+     * Initialize interface
+     * @return status
+     */
+     virtual QStatus Init();
+
+    /**
+     * a callback function for getting property.
+     * @param propName   Identifies the property to get
+     * @param[out] val   Returns the property value. The type of this value is the actual value type.
+     * @return status
+     */
+    virtual QStatus OnGetProperty(const qcc::String propName, MsgArg& val);
+
+    /**
+     * a callback function for setting property.
+     * @param propName  Identifies the property to set
+     * @param val       The property value to set. The type of this value is the actual value type.
+     */
+    virtual QStatus OnSetProperty(const qcc::String propName, MsgArg& val);
+
+    /**
+     * method handler
+     * @param member    Method interface member entry.
+     * @param message   The received method call message.
+     */
+    virtual void OnMethodHandler(const InterfaceDescription::Member* member, Message& msg);
+
+    /**
+     * Get method handlers
+     * @return MethodHandlers
+     */
+    virtual const MethodHandlers& GetMethodHanders() const { return m_methodHandlers; }
+
+    /**
+     * Get bus attachment
+     * @return bus attachment
+     */
+    virtual BusAttachment& GetBusAttachment() const { return m_busAttachment; }
+
+    virtual const int32_t GetReferenceTimer() const {return m_referenceTimer; }
+
+    virtual QStatus SetReferenceTimer(const int32_t time);
+
+    virtual const int32_t GetTargetTimeToStart() const { return m_targetTimeToStart; }
+
+    virtual const int32_t GetTargetTimeToStop() const { return m_targetTimeToStop; }
+
+    virtual const int32_t GetEstimatedTimeToEnd() const { return (m_targetTimeToStop - m_referenceTimer); }
+
+    virtual QStatus SetEstimatedTimeToEnd(const int32_t time);
+
+    virtual const int32_t GetRunningTime() const { return (m_referenceTimer - m_targetTimeToStart); }
+
+    virtual QStatus SetRunningTime(const int32_t time);
+
+    virtual const int32_t GetTargetDuration() const { return (m_targetTimeToStop - m_targetTimeToStart); }
+
+    virtual QStatus SetTargetDuration(const int32_t time);
+
+    void OnSetTargetTimeToStart(const InterfaceDescription::Member* member, Message& msg);
+    void OnSetTargetTimeToStop(const InterfaceDescription::Member* member, Message& msg);
+  private:
+    TimerIntfControlleeImpl();
+
+    BusAttachment& m_busAttachment;
+    TimerIntfControlleeListener& m_interfaceListener;
+    MethodHandlers m_methodHandlers;
+    int32_t m_referenceTimer;
+    int32_t m_targetTimeToStart;
+    int32_t m_targetTimeToStop;
+};
+
+} //namespace services
+} //namespace ajn
+
+#endif /* TIMERINTFCONTROLLEEIMPL_H_ */
diff --git a/cpp/src/interfaces/operation/TimerIntfControllerImpl.cc b/cpp/src/interfaces/operation/TimerIntfControllerImpl.cc
new file mode 100644
index 0000000..8d3e742
--- /dev/null
+++ b/cpp/src/interfaces/operation/TimerIntfControllerImpl.cc
@@ -0,0 +1,292 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#include <qcc/Util.h>
+
+#include <alljoyn/hae/LogModule.h>
+#include <alljoyn/hae/HaeProxyBusObject.h>
+#include <alljoyn/hae/interfaces/operation/TimerIntfControllerListener.h>
+
+#include "TimerIntfControllerImpl.h"
+
+using namespace qcc;
+using namespace std;
+
+namespace ajn {
+namespace services {
+
+HaeInterface* TimerIntfControllerImpl::CreateInterface(BusAttachment& busAttachment, InterfaceControllerListener& listener, HaeProxyBusObject& haeProxyObject)
+{
+    return new TimerIntfControllerImpl(busAttachment, dynamic_cast<TimerIntfControllerListener&>(listener), haeProxyObject);
+}
+
+TimerIntfControllerImpl::TimerIntfControllerImpl(BusAttachment& busAttachment, TimerIntfControllerListener& listener, HaeProxyBusObject& haeProxyObject) :
+    InterfaceController(haeProxyObject),
+    m_busAttachment(busAttachment),
+    m_interfaceListener(listener)
+{
+}
+
+TimerIntfControllerImpl::~TimerIntfControllerImpl()
+{
+}
+
+QStatus TimerIntfControllerImpl::Init()
+{
+    QStatus status = HaeInterface::Init();
+    if (ER_OK != status) {
+        QCC_LogError(status, ("%s: Interface init failed.", __func__));
+        return status;
+    }
+
+    status = m_proxyObject.RegisterPropertiesChangedListener(GetInterfaceName().c_str(), NULL, 0, *this, NULL);
+    if (ER_OK != status) {
+        QCC_LogError(status, ("%s: RegisterPropertiesChangedListener failed.", __func__));
+    }
+
+    return status;
+}
+
+void TimerIntfControllerImpl::PropertiesChanged(ProxyBusObject& obj, const char* ifaceName, const MsgArg& changed, const MsgArg& invalidated, void* context)
+{
+    MsgArg* entries;
+    size_t numEntries;
+
+    changed.Get("a{sv}", &numEntries, &entries);
+    for (size_t i = 0; i < numEntries; ++i)
+    {
+        const char* propName;
+        MsgArg* propValue;
+        entries[i].Get("{sv}", &propName, &propValue);
+        String propNameStr(propName);
+
+        if (!s_prop_ReferenceTimer.compare(propNameStr))
+        {
+            if (propValue->typeId == ALLJOYN_INT32)
+            {
+                int32_t level = propValue->v_int32;
+                m_interfaceListener.OnReferenceTimerPropertyChanged(obj.GetPath(), level);
+            }
+        }
+        else if (!s_prop_TargetTimeToStart.compare(propNameStr))
+        {
+            if (propValue->typeId == ALLJOYN_INT32)
+            {
+                int32_t level = propValue->v_int32;
+                m_interfaceListener.OnTargetTimeToStartPropertyChanged(obj.GetPath(), level);
+            }
+        }
+        else if (!s_prop_TargetTimeToStop.compare(propNameStr))
+        {
+            if (propValue->typeId == ALLJOYN_INT32)
+            {
+                int32_t level = propValue->v_int32;
+                m_interfaceListener.OnTargetTimeToStopPropertyChanged(obj.GetPath(), level);
+            }
+        }
+        else if (!s_prop_RunningTime.compare(propNameStr))
+        {
+            if (propValue->typeId == ALLJOYN_INT32)
+            {
+                int32_t level = propValue->v_int32;
+                m_interfaceListener.OnRunningTimePropertyChanged(obj.GetPath(), level);
+            }
+        }
+        else if (!s_prop_EstimatedTimeToEnd.compare(propNameStr))
+        {
+            if (propValue->typeId == ALLJOYN_INT32)
+            {
+                int32_t level = propValue->v_int32;
+                m_interfaceListener.OnEstimatedTimeToEndPropertyChanged(obj.GetPath(), level);
+            }
+        }
+        else if (!s_prop_TargetDuration.compare(propNameStr))
+        {
+            if (propValue->typeId == ALLJOYN_INT32)
+            {
+                int32_t level = propValue->v_int32;
+                m_interfaceListener.OnTargetDurationPropertyChanged(obj.GetPath(), level);
+            }
+        }
+    }
+}
+
+QStatus TimerIntfControllerImpl::GetReferenceTimer(void* context )
+{
+    QStatus status = ER_OK;
+
+    status = m_proxyObject.GetPropertyAsync(GetInterfaceName().c_str(), s_prop_ReferenceTimer.c_str(),this, (HaeProxyBusObject::Listener::GetPropertyCB)&TimerIntfControllerImpl::GetReferenceTimerCB,context);
+
+    return status;
+}
+
+QStatus TimerIntfControllerImpl::GetTargetTimeToStart(void* context )
+{
+    QStatus status = ER_OK;
+
+    status = m_proxyObject.GetPropertyAsync(GetInterfaceName().c_str(), s_prop_TargetTimeToStart.c_str(),this, (HaeProxyBusObject::Listener::GetPropertyCB)&TimerIntfControllerImpl::GetTargetTimeToStartCB,context);
+
+    return status;
+}
+
+QStatus TimerIntfControllerImpl::GetTargetTimeToStop(void* context )
+{
+    QStatus status = ER_OK;
+
+    status = m_proxyObject.GetPropertyAsync(GetInterfaceName().c_str(), s_prop_TargetTimeToStop.c_str(),this, (HaeProxyBusObject::Listener::GetPropertyCB)&TimerIntfControllerImpl::GetTargetTimeToStopCB,context);
+
+    return status;
+}
+
+QStatus TimerIntfControllerImpl::GetEstimatedTimeToEnd(void* context )
+{
+    QStatus status = ER_OK;
+
+    status = m_proxyObject.GetPropertyAsync(GetInterfaceName().c_str(), s_prop_EstimatedTimeToEnd.c_str(),this, (HaeProxyBusObject::Listener::GetPropertyCB)&TimerIntfControllerImpl::GetEstimatedTimeToEndCB,context);
+
+    return status;
+}
+
+QStatus TimerIntfControllerImpl::GetRunningTime(void* context )
+{
+    QStatus status = ER_OK;
+
+    status = m_proxyObject.GetPropertyAsync(GetInterfaceName().c_str(), s_prop_RunningTime.c_str(),this, (HaeProxyBusObject::Listener::GetPropertyCB)&TimerIntfControllerImpl::GetRunningTimeCB,context);
+
+    return status;
+}
+
+QStatus TimerIntfControllerImpl::GetTargetDuration(void* context )
+{
+    QStatus status = ER_OK;
+
+    status = m_proxyObject.GetPropertyAsync(GetInterfaceName().c_str(), s_prop_TargetDuration.c_str(),this, (HaeProxyBusObject::Listener::GetPropertyCB)&TimerIntfControllerImpl::GetTargetDurationCB,context);
+
+    return status;
+}
+
+QStatus TimerIntfControllerImpl::SetTargetTimeToStart(int32_t time, void* context )
+{
+    QStatus status = ER_OK;
+
+    MsgArg args[1];
+    args[0].typeId = ALLJOYN_INT32;
+    args[0].v_int32 = time;
+    status = m_proxyObject.MethodCallAsync(GetInterfaceName().c_str(), s_method_SetTargetTimeToStart.c_str(), this, (MessageReceiver::ReplyHandler)&TimerIntfControllerImpl::SetTargetTimeToStartReplyHandler, args, 1, context);
+
+    return status;
+
+}
+
+QStatus TimerIntfControllerImpl::SetTargetTimeToStop(int32_t time, void* context )
+{
+    QStatus status = ER_OK;
+
+    MsgArg args[1];
+    args[0].typeId = ALLJOYN_INT32;
+    args[0].v_int32 = time;
+    status = m_proxyObject.MethodCallAsync(GetInterfaceName().c_str(), s_method_SetTargetTimeToStop.c_str(), this, (MessageReceiver::ReplyHandler)&TimerIntfControllerImpl::SetTargetTimeToStopReplyHandler, args, 1, context);
+
+    return status;
+}
+
+void TimerIntfControllerImpl::GetReferenceTimerCB(QStatus status, ProxyBusObject* obj, const MsgArg& value, void* context)
+{
+    if(!obj) {
+        return;
+    }
+    int32_t time;
+    value.Get("i",&time);
+
+    m_interfaceListener.OnResponseGetReferenceTimer(status,obj->GetPath().c_str(),time,context);
+
+}
+void TimerIntfControllerImpl::GetTargetTimeToStartCB(QStatus status, ProxyBusObject* obj, const MsgArg& value, void* context)
+{
+    if(!obj) {
+        return;
+    }
+    int32_t time;
+    value.Get("i",&time);
+
+    m_interfaceListener.OnResponseGetTargetTimeToStart(status,obj->GetPath().c_str(),time,context);
+}
+void TimerIntfControllerImpl::GetTargetTimeToStopCB(QStatus status, ProxyBusObject* obj, const MsgArg& value, void* context)
+{
+    if(!obj) {
+        return;
+    }
+    int32_t time;
+    value.Get("i",&time);
+
+    m_interfaceListener.OnResponseGetTargetTimeToStop(status,obj->GetPath().c_str(),time,context);
+}
+void TimerIntfControllerImpl::GetEstimatedTimeToEndCB(QStatus status, ProxyBusObject* obj, const MsgArg& value, void* context)
+{
+    if(!obj) {
+        return;
+    }
+    int32_t time;
+    value.Get("i",&time);
+
+    m_interfaceListener.OnResponseGetEstimatedTimeToEnd(status,obj->GetPath().c_str(),time,context);
+}
+void TimerIntfControllerImpl::GetRunningTimeCB(QStatus status, ProxyBusObject* obj, const MsgArg& value, void* context)
+{
+    if(!obj) {
+        return;
+    }
+    int32_t time;
+    value.Get("i",&time);
+
+    m_interfaceListener.OnResponseGetRunningTime(status,obj->GetPath().c_str(),time,context);
+}
+void TimerIntfControllerImpl::GetTargetDurationCB(QStatus status, ProxyBusObject* obj, const MsgArg& value, void* context)
+{
+    if(!obj) {
+        return;
+    }
+    int32_t time;
+    value.Get("i",&time);
+
+    m_interfaceListener.OnResponseGetTargetDuration(status,obj->GetPath().c_str(),time,context);
+}
+
+void TimerIntfControllerImpl::SetTargetTimeToStartReplyHandler(Message& message, void* context)
+{
+    qcc::String errorMessage;
+    const char* errorName = message->GetErrorName(&errorMessage);
+    QStatus status = ER_OK;
+    if (message->GetType() != MESSAGE_METHOD_RET)
+    {
+        status = ER_FAIL;
+    }
+    m_interfaceListener.OnResponseSetTargetTimerToStart(status, m_proxyObject.GetPath(), context, errorName, errorMessage.c_str());
+}
+void TimerIntfControllerImpl::SetTargetTimeToStopReplyHandler(Message& message, void* context)
+{
+    qcc::String errorMessage;
+    const char* errorName = message->GetErrorName(&errorMessage);
+    QStatus status = ER_OK;
+    if (message->GetType() != MESSAGE_METHOD_RET)
+    {
+        status = ER_FAIL;
+    }
+    m_interfaceListener.OnResponseSetTargetTimerToStop(status, m_proxyObject.GetPath(), context, errorName, errorMessage.c_str());
+}
+
+} //namespace services
+} //namespace ajn
diff --git a/cpp/src/interfaces/operation/TimerIntfControllerImpl.h b/cpp/src/interfaces/operation/TimerIntfControllerImpl.h
new file mode 100644
index 0000000..f9951b7
--- /dev/null
+++ b/cpp/src/interfaces/operation/TimerIntfControllerImpl.h
@@ -0,0 +1,102 @@
+/******************************************************************************
+ * Copyright AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#ifndef TIMERINTFCONTROLLERIMPL_H_
+#define TIMERINTFCONTROLLERIMPL_H_
+
+#include <alljoyn/Status.h>
+#include <alljoyn/BusAttachment.h>
+#include <alljoyn/hae/interfaces/InterfaceController.h>
+#include <alljoyn/hae/interfaces/operation/TimerIntfController.h>
+
+namespace ajn {
+namespace services {
+
+class TimerIntfControllerListener;
+class HaeProxyBusObject;
+
+/**
+ * Timer Interface Controller implementation class
+ */
+class TimerIntfControllerImpl : public InterfaceController, public TimerIntfController {
+  public:
+    /**
+     * Create interface
+     */
+    static HaeInterface* CreateInterface(BusAttachment& busAttachment, InterfaceControllerListener& listener, HaeProxyBusObject& haeProxyObject);
+
+    /**
+     * Constructor of TimerIntfControllerImpl
+     */
+    TimerIntfControllerImpl(BusAttachment& busAttachment, TimerIntfControllerListener& listener, HaeProxyBusObject& haeProxyObject);
+
+    /**
+     * Destructor of TimerIntfControllerImpl
+     */
+    virtual ~TimerIntfControllerImpl();
+
+    /**
+     * Initialize interface
+     * @return status
+     */
+    virtual QStatus Init();
+
+    /**
+     * Get bus attachment
+     * @return bus attachment
+     */
+    virtual BusAttachment& GetBusAttachment() const { return m_busAttachment; }
+
+
+    virtual QStatus GetReferenceTimer(void* context );
+
+    virtual QStatus GetTargetTimeToStart(void* context );
+
+    virtual QStatus GetTargetTimeToStop(void* context );
+
+    virtual QStatus GetEstimatedTimeToEnd(void* context );
+
+    virtual QStatus GetRunningTime(void* context );
+
+    virtual QStatus GetTargetDuration(void* context );
+
+    virtual QStatus SetTargetTimeToStart(int32_t time, void* context );
+
+    virtual QStatus SetTargetTimeToStop(int32_t time, void* context );
+
+  private:
+    TimerIntfControllerImpl();
+
+    void PropertiesChanged(ProxyBusObject& obj, const char* ifaceName, const MsgArg& changed, const MsgArg& invalidated, void* context);
+
+    void GetReferenceTimerCB(QStatus status, ProxyBusObject* obj, const MsgArg& value, void* context);
+    void GetTargetTimeToStartCB(QStatus status, ProxyBusObject* obj, const MsgArg& value, void* context);
+    void GetTargetTimeToStopCB(QStatus status, ProxyBusObject* obj, const MsgArg& value, void* context);
+    void GetEstimatedTimeToEndCB(QStatus status, ProxyBusObject* obj, const MsgArg& value, void* context);
+    void GetRunningTimeCB(QStatus status, ProxyBusObject* obj, const MsgArg& value, void* context);
+    void GetTargetDurationCB(QStatus status, ProxyBusObject* obj, const MsgArg& value, void* context);
+
+    void SetTargetTimeToStartReplyHandler(Message& message, void* context);
+    void SetTargetTimeToStopReplyHandler(Message& message, void* context);
+
+    BusAttachment& m_busAttachment;
+    TimerIntfControllerListener& m_interfaceListener;
+};
+
+} //namespace services
+} //namespace ajn
+
+#endif /* TIMERINTFCONTROLLERIMPL_H_ */
-- 
2.5.0

